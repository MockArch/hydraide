// =============================================================================
// üß† HydraService ‚Äì gRPC Interface for Hydra 2.0
// =============================================================================
//
// This file defines the complete public gRPC API for the Hydra data engine.
//
// Hydra is a high-performance, real-time, distributed data engine
// built for ultra-fast, fine-grained control of your storage, memory, and compute needs.
// It powers search, queueing, caching, analytics, and more ‚Äî all in one.
//
// üîí This interface is used to communicate with a closed-source Hydra server.
// You are free to build your own clients (SDKs) using this specification,
// but the server binary is licensed separately under commercial terms.
//
// üìú License: Apache 2.0 for this interface definition only
// üí° Learn more: https://github.com/hydraide/hydraide
// ‚úâ Contact: peter.gebri@trendizz.com
//
// =============================================================================

// Code generated by protoc-gen-go-grpc. DO NOT EDIT.
// versions:
// - protoc-gen-go-grpc v1.4.0
// - protoc             v3.21.12
// source: hydra.proto

package hydrapb

import (
	context "context"
	grpc "google.golang.org/grpc"
	codes "google.golang.org/grpc/codes"
	status "google.golang.org/grpc/status"
)

// This is a compile-time assertion to ensure that this generated file
// is compatible with the grpc package it is being compiled against.
// Requires gRPC-Go v1.62.0 or later.
const _ = grpc.SupportPackageIsVersion8

const (
	HydraService_Heartbeat_FullMethodName               = "/hydrapb.HydraService/Heartbeat"
	HydraService_Lock_FullMethodName                    = "/hydrapb.HydraService/Lock"
	HydraService_Unlock_FullMethodName                  = "/hydrapb.HydraService/Unlock"
	HydraService_RegisterSwamp_FullMethodName           = "/hydrapb.HydraService/RegisterSwamp"
	HydraService_DeRegisterSwamp_FullMethodName         = "/hydrapb.HydraService/DeRegisterSwamp"
	HydraService_Set_FullMethodName                     = "/hydrapb.HydraService/Set"
	HydraService_Get_FullMethodName                     = "/hydrapb.HydraService/Get"
	HydraService_GetAll_FullMethodName                  = "/hydrapb.HydraService/GetAll"
	HydraService_GetByIndex_FullMethodName              = "/hydrapb.HydraService/GetByIndex"
	HydraService_ShiftExpiredTreasures_FullMethodName   = "/hydrapb.HydraService/ShiftExpiredTreasures"
	HydraService_Destroy_FullMethodName                 = "/hydrapb.HydraService/Destroy"
	HydraService_Delete_FullMethodName                  = "/hydrapb.HydraService/Delete"
	HydraService_Count_FullMethodName                   = "/hydrapb.HydraService/Count"
	HydraService_IsSwampExist_FullMethodName            = "/hydrapb.HydraService/IsSwampExist"
	HydraService_IsKeyExist_FullMethodName              = "/hydrapb.HydraService/IsKeyExist"
	HydraService_SubscribeToEvents_FullMethodName       = "/hydrapb.HydraService/SubscribeToEvents"
	HydraService_SubscribeToInfo_FullMethodName         = "/hydrapb.HydraService/SubscribeToInfo"
	HydraService_Uint32SlicePush_FullMethodName         = "/hydrapb.HydraService/Uint32SlicePush"
	HydraService_Uint32SliceDelete_FullMethodName       = "/hydrapb.HydraService/Uint32SliceDelete"
	HydraService_Uint32SliceSize_FullMethodName         = "/hydrapb.HydraService/Uint32SliceSize"
	HydraService_Uint32SliceIsValueExist_FullMethodName = "/hydrapb.HydraService/Uint32SliceIsValueExist"
	HydraService_IncrementInt8_FullMethodName           = "/hydrapb.HydraService/IncrementInt8"
	HydraService_IncrementInt16_FullMethodName          = "/hydrapb.HydraService/IncrementInt16"
	HydraService_IncrementInt32_FullMethodName          = "/hydrapb.HydraService/IncrementInt32"
	HydraService_IncrementInt64_FullMethodName          = "/hydrapb.HydraService/IncrementInt64"
	HydraService_IncrementUint8_FullMethodName          = "/hydrapb.HydraService/IncrementUint8"
	HydraService_IncrementUint16_FullMethodName         = "/hydrapb.HydraService/IncrementUint16"
	HydraService_IncrementUint32_FullMethodName         = "/hydrapb.HydraService/IncrementUint32"
	HydraService_IncrementUint64_FullMethodName         = "/hydrapb.HydraService/IncrementUint64"
	HydraService_IncrementFloat32_FullMethodName        = "/hydrapb.HydraService/IncrementFloat32"
	HydraService_IncrementFloat64_FullMethodName        = "/hydrapb.HydraService/IncrementFloat64"
)

// HydraServiceClient is the client API for HydraService service.
//
// For semantics around ctx use and closing/ending streaming RPCs, please refer to https://pkg.go.dev/google.golang.org/grpc/?tab=doc#ClientConn.NewStream.
type HydraServiceClient interface {
	// Heartbeat checks if the Hydra server is alive.
	// The client sends a Ping and expects a Pong response.
	Heartbeat(ctx context.Context, in *HeartbeatRequest, opts ...grpc.CallOption) (*HeartbeatResponse, error)
	// Lock allows you to create a mutex-like lock based on a given key.
	// It queues all lock requests for the same key and only returns once the lock is granted.
	// This mechanism enables swamp- or treasure-level locking to coordinate access between microservices.
	//
	// ‚ö†Ô∏è Note: Locking is logical only ‚Äî it does not block the actual data access unless your logic respects the lock.
	// You must explicitly use the Lock/Unlock sequence around relevant operations.
	//
	// Required: TTL must be set (timeout in milliseconds).
	// If the lock cannot be acquired within this TTL, the call returns an error.
	// If a lock is granted, a LockID is returned, which must be passed to Unlock.
	Lock(ctx context.Context, in *LockRequest, opts ...grpc.CallOption) (*LockResponse, error)
	// Unlock releases the previously granted lock based on the key and LockID.
	// If the LockID is invalid or does not match an existing lock, the call fails.
	//
	// It is crucial to always unlock your locks to avoid deadlocks.
	// If the TTL expires, the lock is automatically released.
	Unlock(ctx context.Context, in *UnlockRequest, opts ...grpc.CallOption) (*UnlockResponse, error)
	// RegisterSwamp registers a new swamp pattern in the Hydra system.
	// A swamp pattern defines the namespace (Sanctuary/Realm/Swamp) and behavior of a storage unit.
	//
	// You can configure:
	// - Whether the swamp lives in memory or on disk
	// - How long it should stay alive without access (CloseAfterIdle)
	// - How frequently it should flush to disk (WriteInterval)
	// - Maximum file size per chunk (MaxFileSize)
	//
	// Use this to define behavior per collection before inserting data.
	RegisterSwamp(ctx context.Context, in *RegisterSwampRequest, opts ...grpc.CallOption) (*RegisterSwampResponse, error)
	// DeRegisterSwamp removes a previously registered swamp pattern.
	// This does not delete the swamp data ‚Äî it only removes its active configuration.
	//
	// Use this to clean up unused swamp definitions.
	DeRegisterSwamp(ctx context.Context, in *DeRegisterSwampRequest, opts ...grpc.CallOption) (*DeRegisterSwampResponse, error)
	// Set inserts or updates one or more key-value pairs into one or more swamps.
	// You can control the behavior using two flags:
	// - CreateIfNotExist: If false, the swamp/key must already exist (update only).
	// - Overwrite: If false, the existing value will not be overwritten.
	//
	// ‚ö†Ô∏è Each KeyValuePair supports multiple data types:
	// - All numeric primitives: int8, int16, int32, int64, uint8, uint16, uint32, uint64
	// - Floating point types: float32, float64
	// - Booleans, strings, bytes, and even slices (e.g., uint32[])
	//
	// üí° Hydra stores the value using its **actual underlying type** without upcasting,
	// which means no wasted memory or disk space ‚Äì you only store what you really need.
	//
	// You can also set metadata like CreatedAt, UpdatedBy, ExpiredAt, etc.
	//
	// ‚úÖ Supports multiple swamps in a single request for batch operations.
	//
	// üîî Realtime: Any inserted or updated treasures will trigger an immediate
	// event to all active subscribers via the SubscribeToEvents stream.
	//
	// This makes Hydra suitable for:
	// - Real-time dashboards
	// - Cache invalidation listeners
	// - Live analytics feeds
	Set(ctx context.Context, in *SetRequest, opts ...grpc.CallOption) (*SetResponse, error)
	// Get retrieves one or more key-value pairs by key from one or more swamps.
	// You must specify the swamp name and the list of keys per swamp.
	//
	// Each response includes the key, value, and metadata fields (timestamps, creators).
	// This is a type-safe, structured read ‚Äì no JSON parsing needed on the client side.
	Get(ctx context.Context, in *GetRequest, opts ...grpc.CallOption) (*GetResponse, error)
	// GetAll retrieves **all** key-value pairs from a given swamp.
	//
	// This is useful for debug purposes, cache rebuilding, or initial snapshot creation.
	// Not recommended for large datasets unless scoped and filtered client-side.
	GetAll(ctx context.Context, in *GetAllRequest, opts ...grpc.CallOption) (*GetAllResponse, error)
	// GetByIndex allows indexed reads based on fields like:
	// - ExpirationTime
	// - CreationTime
	// - Value types (e.g., VALUE_STRING, VALUE_INT32, etc.)
	//
	// You can specify the index type, sorting order (ASC/DESC), and a range using From/Limit.
	// This makes the Hydra engine powerful for search, feed, and queue-like structures.
	//
	// ‚ö†Ô∏è Hydra creates index structures on-demand in memory when this method is called.
	// These indexes are **not persisted**, and are **discarded when the swamp is closed** due to inactivity.
	// This means indexing is stateless, fast, and leaves no storage overhead.
	//
	// You do not need to pre-define indexes. Simply call this method with the right IndexType.
	GetByIndex(ctx context.Context, in *GetByIndexRequest, opts ...grpc.CallOption) (*GetByIndexResponse, error)
	// ShiftExpiredTreasures retrieves and deletes expired treasures from a given swamp.
	//
	// This method is ideal for implementing task queues, time-based processing systems,
	// or scheduled cleanup mechanisms where only expired items should be processed.
	//
	// You can control how many items to retrieve at once using the `HowMany` parameter:
	// - If `HowMany` is 0, all expired treasures will be returned (use with caution on large swamps)
	// - If `HowMany` > 0, only that many expired entries will be returned in the response
	//
	// ‚ö†Ô∏è Important: This method is destructive ‚Äì the returned items will be permanently removed from the swamp.
	//
	// üîî Realtime: All subscribers to the swamp will receive an immediate
	// notification about the deleted treasures via the SubscribeToEvents stream.
	//
	// Use this for building things like:
	// - Delayed jobs
	// - Expiring caches
	// - Scheduled triggers (e.g. publish-after-expiry)
	ShiftExpiredTreasures(ctx context.Context, in *ShiftExpiredTreasuresRequest, opts ...grpc.CallOption) (*ShiftExpiredTreasuresResponse, error)
	// Destroy permanently deletes the entire swamp and all its treasures.
	//
	// This removes all data associated with the given swamp, including metadata, indexes, and chunks.
	//
	// ‚ö†Ô∏è Warning: This operation is irreversible. All data will be lost.
	// Use only when you're absolutely sure the swamp is no longer needed.
	//
	// Typical use cases:
	// - Cleanup after tests or temporary data
	// - User data deletion requests
	// - Full environment reset
	Destroy(ctx context.Context, in *DestroyRequest, opts ...grpc.CallOption) (*DestroyResponse, error)
	// Delete removes one or more treasures (key-value pairs) from the specified swamp.
	//
	// This is a precise, non-destructive swamp-level operation.
	// You must provide the swamp name and the list of keys to delete.
	//
	// ‚úÖ Supports batch deletion across multiple swamps in a single request.
	// Each swamp and its deleted keys will be included in the response.
	//
	// üîî Realtime: All subscribers to the swamp will receive an immediate
	// notification about the deleted treasures via the SubscribeToEvents stream.
	//
	// Use this to:
	// - Manually remove outdated or invalid entries
	// - Implement "soft delete" logic (client-side)
	// - Perform targeted cleanup operations
	Delete(ctx context.Context, in *DeleteRequest, opts ...grpc.CallOption) (*DeleteResponse, error)
	// Count returns the number of treasures in one or more specified swamps.
	//
	// You provide a list of swamp names, and for each swamp Hydra returns:
	// - Whether the swamp exists
	// - How many elements (treasures) are currently stored in it
	//
	// ‚úÖ This is useful for:
	// - Dashboard metrics and monitoring
	// - Queue size estimation
	// - Expiry-aware cleanup or batch logic
	//
	// üí° The count is calculated instantly from the swamp‚Äôs current state,
	// with no need for full traversal or manual iteration.
	//
	// Can be used across multiple swamps in a single request.
	Count(ctx context.Context, in *CountRequest, opts ...grpc.CallOption) (*CountResponse, error)
	// IsSwampExist checks if the specified swamp exists in the given sanctuary.
	//
	// This method does not create or modify anything ‚Äì it only verifies existence.
	// Use it to validate swamp names before writing, migrating, or deleting.
	//
	// Typical use cases:
	// - Pre-checks before Set/Delete operations
	// - UI/UX logic (e.g. show/hide a swamp)
	// - Schema validation before batch processing
	//
	// üí° Note: Swamp existence does not guarantee any treasures inside ‚Äì it's purely structural.
	IsSwampExist(ctx context.Context, in *IsSwampExistRequest, opts ...grpc.CallOption) (*IsSwampExistResponse, error)
	// IsKeyExist checks whether a specific key exists in a given swamp.
	//
	// This allows you to verify the presence of a treasure without retrieving its content.
	//
	// Use cases include:
	// - Validation before conditional logic (e.g. overwrite if exists)
	// - Data consistency checks
	// - TTL-aware logic (e.g. only update if key is still present)
	//
	// üí° Note: The value is not returned ‚Äì only a boolean indicator of existence.
	IsKeyExist(ctx context.Context, in *IsKeyExistRequest, opts ...grpc.CallOption) (*IsKeyExistResponse, error)
	// SubscribeToEvents allows clients to subscribe to **all data changes** within a given swamp.
	//
	// When any treasure in the swamp is created, updated, or deleted,
	// the subscriber immediately receives an event via the gRPC stream.
	//
	// Each event includes:
	// - The new Treasure (after Set, Shift, etc.)
	// - The previous Treasure (if updated)
	// - The deleted Treasure (if removed)
	// - The EventType: NEW, UPDATED, DELETED, etc.
	// - The timestamp of the change
	//
	// üîÅ Events are streamed continuously and in real time, making this ideal for:
	// - Realtime dashboards
	// - Reactive frontends (e.g. auto-refreshing tables)
	// - Notification systems
	// - Chat or messaging systems (event-driven communication)
	// - Distributed coordination (e.g. data sync across services)
	// - Microservice communication via event stream
	//
	// üí° You can use this to completely replace traditional polling or cron-based checks.
	SubscribeToEvents(ctx context.Context, in *SubscribeToEventsRequest, opts ...grpc.CallOption) (HydraService_SubscribeToEventsClient, error)
	// SubscribeToInfo allows clients to subscribe to the **size** of a given swamp.
	//
	// Whenever the number of treasures changes in the swamp (insert, delete, expire),
	// the client receives a realtime update of the current element count.
	//
	// This is useful for:
	// - Showing live counters or progress bars
	// - Monitoring queue sizes
	// - Displaying health metrics or swamp saturation
	//
	// ‚ö° Events are sent immediately upon any change to the number of elements.
	SubscribeToInfo(ctx context.Context, in *SubscribeToInfoRequest, opts ...grpc.CallOption) (HydraService_SubscribeToInfoClient, error)
	// Uint32SlicePush adds one or more uint32 values to one or more uint32 slices stored in a swamp.
	//
	// üí° Hydra automatically ensures that each value is unique within the slice.
	// If a number already exists, it will be ignored ‚Äì no duplicates are ever stored.
	//
	// You can safely push multiple values at once, even if some already exist.
	// The resulting slice will contain only distinct uint32 values.
	//
	// üîî Any change to the slice triggers a real-time event to all swamp subscribers.
	// The full updated slice is included in the event payload.
	//
	// This feature is ideal for building:
	// - Reverse indexes (e.g. word ‚Üí [domainHash1, domainHash2])
	// - Subscriptions, permissions, ID-based tagging
	// - Memory-efficient, append-only ID lists
	//
	// ‚ö†Ô∏è Recommended for cases where the slice size is small to moderate,
	// as the full slice is returned on each update.
	Uint32SlicePush(ctx context.Context, in *AddToUint32SlicePushRequest, opts ...grpc.CallOption) (*AddToUint32SlicePushResponse, error)
	// Uint32SliceDelete removes one or more uint32 values from one or more slices.
	//
	// If a value does not exist, it is silently ignored (no error thrown).
	// The key itself (treasure) is preserved ‚Äì only the values inside the slice are modified.
	//
	// üîî The deletion also triggers a real-time event to all subscribers.
	Uint32SliceDelete(ctx context.Context, in *Uint32SliceDeleteRequest, opts ...grpc.CallOption) (*Uint32SliceDeleteResponse, error)
	// Uint32SliceSize returns the number of values stored in the uint32 slice.
	//
	// Use this to:
	// - Show visual counters
	// - Estimate memory usage
	// - Monitor collection density
	Uint32SliceSize(ctx context.Context, in *Uint32SliceSizeRequest, opts ...grpc.CallOption) (*Uint32SliceSizeResponse, error)
	// Uint32SliceIsValueExist checks whether a specific value exists inside the slice.
	//
	// This is useful when you want to validate membership before taking actions,
	// such as displaying UI states or preventing duplicate logic.
	Uint32SliceIsValueExist(ctx context.Context, in *Uint32SliceIsValueExistRequest, opts ...grpc.CallOption) (*Uint32SliceIsValueExistResponse, error)
	// IncrementInt8 increments (or decrements) the value of the key by the specified amount,
	// if a given condition is satisfied.
	//
	// üí° The increment can be negative ‚Äì enabling both increment and decrement operations.
	// If the condition fails, the value is not modified.
	//
	// The response includes:
	// - The new (or original) value
	// - Whether the increment was applied
	//
	// üîî Realtime: Any change triggers an immediate event to all swamp subscribers via SubscribeToEvents.
	//
	// Typical use cases:
	// - Counter logic (votes, likes, attempts)
	// - Conditional stock adjustments
	// - Quota or retry limits
	IncrementInt8(ctx context.Context, in *IncrementInt8Request, opts ...grpc.CallOption) (*IncrementInt8Response, error)
	// IncrementInt8 same logic as IncrementInt8 but for int16 values
	IncrementInt16(ctx context.Context, in *IncrementInt16Request, opts ...grpc.CallOption) (*IncrementInt16Response, error)
	// IncrementInt32 same logic as IncrementInt8 but for int32 values
	IncrementInt32(ctx context.Context, in *IncrementInt32Request, opts ...grpc.CallOption) (*IncrementInt32Response, error)
	// IncrementInt64 same logic as IncrementInt8 but for int64 values
	IncrementInt64(ctx context.Context, in *IncrementInt64Request, opts ...grpc.CallOption) (*IncrementInt64Response, error)
	// IncrementUint8 same logic as IncrementInt8 but for uint8 values
	IncrementUint8(ctx context.Context, in *IncrementUint8Request, opts ...grpc.CallOption) (*IncrementUint8Response, error)
	// IncrementUint16 same logic as IncrementInt8 but for uint16 values
	IncrementUint16(ctx context.Context, in *IncrementUint16Request, opts ...grpc.CallOption) (*IncrementUint16Response, error)
	// IncrementUint32 same logic as IncrementInt8 but for uint32 values
	IncrementUint32(ctx context.Context, in *IncrementUint32Request, opts ...grpc.CallOption) (*IncrementUint32Response, error)
	// IncrementUint64 same logic as IncrementInt8 but for uint64 values
	IncrementUint64(ctx context.Context, in *IncrementUint64Request, opts ...grpc.CallOption) (*IncrementUint64Response, error)
	// IncrementFloat32 same logic as IncrementInt8 but for float32 values
	IncrementFloat32(ctx context.Context, in *IncrementFloat32Request, opts ...grpc.CallOption) (*IncrementFloat32Response, error)
	// IncrementFloat64 same logic as IncrementInt8 but for float64 values
	IncrementFloat64(ctx context.Context, in *IncrementFloat64Request, opts ...grpc.CallOption) (*IncrementFloat64Response, error)
}

type hydraServiceClient struct {
	cc grpc.ClientConnInterface
}

func NewHydraServiceClient(cc grpc.ClientConnInterface) HydraServiceClient {
	return &hydraServiceClient{cc}
}

func (c *hydraServiceClient) Heartbeat(ctx context.Context, in *HeartbeatRequest, opts ...grpc.CallOption) (*HeartbeatResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(HeartbeatResponse)
	err := c.cc.Invoke(ctx, HydraService_Heartbeat_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *hydraServiceClient) Lock(ctx context.Context, in *LockRequest, opts ...grpc.CallOption) (*LockResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(LockResponse)
	err := c.cc.Invoke(ctx, HydraService_Lock_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *hydraServiceClient) Unlock(ctx context.Context, in *UnlockRequest, opts ...grpc.CallOption) (*UnlockResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(UnlockResponse)
	err := c.cc.Invoke(ctx, HydraService_Unlock_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *hydraServiceClient) RegisterSwamp(ctx context.Context, in *RegisterSwampRequest, opts ...grpc.CallOption) (*RegisterSwampResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(RegisterSwampResponse)
	err := c.cc.Invoke(ctx, HydraService_RegisterSwamp_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *hydraServiceClient) DeRegisterSwamp(ctx context.Context, in *DeRegisterSwampRequest, opts ...grpc.CallOption) (*DeRegisterSwampResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(DeRegisterSwampResponse)
	err := c.cc.Invoke(ctx, HydraService_DeRegisterSwamp_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *hydraServiceClient) Set(ctx context.Context, in *SetRequest, opts ...grpc.CallOption) (*SetResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(SetResponse)
	err := c.cc.Invoke(ctx, HydraService_Set_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *hydraServiceClient) Get(ctx context.Context, in *GetRequest, opts ...grpc.CallOption) (*GetResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(GetResponse)
	err := c.cc.Invoke(ctx, HydraService_Get_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *hydraServiceClient) GetAll(ctx context.Context, in *GetAllRequest, opts ...grpc.CallOption) (*GetAllResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(GetAllResponse)
	err := c.cc.Invoke(ctx, HydraService_GetAll_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *hydraServiceClient) GetByIndex(ctx context.Context, in *GetByIndexRequest, opts ...grpc.CallOption) (*GetByIndexResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(GetByIndexResponse)
	err := c.cc.Invoke(ctx, HydraService_GetByIndex_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *hydraServiceClient) ShiftExpiredTreasures(ctx context.Context, in *ShiftExpiredTreasuresRequest, opts ...grpc.CallOption) (*ShiftExpiredTreasuresResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(ShiftExpiredTreasuresResponse)
	err := c.cc.Invoke(ctx, HydraService_ShiftExpiredTreasures_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *hydraServiceClient) Destroy(ctx context.Context, in *DestroyRequest, opts ...grpc.CallOption) (*DestroyResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(DestroyResponse)
	err := c.cc.Invoke(ctx, HydraService_Destroy_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *hydraServiceClient) Delete(ctx context.Context, in *DeleteRequest, opts ...grpc.CallOption) (*DeleteResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(DeleteResponse)
	err := c.cc.Invoke(ctx, HydraService_Delete_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *hydraServiceClient) Count(ctx context.Context, in *CountRequest, opts ...grpc.CallOption) (*CountResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(CountResponse)
	err := c.cc.Invoke(ctx, HydraService_Count_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *hydraServiceClient) IsSwampExist(ctx context.Context, in *IsSwampExistRequest, opts ...grpc.CallOption) (*IsSwampExistResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(IsSwampExistResponse)
	err := c.cc.Invoke(ctx, HydraService_IsSwampExist_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *hydraServiceClient) IsKeyExist(ctx context.Context, in *IsKeyExistRequest, opts ...grpc.CallOption) (*IsKeyExistResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(IsKeyExistResponse)
	err := c.cc.Invoke(ctx, HydraService_IsKeyExist_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *hydraServiceClient) SubscribeToEvents(ctx context.Context, in *SubscribeToEventsRequest, opts ...grpc.CallOption) (HydraService_SubscribeToEventsClient, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	stream, err := c.cc.NewStream(ctx, &HydraService_ServiceDesc.Streams[0], HydraService_SubscribeToEvents_FullMethodName, cOpts...)
	if err != nil {
		return nil, err
	}
	x := &hydraServiceSubscribeToEventsClient{ClientStream: stream}
	if err := x.ClientStream.SendMsg(in); err != nil {
		return nil, err
	}
	if err := x.ClientStream.CloseSend(); err != nil {
		return nil, err
	}
	return x, nil
}

type HydraService_SubscribeToEventsClient interface {
	Recv() (*SubscribeToEventsResponse, error)
	grpc.ClientStream
}

type hydraServiceSubscribeToEventsClient struct {
	grpc.ClientStream
}

func (x *hydraServiceSubscribeToEventsClient) Recv() (*SubscribeToEventsResponse, error) {
	m := new(SubscribeToEventsResponse)
	if err := x.ClientStream.RecvMsg(m); err != nil {
		return nil, err
	}
	return m, nil
}

func (c *hydraServiceClient) SubscribeToInfo(ctx context.Context, in *SubscribeToInfoRequest, opts ...grpc.CallOption) (HydraService_SubscribeToInfoClient, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	stream, err := c.cc.NewStream(ctx, &HydraService_ServiceDesc.Streams[1], HydraService_SubscribeToInfo_FullMethodName, cOpts...)
	if err != nil {
		return nil, err
	}
	x := &hydraServiceSubscribeToInfoClient{ClientStream: stream}
	if err := x.ClientStream.SendMsg(in); err != nil {
		return nil, err
	}
	if err := x.ClientStream.CloseSend(); err != nil {
		return nil, err
	}
	return x, nil
}

type HydraService_SubscribeToInfoClient interface {
	Recv() (*SubscribeToInfoResponse, error)
	grpc.ClientStream
}

type hydraServiceSubscribeToInfoClient struct {
	grpc.ClientStream
}

func (x *hydraServiceSubscribeToInfoClient) Recv() (*SubscribeToInfoResponse, error) {
	m := new(SubscribeToInfoResponse)
	if err := x.ClientStream.RecvMsg(m); err != nil {
		return nil, err
	}
	return m, nil
}

func (c *hydraServiceClient) Uint32SlicePush(ctx context.Context, in *AddToUint32SlicePushRequest, opts ...grpc.CallOption) (*AddToUint32SlicePushResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(AddToUint32SlicePushResponse)
	err := c.cc.Invoke(ctx, HydraService_Uint32SlicePush_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *hydraServiceClient) Uint32SliceDelete(ctx context.Context, in *Uint32SliceDeleteRequest, opts ...grpc.CallOption) (*Uint32SliceDeleteResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(Uint32SliceDeleteResponse)
	err := c.cc.Invoke(ctx, HydraService_Uint32SliceDelete_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *hydraServiceClient) Uint32SliceSize(ctx context.Context, in *Uint32SliceSizeRequest, opts ...grpc.CallOption) (*Uint32SliceSizeResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(Uint32SliceSizeResponse)
	err := c.cc.Invoke(ctx, HydraService_Uint32SliceSize_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *hydraServiceClient) Uint32SliceIsValueExist(ctx context.Context, in *Uint32SliceIsValueExistRequest, opts ...grpc.CallOption) (*Uint32SliceIsValueExistResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(Uint32SliceIsValueExistResponse)
	err := c.cc.Invoke(ctx, HydraService_Uint32SliceIsValueExist_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *hydraServiceClient) IncrementInt8(ctx context.Context, in *IncrementInt8Request, opts ...grpc.CallOption) (*IncrementInt8Response, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(IncrementInt8Response)
	err := c.cc.Invoke(ctx, HydraService_IncrementInt8_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *hydraServiceClient) IncrementInt16(ctx context.Context, in *IncrementInt16Request, opts ...grpc.CallOption) (*IncrementInt16Response, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(IncrementInt16Response)
	err := c.cc.Invoke(ctx, HydraService_IncrementInt16_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *hydraServiceClient) IncrementInt32(ctx context.Context, in *IncrementInt32Request, opts ...grpc.CallOption) (*IncrementInt32Response, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(IncrementInt32Response)
	err := c.cc.Invoke(ctx, HydraService_IncrementInt32_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *hydraServiceClient) IncrementInt64(ctx context.Context, in *IncrementInt64Request, opts ...grpc.CallOption) (*IncrementInt64Response, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(IncrementInt64Response)
	err := c.cc.Invoke(ctx, HydraService_IncrementInt64_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *hydraServiceClient) IncrementUint8(ctx context.Context, in *IncrementUint8Request, opts ...grpc.CallOption) (*IncrementUint8Response, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(IncrementUint8Response)
	err := c.cc.Invoke(ctx, HydraService_IncrementUint8_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *hydraServiceClient) IncrementUint16(ctx context.Context, in *IncrementUint16Request, opts ...grpc.CallOption) (*IncrementUint16Response, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(IncrementUint16Response)
	err := c.cc.Invoke(ctx, HydraService_IncrementUint16_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *hydraServiceClient) IncrementUint32(ctx context.Context, in *IncrementUint32Request, opts ...grpc.CallOption) (*IncrementUint32Response, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(IncrementUint32Response)
	err := c.cc.Invoke(ctx, HydraService_IncrementUint32_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *hydraServiceClient) IncrementUint64(ctx context.Context, in *IncrementUint64Request, opts ...grpc.CallOption) (*IncrementUint64Response, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(IncrementUint64Response)
	err := c.cc.Invoke(ctx, HydraService_IncrementUint64_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *hydraServiceClient) IncrementFloat32(ctx context.Context, in *IncrementFloat32Request, opts ...grpc.CallOption) (*IncrementFloat32Response, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(IncrementFloat32Response)
	err := c.cc.Invoke(ctx, HydraService_IncrementFloat32_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *hydraServiceClient) IncrementFloat64(ctx context.Context, in *IncrementFloat64Request, opts ...grpc.CallOption) (*IncrementFloat64Response, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(IncrementFloat64Response)
	err := c.cc.Invoke(ctx, HydraService_IncrementFloat64_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

// HydraServiceServer is the server API for HydraService service.
// All implementations must embed UnimplementedHydraServiceServer
// for forward compatibility
type HydraServiceServer interface {
	// Heartbeat checks if the Hydra server is alive.
	// The client sends a Ping and expects a Pong response.
	Heartbeat(context.Context, *HeartbeatRequest) (*HeartbeatResponse, error)
	// Lock allows you to create a mutex-like lock based on a given key.
	// It queues all lock requests for the same key and only returns once the lock is granted.
	// This mechanism enables swamp- or treasure-level locking to coordinate access between microservices.
	//
	// ‚ö†Ô∏è Note: Locking is logical only ‚Äî it does not block the actual data access unless your logic respects the lock.
	// You must explicitly use the Lock/Unlock sequence around relevant operations.
	//
	// Required: TTL must be set (timeout in milliseconds).
	// If the lock cannot be acquired within this TTL, the call returns an error.
	// If a lock is granted, a LockID is returned, which must be passed to Unlock.
	Lock(context.Context, *LockRequest) (*LockResponse, error)
	// Unlock releases the previously granted lock based on the key and LockID.
	// If the LockID is invalid or does not match an existing lock, the call fails.
	//
	// It is crucial to always unlock your locks to avoid deadlocks.
	// If the TTL expires, the lock is automatically released.
	Unlock(context.Context, *UnlockRequest) (*UnlockResponse, error)
	// RegisterSwamp registers a new swamp pattern in the Hydra system.
	// A swamp pattern defines the namespace (Sanctuary/Realm/Swamp) and behavior of a storage unit.
	//
	// You can configure:
	// - Whether the swamp lives in memory or on disk
	// - How long it should stay alive without access (CloseAfterIdle)
	// - How frequently it should flush to disk (WriteInterval)
	// - Maximum file size per chunk (MaxFileSize)
	//
	// Use this to define behavior per collection before inserting data.
	RegisterSwamp(context.Context, *RegisterSwampRequest) (*RegisterSwampResponse, error)
	// DeRegisterSwamp removes a previously registered swamp pattern.
	// This does not delete the swamp data ‚Äî it only removes its active configuration.
	//
	// Use this to clean up unused swamp definitions.
	DeRegisterSwamp(context.Context, *DeRegisterSwampRequest) (*DeRegisterSwampResponse, error)
	// Set inserts or updates one or more key-value pairs into one or more swamps.
	// You can control the behavior using two flags:
	// - CreateIfNotExist: If false, the swamp/key must already exist (update only).
	// - Overwrite: If false, the existing value will not be overwritten.
	//
	// ‚ö†Ô∏è Each KeyValuePair supports multiple data types:
	// - All numeric primitives: int8, int16, int32, int64, uint8, uint16, uint32, uint64
	// - Floating point types: float32, float64
	// - Booleans, strings, bytes, and even slices (e.g., uint32[])
	//
	// üí° Hydra stores the value using its **actual underlying type** without upcasting,
	// which means no wasted memory or disk space ‚Äì you only store what you really need.
	//
	// You can also set metadata like CreatedAt, UpdatedBy, ExpiredAt, etc.
	//
	// ‚úÖ Supports multiple swamps in a single request for batch operations.
	//
	// üîî Realtime: Any inserted or updated treasures will trigger an immediate
	// event to all active subscribers via the SubscribeToEvents stream.
	//
	// This makes Hydra suitable for:
	// - Real-time dashboards
	// - Cache invalidation listeners
	// - Live analytics feeds
	Set(context.Context, *SetRequest) (*SetResponse, error)
	// Get retrieves one or more key-value pairs by key from one or more swamps.
	// You must specify the swamp name and the list of keys per swamp.
	//
	// Each response includes the key, value, and metadata fields (timestamps, creators).
	// This is a type-safe, structured read ‚Äì no JSON parsing needed on the client side.
	Get(context.Context, *GetRequest) (*GetResponse, error)
	// GetAll retrieves **all** key-value pairs from a given swamp.
	//
	// This is useful for debug purposes, cache rebuilding, or initial snapshot creation.
	// Not recommended for large datasets unless scoped and filtered client-side.
	GetAll(context.Context, *GetAllRequest) (*GetAllResponse, error)
	// GetByIndex allows indexed reads based on fields like:
	// - ExpirationTime
	// - CreationTime
	// - Value types (e.g., VALUE_STRING, VALUE_INT32, etc.)
	//
	// You can specify the index type, sorting order (ASC/DESC), and a range using From/Limit.
	// This makes the Hydra engine powerful for search, feed, and queue-like structures.
	//
	// ‚ö†Ô∏è Hydra creates index structures on-demand in memory when this method is called.
	// These indexes are **not persisted**, and are **discarded when the swamp is closed** due to inactivity.
	// This means indexing is stateless, fast, and leaves no storage overhead.
	//
	// You do not need to pre-define indexes. Simply call this method with the right IndexType.
	GetByIndex(context.Context, *GetByIndexRequest) (*GetByIndexResponse, error)
	// ShiftExpiredTreasures retrieves and deletes expired treasures from a given swamp.
	//
	// This method is ideal for implementing task queues, time-based processing systems,
	// or scheduled cleanup mechanisms where only expired items should be processed.
	//
	// You can control how many items to retrieve at once using the `HowMany` parameter:
	// - If `HowMany` is 0, all expired treasures will be returned (use with caution on large swamps)
	// - If `HowMany` > 0, only that many expired entries will be returned in the response
	//
	// ‚ö†Ô∏è Important: This method is destructive ‚Äì the returned items will be permanently removed from the swamp.
	//
	// üîî Realtime: All subscribers to the swamp will receive an immediate
	// notification about the deleted treasures via the SubscribeToEvents stream.
	//
	// Use this for building things like:
	// - Delayed jobs
	// - Expiring caches
	// - Scheduled triggers (e.g. publish-after-expiry)
	ShiftExpiredTreasures(context.Context, *ShiftExpiredTreasuresRequest) (*ShiftExpiredTreasuresResponse, error)
	// Destroy permanently deletes the entire swamp and all its treasures.
	//
	// This removes all data associated with the given swamp, including metadata, indexes, and chunks.
	//
	// ‚ö†Ô∏è Warning: This operation is irreversible. All data will be lost.
	// Use only when you're absolutely sure the swamp is no longer needed.
	//
	// Typical use cases:
	// - Cleanup after tests or temporary data
	// - User data deletion requests
	// - Full environment reset
	Destroy(context.Context, *DestroyRequest) (*DestroyResponse, error)
	// Delete removes one or more treasures (key-value pairs) from the specified swamp.
	//
	// This is a precise, non-destructive swamp-level operation.
	// You must provide the swamp name and the list of keys to delete.
	//
	// ‚úÖ Supports batch deletion across multiple swamps in a single request.
	// Each swamp and its deleted keys will be included in the response.
	//
	// üîî Realtime: All subscribers to the swamp will receive an immediate
	// notification about the deleted treasures via the SubscribeToEvents stream.
	//
	// Use this to:
	// - Manually remove outdated or invalid entries
	// - Implement "soft delete" logic (client-side)
	// - Perform targeted cleanup operations
	Delete(context.Context, *DeleteRequest) (*DeleteResponse, error)
	// Count returns the number of treasures in one or more specified swamps.
	//
	// You provide a list of swamp names, and for each swamp Hydra returns:
	// - Whether the swamp exists
	// - How many elements (treasures) are currently stored in it
	//
	// ‚úÖ This is useful for:
	// - Dashboard metrics and monitoring
	// - Queue size estimation
	// - Expiry-aware cleanup or batch logic
	//
	// üí° The count is calculated instantly from the swamp‚Äôs current state,
	// with no need for full traversal or manual iteration.
	//
	// Can be used across multiple swamps in a single request.
	Count(context.Context, *CountRequest) (*CountResponse, error)
	// IsSwampExist checks if the specified swamp exists in the given sanctuary.
	//
	// This method does not create or modify anything ‚Äì it only verifies existence.
	// Use it to validate swamp names before writing, migrating, or deleting.
	//
	// Typical use cases:
	// - Pre-checks before Set/Delete operations
	// - UI/UX logic (e.g. show/hide a swamp)
	// - Schema validation before batch processing
	//
	// üí° Note: Swamp existence does not guarantee any treasures inside ‚Äì it's purely structural.
	IsSwampExist(context.Context, *IsSwampExistRequest) (*IsSwampExistResponse, error)
	// IsKeyExist checks whether a specific key exists in a given swamp.
	//
	// This allows you to verify the presence of a treasure without retrieving its content.
	//
	// Use cases include:
	// - Validation before conditional logic (e.g. overwrite if exists)
	// - Data consistency checks
	// - TTL-aware logic (e.g. only update if key is still present)
	//
	// üí° Note: The value is not returned ‚Äì only a boolean indicator of existence.
	IsKeyExist(context.Context, *IsKeyExistRequest) (*IsKeyExistResponse, error)
	// SubscribeToEvents allows clients to subscribe to **all data changes** within a given swamp.
	//
	// When any treasure in the swamp is created, updated, or deleted,
	// the subscriber immediately receives an event via the gRPC stream.
	//
	// Each event includes:
	// - The new Treasure (after Set, Shift, etc.)
	// - The previous Treasure (if updated)
	// - The deleted Treasure (if removed)
	// - The EventType: NEW, UPDATED, DELETED, etc.
	// - The timestamp of the change
	//
	// üîÅ Events are streamed continuously and in real time, making this ideal for:
	// - Realtime dashboards
	// - Reactive frontends (e.g. auto-refreshing tables)
	// - Notification systems
	// - Chat or messaging systems (event-driven communication)
	// - Distributed coordination (e.g. data sync across services)
	// - Microservice communication via event stream
	//
	// üí° You can use this to completely replace traditional polling or cron-based checks.
	SubscribeToEvents(*SubscribeToEventsRequest, HydraService_SubscribeToEventsServer) error
	// SubscribeToInfo allows clients to subscribe to the **size** of a given swamp.
	//
	// Whenever the number of treasures changes in the swamp (insert, delete, expire),
	// the client receives a realtime update of the current element count.
	//
	// This is useful for:
	// - Showing live counters or progress bars
	// - Monitoring queue sizes
	// - Displaying health metrics or swamp saturation
	//
	// ‚ö° Events are sent immediately upon any change to the number of elements.
	SubscribeToInfo(*SubscribeToInfoRequest, HydraService_SubscribeToInfoServer) error
	// Uint32SlicePush adds one or more uint32 values to one or more uint32 slices stored in a swamp.
	//
	// üí° Hydra automatically ensures that each value is unique within the slice.
	// If a number already exists, it will be ignored ‚Äì no duplicates are ever stored.
	//
	// You can safely push multiple values at once, even if some already exist.
	// The resulting slice will contain only distinct uint32 values.
	//
	// üîî Any change to the slice triggers a real-time event to all swamp subscribers.
	// The full updated slice is included in the event payload.
	//
	// This feature is ideal for building:
	// - Reverse indexes (e.g. word ‚Üí [domainHash1, domainHash2])
	// - Subscriptions, permissions, ID-based tagging
	// - Memory-efficient, append-only ID lists
	//
	// ‚ö†Ô∏è Recommended for cases where the slice size is small to moderate,
	// as the full slice is returned on each update.
	Uint32SlicePush(context.Context, *AddToUint32SlicePushRequest) (*AddToUint32SlicePushResponse, error)
	// Uint32SliceDelete removes one or more uint32 values from one or more slices.
	//
	// If a value does not exist, it is silently ignored (no error thrown).
	// The key itself (treasure) is preserved ‚Äì only the values inside the slice are modified.
	//
	// üîî The deletion also triggers a real-time event to all subscribers.
	Uint32SliceDelete(context.Context, *Uint32SliceDeleteRequest) (*Uint32SliceDeleteResponse, error)
	// Uint32SliceSize returns the number of values stored in the uint32 slice.
	//
	// Use this to:
	// - Show visual counters
	// - Estimate memory usage
	// - Monitor collection density
	Uint32SliceSize(context.Context, *Uint32SliceSizeRequest) (*Uint32SliceSizeResponse, error)
	// Uint32SliceIsValueExist checks whether a specific value exists inside the slice.
	//
	// This is useful when you want to validate membership before taking actions,
	// such as displaying UI states or preventing duplicate logic.
	Uint32SliceIsValueExist(context.Context, *Uint32SliceIsValueExistRequest) (*Uint32SliceIsValueExistResponse, error)
	// IncrementInt8 increments (or decrements) the value of the key by the specified amount,
	// if a given condition is satisfied.
	//
	// üí° The increment can be negative ‚Äì enabling both increment and decrement operations.
	// If the condition fails, the value is not modified.
	//
	// The response includes:
	// - The new (or original) value
	// - Whether the increment was applied
	//
	// üîî Realtime: Any change triggers an immediate event to all swamp subscribers via SubscribeToEvents.
	//
	// Typical use cases:
	// - Counter logic (votes, likes, attempts)
	// - Conditional stock adjustments
	// - Quota or retry limits
	IncrementInt8(context.Context, *IncrementInt8Request) (*IncrementInt8Response, error)
	// IncrementInt8 same logic as IncrementInt8 but for int16 values
	IncrementInt16(context.Context, *IncrementInt16Request) (*IncrementInt16Response, error)
	// IncrementInt32 same logic as IncrementInt8 but for int32 values
	IncrementInt32(context.Context, *IncrementInt32Request) (*IncrementInt32Response, error)
	// IncrementInt64 same logic as IncrementInt8 but for int64 values
	IncrementInt64(context.Context, *IncrementInt64Request) (*IncrementInt64Response, error)
	// IncrementUint8 same logic as IncrementInt8 but for uint8 values
	IncrementUint8(context.Context, *IncrementUint8Request) (*IncrementUint8Response, error)
	// IncrementUint16 same logic as IncrementInt8 but for uint16 values
	IncrementUint16(context.Context, *IncrementUint16Request) (*IncrementUint16Response, error)
	// IncrementUint32 same logic as IncrementInt8 but for uint32 values
	IncrementUint32(context.Context, *IncrementUint32Request) (*IncrementUint32Response, error)
	// IncrementUint64 same logic as IncrementInt8 but for uint64 values
	IncrementUint64(context.Context, *IncrementUint64Request) (*IncrementUint64Response, error)
	// IncrementFloat32 same logic as IncrementInt8 but for float32 values
	IncrementFloat32(context.Context, *IncrementFloat32Request) (*IncrementFloat32Response, error)
	// IncrementFloat64 same logic as IncrementInt8 but for float64 values
	IncrementFloat64(context.Context, *IncrementFloat64Request) (*IncrementFloat64Response, error)
	mustEmbedUnimplementedHydraServiceServer()
}

// UnimplementedHydraServiceServer must be embedded to have forward compatible implementations.
type UnimplementedHydraServiceServer struct {
}

func (UnimplementedHydraServiceServer) Heartbeat(context.Context, *HeartbeatRequest) (*HeartbeatResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method Heartbeat not implemented")
}
func (UnimplementedHydraServiceServer) Lock(context.Context, *LockRequest) (*LockResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method Lock not implemented")
}
func (UnimplementedHydraServiceServer) Unlock(context.Context, *UnlockRequest) (*UnlockResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method Unlock not implemented")
}
func (UnimplementedHydraServiceServer) RegisterSwamp(context.Context, *RegisterSwampRequest) (*RegisterSwampResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method RegisterSwamp not implemented")
}
func (UnimplementedHydraServiceServer) DeRegisterSwamp(context.Context, *DeRegisterSwampRequest) (*DeRegisterSwampResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method DeRegisterSwamp not implemented")
}
func (UnimplementedHydraServiceServer) Set(context.Context, *SetRequest) (*SetResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method Set not implemented")
}
func (UnimplementedHydraServiceServer) Get(context.Context, *GetRequest) (*GetResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method Get not implemented")
}
func (UnimplementedHydraServiceServer) GetAll(context.Context, *GetAllRequest) (*GetAllResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method GetAll not implemented")
}
func (UnimplementedHydraServiceServer) GetByIndex(context.Context, *GetByIndexRequest) (*GetByIndexResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method GetByIndex not implemented")
}
func (UnimplementedHydraServiceServer) ShiftExpiredTreasures(context.Context, *ShiftExpiredTreasuresRequest) (*ShiftExpiredTreasuresResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method ShiftExpiredTreasures not implemented")
}
func (UnimplementedHydraServiceServer) Destroy(context.Context, *DestroyRequest) (*DestroyResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method Destroy not implemented")
}
func (UnimplementedHydraServiceServer) Delete(context.Context, *DeleteRequest) (*DeleteResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method Delete not implemented")
}
func (UnimplementedHydraServiceServer) Count(context.Context, *CountRequest) (*CountResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method Count not implemented")
}
func (UnimplementedHydraServiceServer) IsSwampExist(context.Context, *IsSwampExistRequest) (*IsSwampExistResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method IsSwampExist not implemented")
}
func (UnimplementedHydraServiceServer) IsKeyExist(context.Context, *IsKeyExistRequest) (*IsKeyExistResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method IsKeyExist not implemented")
}
func (UnimplementedHydraServiceServer) SubscribeToEvents(*SubscribeToEventsRequest, HydraService_SubscribeToEventsServer) error {
	return status.Errorf(codes.Unimplemented, "method SubscribeToEvents not implemented")
}
func (UnimplementedHydraServiceServer) SubscribeToInfo(*SubscribeToInfoRequest, HydraService_SubscribeToInfoServer) error {
	return status.Errorf(codes.Unimplemented, "method SubscribeToInfo not implemented")
}
func (UnimplementedHydraServiceServer) Uint32SlicePush(context.Context, *AddToUint32SlicePushRequest) (*AddToUint32SlicePushResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method Uint32SlicePush not implemented")
}
func (UnimplementedHydraServiceServer) Uint32SliceDelete(context.Context, *Uint32SliceDeleteRequest) (*Uint32SliceDeleteResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method Uint32SliceDelete not implemented")
}
func (UnimplementedHydraServiceServer) Uint32SliceSize(context.Context, *Uint32SliceSizeRequest) (*Uint32SliceSizeResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method Uint32SliceSize not implemented")
}
func (UnimplementedHydraServiceServer) Uint32SliceIsValueExist(context.Context, *Uint32SliceIsValueExistRequest) (*Uint32SliceIsValueExistResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method Uint32SliceIsValueExist not implemented")
}
func (UnimplementedHydraServiceServer) IncrementInt8(context.Context, *IncrementInt8Request) (*IncrementInt8Response, error) {
	return nil, status.Errorf(codes.Unimplemented, "method IncrementInt8 not implemented")
}
func (UnimplementedHydraServiceServer) IncrementInt16(context.Context, *IncrementInt16Request) (*IncrementInt16Response, error) {
	return nil, status.Errorf(codes.Unimplemented, "method IncrementInt16 not implemented")
}
func (UnimplementedHydraServiceServer) IncrementInt32(context.Context, *IncrementInt32Request) (*IncrementInt32Response, error) {
	return nil, status.Errorf(codes.Unimplemented, "method IncrementInt32 not implemented")
}
func (UnimplementedHydraServiceServer) IncrementInt64(context.Context, *IncrementInt64Request) (*IncrementInt64Response, error) {
	return nil, status.Errorf(codes.Unimplemented, "method IncrementInt64 not implemented")
}
func (UnimplementedHydraServiceServer) IncrementUint8(context.Context, *IncrementUint8Request) (*IncrementUint8Response, error) {
	return nil, status.Errorf(codes.Unimplemented, "method IncrementUint8 not implemented")
}
func (UnimplementedHydraServiceServer) IncrementUint16(context.Context, *IncrementUint16Request) (*IncrementUint16Response, error) {
	return nil, status.Errorf(codes.Unimplemented, "method IncrementUint16 not implemented")
}
func (UnimplementedHydraServiceServer) IncrementUint32(context.Context, *IncrementUint32Request) (*IncrementUint32Response, error) {
	return nil, status.Errorf(codes.Unimplemented, "method IncrementUint32 not implemented")
}
func (UnimplementedHydraServiceServer) IncrementUint64(context.Context, *IncrementUint64Request) (*IncrementUint64Response, error) {
	return nil, status.Errorf(codes.Unimplemented, "method IncrementUint64 not implemented")
}
func (UnimplementedHydraServiceServer) IncrementFloat32(context.Context, *IncrementFloat32Request) (*IncrementFloat32Response, error) {
	return nil, status.Errorf(codes.Unimplemented, "method IncrementFloat32 not implemented")
}
func (UnimplementedHydraServiceServer) IncrementFloat64(context.Context, *IncrementFloat64Request) (*IncrementFloat64Response, error) {
	return nil, status.Errorf(codes.Unimplemented, "method IncrementFloat64 not implemented")
}
func (UnimplementedHydraServiceServer) mustEmbedUnimplementedHydraServiceServer() {}

// UnsafeHydraServiceServer may be embedded to opt out of forward compatibility for this service.
// Use of this interface is not recommended, as added methods to HydraServiceServer will
// result in compilation errors.
type UnsafeHydraServiceServer interface {
	mustEmbedUnimplementedHydraServiceServer()
}

func RegisterHydraServiceServer(s grpc.ServiceRegistrar, srv HydraServiceServer) {
	s.RegisterService(&HydraService_ServiceDesc, srv)
}

func _HydraService_Heartbeat_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(HeartbeatRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(HydraServiceServer).Heartbeat(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: HydraService_Heartbeat_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(HydraServiceServer).Heartbeat(ctx, req.(*HeartbeatRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _HydraService_Lock_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(LockRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(HydraServiceServer).Lock(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: HydraService_Lock_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(HydraServiceServer).Lock(ctx, req.(*LockRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _HydraService_Unlock_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(UnlockRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(HydraServiceServer).Unlock(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: HydraService_Unlock_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(HydraServiceServer).Unlock(ctx, req.(*UnlockRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _HydraService_RegisterSwamp_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(RegisterSwampRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(HydraServiceServer).RegisterSwamp(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: HydraService_RegisterSwamp_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(HydraServiceServer).RegisterSwamp(ctx, req.(*RegisterSwampRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _HydraService_DeRegisterSwamp_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(DeRegisterSwampRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(HydraServiceServer).DeRegisterSwamp(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: HydraService_DeRegisterSwamp_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(HydraServiceServer).DeRegisterSwamp(ctx, req.(*DeRegisterSwampRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _HydraService_Set_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(SetRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(HydraServiceServer).Set(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: HydraService_Set_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(HydraServiceServer).Set(ctx, req.(*SetRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _HydraService_Get_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(GetRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(HydraServiceServer).Get(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: HydraService_Get_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(HydraServiceServer).Get(ctx, req.(*GetRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _HydraService_GetAll_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(GetAllRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(HydraServiceServer).GetAll(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: HydraService_GetAll_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(HydraServiceServer).GetAll(ctx, req.(*GetAllRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _HydraService_GetByIndex_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(GetByIndexRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(HydraServiceServer).GetByIndex(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: HydraService_GetByIndex_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(HydraServiceServer).GetByIndex(ctx, req.(*GetByIndexRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _HydraService_ShiftExpiredTreasures_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(ShiftExpiredTreasuresRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(HydraServiceServer).ShiftExpiredTreasures(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: HydraService_ShiftExpiredTreasures_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(HydraServiceServer).ShiftExpiredTreasures(ctx, req.(*ShiftExpiredTreasuresRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _HydraService_Destroy_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(DestroyRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(HydraServiceServer).Destroy(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: HydraService_Destroy_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(HydraServiceServer).Destroy(ctx, req.(*DestroyRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _HydraService_Delete_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(DeleteRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(HydraServiceServer).Delete(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: HydraService_Delete_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(HydraServiceServer).Delete(ctx, req.(*DeleteRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _HydraService_Count_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(CountRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(HydraServiceServer).Count(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: HydraService_Count_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(HydraServiceServer).Count(ctx, req.(*CountRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _HydraService_IsSwampExist_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(IsSwampExistRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(HydraServiceServer).IsSwampExist(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: HydraService_IsSwampExist_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(HydraServiceServer).IsSwampExist(ctx, req.(*IsSwampExistRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _HydraService_IsKeyExist_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(IsKeyExistRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(HydraServiceServer).IsKeyExist(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: HydraService_IsKeyExist_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(HydraServiceServer).IsKeyExist(ctx, req.(*IsKeyExistRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _HydraService_SubscribeToEvents_Handler(srv interface{}, stream grpc.ServerStream) error {
	m := new(SubscribeToEventsRequest)
	if err := stream.RecvMsg(m); err != nil {
		return err
	}
	return srv.(HydraServiceServer).SubscribeToEvents(m, &hydraServiceSubscribeToEventsServer{ServerStream: stream})
}

type HydraService_SubscribeToEventsServer interface {
	Send(*SubscribeToEventsResponse) error
	grpc.ServerStream
}

type hydraServiceSubscribeToEventsServer struct {
	grpc.ServerStream
}

func (x *hydraServiceSubscribeToEventsServer) Send(m *SubscribeToEventsResponse) error {
	return x.ServerStream.SendMsg(m)
}

func _HydraService_SubscribeToInfo_Handler(srv interface{}, stream grpc.ServerStream) error {
	m := new(SubscribeToInfoRequest)
	if err := stream.RecvMsg(m); err != nil {
		return err
	}
	return srv.(HydraServiceServer).SubscribeToInfo(m, &hydraServiceSubscribeToInfoServer{ServerStream: stream})
}

type HydraService_SubscribeToInfoServer interface {
	Send(*SubscribeToInfoResponse) error
	grpc.ServerStream
}

type hydraServiceSubscribeToInfoServer struct {
	grpc.ServerStream
}

func (x *hydraServiceSubscribeToInfoServer) Send(m *SubscribeToInfoResponse) error {
	return x.ServerStream.SendMsg(m)
}

func _HydraService_Uint32SlicePush_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(AddToUint32SlicePushRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(HydraServiceServer).Uint32SlicePush(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: HydraService_Uint32SlicePush_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(HydraServiceServer).Uint32SlicePush(ctx, req.(*AddToUint32SlicePushRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _HydraService_Uint32SliceDelete_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(Uint32SliceDeleteRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(HydraServiceServer).Uint32SliceDelete(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: HydraService_Uint32SliceDelete_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(HydraServiceServer).Uint32SliceDelete(ctx, req.(*Uint32SliceDeleteRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _HydraService_Uint32SliceSize_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(Uint32SliceSizeRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(HydraServiceServer).Uint32SliceSize(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: HydraService_Uint32SliceSize_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(HydraServiceServer).Uint32SliceSize(ctx, req.(*Uint32SliceSizeRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _HydraService_Uint32SliceIsValueExist_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(Uint32SliceIsValueExistRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(HydraServiceServer).Uint32SliceIsValueExist(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: HydraService_Uint32SliceIsValueExist_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(HydraServiceServer).Uint32SliceIsValueExist(ctx, req.(*Uint32SliceIsValueExistRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _HydraService_IncrementInt8_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(IncrementInt8Request)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(HydraServiceServer).IncrementInt8(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: HydraService_IncrementInt8_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(HydraServiceServer).IncrementInt8(ctx, req.(*IncrementInt8Request))
	}
	return interceptor(ctx, in, info, handler)
}

func _HydraService_IncrementInt16_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(IncrementInt16Request)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(HydraServiceServer).IncrementInt16(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: HydraService_IncrementInt16_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(HydraServiceServer).IncrementInt16(ctx, req.(*IncrementInt16Request))
	}
	return interceptor(ctx, in, info, handler)
}

func _HydraService_IncrementInt32_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(IncrementInt32Request)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(HydraServiceServer).IncrementInt32(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: HydraService_IncrementInt32_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(HydraServiceServer).IncrementInt32(ctx, req.(*IncrementInt32Request))
	}
	return interceptor(ctx, in, info, handler)
}

func _HydraService_IncrementInt64_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(IncrementInt64Request)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(HydraServiceServer).IncrementInt64(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: HydraService_IncrementInt64_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(HydraServiceServer).IncrementInt64(ctx, req.(*IncrementInt64Request))
	}
	return interceptor(ctx, in, info, handler)
}

func _HydraService_IncrementUint8_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(IncrementUint8Request)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(HydraServiceServer).IncrementUint8(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: HydraService_IncrementUint8_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(HydraServiceServer).IncrementUint8(ctx, req.(*IncrementUint8Request))
	}
	return interceptor(ctx, in, info, handler)
}

func _HydraService_IncrementUint16_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(IncrementUint16Request)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(HydraServiceServer).IncrementUint16(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: HydraService_IncrementUint16_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(HydraServiceServer).IncrementUint16(ctx, req.(*IncrementUint16Request))
	}
	return interceptor(ctx, in, info, handler)
}

func _HydraService_IncrementUint32_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(IncrementUint32Request)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(HydraServiceServer).IncrementUint32(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: HydraService_IncrementUint32_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(HydraServiceServer).IncrementUint32(ctx, req.(*IncrementUint32Request))
	}
	return interceptor(ctx, in, info, handler)
}

func _HydraService_IncrementUint64_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(IncrementUint64Request)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(HydraServiceServer).IncrementUint64(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: HydraService_IncrementUint64_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(HydraServiceServer).IncrementUint64(ctx, req.(*IncrementUint64Request))
	}
	return interceptor(ctx, in, info, handler)
}

func _HydraService_IncrementFloat32_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(IncrementFloat32Request)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(HydraServiceServer).IncrementFloat32(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: HydraService_IncrementFloat32_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(HydraServiceServer).IncrementFloat32(ctx, req.(*IncrementFloat32Request))
	}
	return interceptor(ctx, in, info, handler)
}

func _HydraService_IncrementFloat64_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(IncrementFloat64Request)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(HydraServiceServer).IncrementFloat64(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: HydraService_IncrementFloat64_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(HydraServiceServer).IncrementFloat64(ctx, req.(*IncrementFloat64Request))
	}
	return interceptor(ctx, in, info, handler)
}

// HydraService_ServiceDesc is the grpc.ServiceDesc for HydraService service.
// It's only intended for direct use with grpc.RegisterService,
// and not to be introspected or modified (even as a copy)
var HydraService_ServiceDesc = grpc.ServiceDesc{
	ServiceName: "hydrapb.HydraService",
	HandlerType: (*HydraServiceServer)(nil),
	Methods: []grpc.MethodDesc{
		{
			MethodName: "Heartbeat",
			Handler:    _HydraService_Heartbeat_Handler,
		},
		{
			MethodName: "Lock",
			Handler:    _HydraService_Lock_Handler,
		},
		{
			MethodName: "Unlock",
			Handler:    _HydraService_Unlock_Handler,
		},
		{
			MethodName: "RegisterSwamp",
			Handler:    _HydraService_RegisterSwamp_Handler,
		},
		{
			MethodName: "DeRegisterSwamp",
			Handler:    _HydraService_DeRegisterSwamp_Handler,
		},
		{
			MethodName: "Set",
			Handler:    _HydraService_Set_Handler,
		},
		{
			MethodName: "Get",
			Handler:    _HydraService_Get_Handler,
		},
		{
			MethodName: "GetAll",
			Handler:    _HydraService_GetAll_Handler,
		},
		{
			MethodName: "GetByIndex",
			Handler:    _HydraService_GetByIndex_Handler,
		},
		{
			MethodName: "ShiftExpiredTreasures",
			Handler:    _HydraService_ShiftExpiredTreasures_Handler,
		},
		{
			MethodName: "Destroy",
			Handler:    _HydraService_Destroy_Handler,
		},
		{
			MethodName: "Delete",
			Handler:    _HydraService_Delete_Handler,
		},
		{
			MethodName: "Count",
			Handler:    _HydraService_Count_Handler,
		},
		{
			MethodName: "IsSwampExist",
			Handler:    _HydraService_IsSwampExist_Handler,
		},
		{
			MethodName: "IsKeyExist",
			Handler:    _HydraService_IsKeyExist_Handler,
		},
		{
			MethodName: "Uint32SlicePush",
			Handler:    _HydraService_Uint32SlicePush_Handler,
		},
		{
			MethodName: "Uint32SliceDelete",
			Handler:    _HydraService_Uint32SliceDelete_Handler,
		},
		{
			MethodName: "Uint32SliceSize",
			Handler:    _HydraService_Uint32SliceSize_Handler,
		},
		{
			MethodName: "Uint32SliceIsValueExist",
			Handler:    _HydraService_Uint32SliceIsValueExist_Handler,
		},
		{
			MethodName: "IncrementInt8",
			Handler:    _HydraService_IncrementInt8_Handler,
		},
		{
			MethodName: "IncrementInt16",
			Handler:    _HydraService_IncrementInt16_Handler,
		},
		{
			MethodName: "IncrementInt32",
			Handler:    _HydraService_IncrementInt32_Handler,
		},
		{
			MethodName: "IncrementInt64",
			Handler:    _HydraService_IncrementInt64_Handler,
		},
		{
			MethodName: "IncrementUint8",
			Handler:    _HydraService_IncrementUint8_Handler,
		},
		{
			MethodName: "IncrementUint16",
			Handler:    _HydraService_IncrementUint16_Handler,
		},
		{
			MethodName: "IncrementUint32",
			Handler:    _HydraService_IncrementUint32_Handler,
		},
		{
			MethodName: "IncrementUint64",
			Handler:    _HydraService_IncrementUint64_Handler,
		},
		{
			MethodName: "IncrementFloat32",
			Handler:    _HydraService_IncrementFloat32_Handler,
		},
		{
			MethodName: "IncrementFloat64",
			Handler:    _HydraService_IncrementFloat64_Handler,
		},
	},
	Streams: []grpc.StreamDesc{
		{
			StreamName:    "SubscribeToEvents",
			Handler:       _HydraService_SubscribeToEvents_Handler,
			ServerStreams: true,
		},
		{
			StreamName:    "SubscribeToInfo",
			Handler:       _HydraService_SubscribeToInfo_Handler,
			ServerStreams: true,
		},
	},
	Metadata: "hydra.proto",
}
