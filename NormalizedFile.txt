================================================================================
🚀 CODEBASE NORMALIZED FILE
================================================================================
Generated on: 2025-07-30 09:36:50
Base Directory: C:\go\src\hydraide\app
Total Files: 48
================================================================================

📋 PROJECT STRUCTURE
----------------------------------------
📁 app/
├── 📁 core/
    └── 📝 README.md
├── 📁 core\compressor/
    └── 📝 compressor.go
    └── 📝 compressor_test.go
├── 📁 core\compressor\test-data/
    └── 📝 test-data.json
├── 📁 core\filesystem/
    └── 📝 filesystem.go
    └── 📝 filesystem_test.go
├── 📁 core\hydra/
    └── 📝 hydra.go
    └── 📝 hydra_test.go
├── 📁 core\hydra\gobber/
    └── 📝 go_test.go
    └── 📝 gobber.go
├── 📁 core\hydra\lock/
    └── 📝 lock.go
    └── 📝 lock_test.go
├── 📁 core\hydra\stringid/
    └── 📝 stringid.go
    └── 📝 stringid_test.go
├── 📁 core\hydra\swamp/
    └── 📝 swamp.go
    └── 📝 swamp_test.go
├── 📁 core\hydra\swamp\beacon/
    └── 📝 beacon.go
    └── 📝 beacon_test.go
├── 📁 core\hydra\swamp\chronicler/
    └── 📝 chronicler.go
├── 📁 core\hydra\swamp\metadata/
    └── 📝 metadata.go
    └── 📝 metadata_test.go
├── 📁 core\hydra\swamp\treasure/
    └── 📝 treasure.go
    └── 📝 treasure_test.go
├── 📁 core\hydra\swamp\treasure\guard/
    └── 📝 guard.go
    └── 📝 guard_test.go
├── 📁 core\hydra\swamp\vigil/
    └── 📝 vigil.go
    └── 📝 vigil_test.go
├── 📁 core\hydra\target/
    └── 📝 target.go
├── 📁 core\safeops/
    └── 📝 safeops.go
    └── 📝 safeops_test.go
├── 📁 core\settings/
    └── 📝 settings.go
    └── 📝 settings_test.go
├── 📁 core\settings\setting/
    └── 📝 setting.go
    └── 📝 setting_test.go
├── 📁 core\zeus/
    └── 📝 zeus.go
    └── 📝 zeus_test.go
├── 📁 name/
    └── 📝 README.md
    └── 📝 name.go
    └── 📝 name_test.go
├── 📁 server/
    └── 📝 Makefile
    └── 📝 main.go
├── 📁 server\e2etests/
    └── 📝 e2etests_test.go
├── 📁 server\gateway/
    └── 📝 gateway.go
├── 📁 server\loghandlers\fallback/
    └── 📝 fallback.go
├── 📁 server\loghandlers\graylog/
    └── 📝 graylog.go
├── 📁 server\loghandlers\slogmulti/
    └── 📝 slogmulti.go
├── 📁 server\observer/
    └── 📝 observer.go
├── 📁 server\server/
    └── 📝 server.go

================================================================================
📄 FILE CONTENTS
================================================================================

/==============================================================================\
| FILE: core\compressor\compressor.go
| PATH: C:\go\src\hydraide\app\core\compressor\compressor.go
| SIZE: 4.8 KB
\==============================================================================/

// Package compressor provides a simple interface to compress and decompress data using different algorithms
// A Hydra uses a compressor to store the Gems compressed in files and, after decompression,
// it is able to transform the Gems back into a readable format.
// The control of the compressor is done through the Traits, compressing and decompressing the data according to the
// algorithm specified in the setting. Therefore, the compressor is not accessible from the outside for the head of Hydra!
//
// The New function returns a new compressor. The compressorType parameter specifies the algorithm to be used.
package compressor

import (
	"bytes"
	"compress/gzip"
	"errors"
	"github.com/golang/snappy"
	"github.com/klauspost/compress/zstd"
	"github.com/pierrec/lz4"
	"io"
)

type Type int

// available compression methods
const (
	Gzip Type = iota + 1
	LZ4
	Snappy
	Zstd
)

type Compressor interface {
	Compress(uncompressed []byte) (compressed []byte, err error)
	Decompress(compressed []byte) (decompressed []byte, err error)
}

type compressor struct {
	compressorType Type
}

// New returns a new compressor
func New(compressorType Type) Compressor {

	return &compressor{
		compressorType: compressorType,
	}
}

// Compress compresses the given data using the given algorithm
func (c *compressor) Compress(uncompressed []byte) (compressed []byte, err error) {
	switch c.compressorType {
	case Gzip:
		return c.compressGzip(uncompressed)
	case LZ4:
		return c.compressLZ4(uncompressed)
	case Snappy:
		return c.compressSnappy(uncompressed)
	case Zstd:
		return c.compressZstd(uncompressed)
	}
	return nil, errors.New("unknown compressor type")
}

// Decompress decompresses the given data using the given algorithm
func (c *compressor) Decompress(compressed []byte) (decompressed []byte, err error) {
	switch c.compressorType {
	case Gzip:
		return c.decompressGzip(compressed)
	case LZ4:
		return c.decompressLZ4(compressed)
	case Snappy:
		return c.decompressSnappy(compressed)
	case Zstd:
		return c.decompressZstd(compressed)
	}
	return nil, errors.New("unknown compressor type")
}

// compressGzip compress the given data using the gzip algorithm
func (c *compressor) compressGzip(uncompressed []byte) (compressed []byte, err error) {

	var b bytes.Buffer
	gz := gzip.NewWriter(&b)

	if _, err = gz.Write(uncompressed); err != nil {
		return nil, err
	}
	if err = gz.Close(); err != nil {
		return nil, err
	}

	return b.Bytes(), nil

}

// decompressGzip decompress the given data using the gzip algorithm
func (c *compressor) decompressGzip(compressed []byte) (decompressed []byte, err error) {

	reader := bytes.NewReader(compressed)
	gzReader, e1 := gzip.NewReader(reader)

	if e1 != nil {
		return nil, err
	}

	output, e2 := io.ReadAll(gzReader)
	if e2 != nil {
		return nil, err
	}

	return output, nil

}

// compressLZ4 compress the given data using the lz4 algorithm
func (c *compressor) compressLZ4(uncompressed []byte) (compressed []byte, err error) {

	// create a new buffer to write the compressed data to
	w := &bytes.Buffer{}
	zw := lz4.NewWriter(w)
	_, err = zw.Write(uncompressed)
	if err != nil {
		return nil, err
	}
	// Closing is *very* important
	if err = zw.Close(); err != nil {
		return nil, err
	}
	return w.Bytes(), nil

}

// decompressLZ4 decompress the given data using the lz4 algorithm
func (c *compressor) decompressLZ4(compressed []byte) (decompressed []byte, err error) {

	r := bytes.NewReader(compressed)
	zr := lz4.NewReader(r)
	output, err := io.ReadAll(zr)
	if err != nil {
		return nil, err
	}
	return output, nil

}

// compressSnappy compress the given data using the snappy algorithm
func (c *compressor) compressSnappy(uncompressed []byte) (compressed []byte, err error) {
	compressed = snappy.Encode(nil, uncompressed)
	return compressed, nil
}

// decompressSnappy decompress the given data using the snappy algorithm
func (c *compressor) decompressSnappy(compressed []byte) (decompressed []byte, err error) {

	decompressed, err = snappy.Decode(nil, compressed)
	if err != nil {
		return nil, err
	}
	return decompressed, nil

}

// compressZstd compress the given data using the zstd algorithm
func (c *compressor) compressZstd(uncompressed []byte) (compressed []byte, err error) {

	w := &bytes.Buffer{}
	zstdEncoder, err := zstd.NewWriter(w)
	if err != nil {
		return nil, err
	}
	return zstdEncoder.EncodeAll(uncompressed, nil), nil

}

// decompressZstd decompress the given data using the zstd algorithm
func (c *compressor) decompressZstd(compressed []byte) (decompressed []byte, err error) {

	r := bytes.NewReader(compressed)
	zstdDecoder, err := zstd.NewReader(r)
	if err != nil {
		return nil, err
	}

	decompressed, err = zstdDecoder.DecodeAll(compressed, nil)
	return decompressed, err

}

--------------------------------------------------------------------------------

/==============================================================================\
| FILE: core\compressor\compressor_test.go
| PATH: C:\go\src\hydraide\app\core\compressor\compressor_test.go
| SIZE: 8.6 KB
\==============================================================================/

package compressor

import (
	_ "embed"
	"github.com/stretchr/testify/suite"
	"testing"
)

const lipsum = "Lorem ipsum dolor sit amet, consectetur adipiscing elit. In vel hendrerit diam. Nam fringilla arcu quis aliquet finibus. In viverra condimentum arcu, nec dignissim augue bibendum a."

//go:embed test-data/test-data.json
var jsonData []byte

type CompressorSuite struct {
	suite.Suite
}

func (c *CompressorSuite) TestGzip() {

	// test data
	compressorInterface := New(Gzip)
	compressed, err := compressorInterface.Compress(jsonData)
	c.Nil(err)

	decompressed, err := compressorInterface.Decompress(compressed)
	c.Nil(err)
	c.Equal(jsonData, decompressed)

}

func (c *CompressorSuite) TestLZ4() {

	// test data
	compressorInterface := New(LZ4)
	compressed, err := compressorInterface.Compress(jsonData)
	c.Nil(err)

	decompressed, err := compressorInterface.Decompress(compressed)
	c.Nil(err)
	c.Equal(jsonData, decompressed)

}

func (c *CompressorSuite) TestSnappy() {

	// test data
	compressorInterface := New(Snappy)
	compressed, err := compressorInterface.Compress(jsonData)
	c.Nil(err)

	decompressed, err := compressorInterface.Decompress(compressed)
	c.Nil(err)
	c.Equal(jsonData, decompressed)

}

func (c *CompressorSuite) TestZstd() {

	// test data
	compressorInterface := New(Zstd)
	compressed, err := compressorInterface.Compress(jsonData)
	c.Nil(err)

	decompressed, err := compressorInterface.Decompress(compressed)
	c.Nil(err)
	c.Equal(jsonData, decompressed)

}

func TestNew(t *testing.T) {
	suite.Run(t, new(CompressorSuite))
}

// goos: windows
// goarch: amd64
// cpu: AMD Ryzen 9 5950X 16-Core Processor
// BenchmarkCompressor_Compress_Gzip
// BenchmarkCompressor_Compress_Gzip_lipsum-26         8630            149521 ns/op
func BenchmarkCompressor_Compress_Gzip_lipsum(b *testing.B) {

	// test data
	compressorInterface := New(Gzip)
	data := []byte(lipsum)
	b.ResetTimer()
	for i := 0; i < b.N; i++ {
		_, _ = compressorInterface.Compress(data)
	}

}

// goos: windows
// goarch: amd64
// cpu: AMD Ryzen 9 5950X 16-Core Processor
// BenchmarkCompressor_Decompress_Gzip
// BenchmarkCompressor_Decompress_Gzip-26            147265              8003 ns/op
func BenchmarkCompressor_Decompress_Gzip(b *testing.B) {

	compressorInterface := New(Gzip)
	compressed, _ := compressorInterface.Compress([]byte(lipsum))
	b.ResetTimer()
	for i := 0; i < b.N; i++ {
		_, _ = compressorInterface.Decompress(compressed)
	}

}

// goos: windows
// goarch: amd64
// cpu: AMD Ryzen 9 5950X 16-Core Processor
// BenchmarkCompressor_Compress_Gzip_json
// BenchmarkCompressor_Compress_Gzip_json-32            907           1302005 ns/op
func BenchmarkCompressor_Compress_Gzip_json(b *testing.B) {

	// test data
	compressorInterface := New(Gzip)
	b.ResetTimer()
	for i := 0; i < b.N; i++ {
		_, _ = compressorInterface.Compress(jsonData)
	}

}

func BenchmarkCompressor_Decompress_Gzip_json(b *testing.B) {

	compressorInterface := New(Gzip)
	compressed, _ := compressorInterface.Compress(jsonData)
	b.ResetTimer()
	for i := 0; i < b.N; i++ {
		_, _ = compressorInterface.Decompress(compressed)
	}

}

// goos: windows
// goarch: amd64
// sor
// cpu: AMD Ryzen 9 5950X 16-Core Processor
// BenchmarkCompressor_Compress_LZ4
// BenchmarkCompressor_Compress_LZ4-32         1566            760116 ns/op
func BenchmarkCompressor_Compress_LZ4(b *testing.B) {

	// test data
	compressorInterface := New(LZ4)
	b.ResetTimer()
	for i := 0; i < b.N; i++ {
		_, _ = compressorInterface.Compress([]byte(lipsum))
	}

}

// goos: windows
// goarch: amd64
// sor
// cpu: AMD Ryzen 9 5950X 16-Core Processor
// BenchmarkCompressor_Decompress_LZ4
// BenchmarkCompressor_Decompress_LZ4-26               2576            484257 ns/op
func BenchmarkCompressor_Decompress_LZ4(b *testing.B) {

	// test data
	compressorInterface := New(LZ4)
	compressed, _ := compressorInterface.Compress([]byte(lipsum))
	b.ResetTimer()
	for i := 0; i < b.N; i++ {
		_, _ = compressorInterface.Decompress(compressed)
	}

}

// goos: windows
// goarch: amd64
// cpu: AMD Ryzen 9 5950X 16-Core Processor
// BenchmarkCompressor_Compress_LZ4_json
// BenchmarkCompressor_Compress_LZ4_json-26            1616            727394 ns/op
func BenchmarkCompressor_Compress_LZ4_json(b *testing.B) {

	// test data
	compressorInterface := New(LZ4)
	b.ResetTimer()
	for i := 0; i < b.N; i++ {
		_, _ = compressorInterface.Compress(jsonData)
	}

}

// goos: windows
// goarch: amd64
// cpu: AMD Ryzen 9 5950X 16-Core Processor
// BenchmarkCompressor_Decompress_LZ4_json
// BenchmarkCompressor_Decompress_LZ4_json-26          1774            746229 ns/op
func BenchmarkCompressor_Decompress_LZ4_json(b *testing.B) {

	// test data
	compressorInterface := New(LZ4)
	compressed, _ := compressorInterface.Compress(jsonData)
	b.ResetTimer()
	for i := 0; i < b.N; i++ {
		_, _ = compressorInterface.Decompress(compressed)
	}

}

// goos: windows
// goarch: amd64
// sor
// cpu: AMD Ryzen 9 5950X 16-Core Processor
// BenchmarkCompressor_Compress_Snappy
// BenchmarkCompressor_Compress_Snappy-32           6855946               174.0 ns/
func BenchmarkCompressor_Compress_Snappy(b *testing.B) {

	// test data
	compressorInterface := New(Snappy)
	b.ResetTimer()
	for i := 0; i < b.N; i++ {
		_, _ = compressorInterface.Compress([]byte(lipsum))
	}

}

// goos: windows
// goarch: amd64
// sor
// cpu: AMD Ryzen 9 5950X 16-Core Processor
// BenchmarkCompressor_Decompress_Snappy
// BenchmarkCompressor_Decompress_Snappy-26        24138042                53.28 ns
func BenchmarkCompressor_Decompress_Snappy(b *testing.B) {

	// test data
	compressorInterface := New(Snappy)
	compressed, _ := compressorInterface.Compress([]byte(lipsum))
	b.ResetTimer()
	for i := 0; i < b.N; i++ {
		_, _ = compressorInterface.Decompress(compressed)
	}

}

// goos: windows
// goarch: amd64
// cpu: AMD Ryzen 9 5950X 16-Core Processor
// BenchmarkCompressor_Compress_Snappy_json
// BenchmarkCompressor_Compress_Snappy_json-26        13722             83310 ns/op
func BenchmarkCompressor_Compress_Snappy_json(b *testing.B) {

	// test data
	compressorInterface := New(Snappy)
	b.ResetTimer()
	for i := 0; i < b.N; i++ {
		_, _ = compressorInterface.Compress(jsonData)
	}

}

// goos: windows
// goarch: amd64
// cpu: AMD Ryzen 9 5950X 16-Core Processor
// BenchmarkCompressor_Decompress_Snappy_json
// BenchmarkCompressor_Decompress_Snappy_json-26              40098             310
func BenchmarkCompressor_Decompress_Snappy_json(b *testing.B) {

	// test data
	compressorInterface := New(Snappy)
	compressed, _ := compressorInterface.Compress(jsonData)
	b.ResetTimer()
	for i := 0; i < b.N; i++ {
		_, _ = compressorInterface.Decompress(compressed)
	}

}

// goos: windows
// goarch: amd64
// sor
// cpu: AMD Ryzen 9 5950X 16-Core Processor
// BenchmarkCompressor_Compress_Zstd
// BenchmarkCompressor_Compress_Zstd-26                 468           2555395 ns/op
func BenchmarkCompressor_Compress_Zstd(b *testing.B) {

	// test data
	compressorInterface := New(Zstd)
	b.ResetTimer()
	for i := 0; i < b.N; i++ {
		_, _ = compressorInterface.Compress([]byte(lipsum))
	}

}

// goos: windows
// goarch: amd64
// sor
// cpu: AMD Ryzen 9 5950X 16-Core Processor
// BenchmarkCompressor_Decompress_Zstd
// BenchmarkCompressor_Decompress_Zstd-26            234162              7051 ns/op
func BenchmarkCompressor_Decompress_Zstd(b *testing.B) {

	// test data
	compressorInterface := New(Zstd)
	compressed, _ := compressorInterface.Compress([]byte(lipsum))
	b.ResetTimer()
	for i := 0; i < b.N; i++ {
		_, _ = compressorInterface.Decompress(compressed)
	}

}

// goos: windows
// goarch: amd64
// cpu: AMD Ryzen 9 5950X 16-Core Processor
// BenchmarkCompressor_Compress_Zstd_json
// BenchmarkCompressor_Compress_Zstd_json-26            324           3117190 ns/op
func BenchmarkCompressor_Compress_Zstd_json(b *testing.B) {

	// test data
	compressorInterface := New(Zstd)
	b.ResetTimer()
	for i := 0; i < b.N; i++ {
		_, _ = compressorInterface.Compress(jsonData)
	}

}

// goos: windows
// goarch: amd64
// cpu: AMD Ryzen 9 5950X 16-Core Processor
// BenchmarkCompressor_Decompress_Zstd_json
// BenchmarkCompressor_Decompress_Zstd_json-26         6168            223583 ns/op
func BenchmarkCompressor_Decompress_Zstd_json(b *testing.B) {

	// test data
	compressorInterface := New(Zstd)
	compressed, _ := compressorInterface.Compress(jsonData)
	b.ResetTimer()
	for i := 0; i < b.N; i++ {
		_, _ = compressorInterface.Decompress(compressed)
	}

}

--------------------------------------------------------------------------------

/==============================================================================\
| FILE: core\compressor\test-data\test-data.json
| PATH: C:\go\src\hydraide\app\core\compressor\test-data\test-data.json
| SIZE: 86.1 KB
\==============================================================================/

[
  {
    "_id": "63982bbb466976c45ac01b23",
    "index": 0,
    "guid": "ef1f1974-e863-44b7-8f96-f09fdb01ee34",
    "isActive": true,
    "balance": "$1,849.47",
    "picture": "http://placehold.it/32x32",
    "age": 30,
    "eyeColor": "brown",
    "name": "Carter Bush",
    "gender": "male",
    "company": "EYEWAX",
    "email": "carterbush@eyewax.com",
    "phone": "+1 (940) 464-2625",
    "address": "491 Downing Street, Abrams, Northern Mariana Islands, 2477",
    "about": "Anim adipisicing aliquip Lorem Lorem culpa officia adipisicing irure non eu velit officia. Excepteur quis qui voluptate elit quis ullamco eiusmod magna eiusmod anim deserunt esse commodo cillum. Quis excepteur ex consequat nisi do adipisicing nostrud occaecat sint est.\r\n",
    "registered": "2021-11-20T09:18:00 -01:00",
    "latitude": 16.980617,
    "longitude": 57.343218,
    "tags": [
      "dolor",
      "commodo",
      "est",
      "mollit",
      "sint",
      "incididunt",
      "voluptate"
    ],
    "friends": [
      {
        "id": 0,
        "name": "Erna Edwards"
      },
      {
        "id": 1,
        "name": "Noble Fischer"
      },
      {
        "id": 2,
        "name": "Benson Davidson"
      }
    ],
    "greeting": "Hello, Carter Bush! You have 8 unread messages.",
    "favoriteFruit": "apple"
  },
  {
    "_id": "63982bbb0c0c7140a71eb0be",
    "index": 1,
    "guid": "1d6b9d77-9f31-4d32-85a1-e83e0fe13110",
    "isActive": false,
    "balance": "$1,714.54",
    "picture": "http://placehold.it/32x32",
    "age": 38,
    "eyeColor": "green",
    "name": "Berg Grimes",
    "gender": "male",
    "company": "SILODYNE",
    "email": "berggrimes@silodyne.com",
    "phone": "+1 (873) 492-2344",
    "address": "381 Ditmars Street, Riner, Florida, 806",
    "about": "Nisi reprehenderit sunt elit id ullamco non qui duis ad cupidatat exercitation laboris ex. Do exercitation qui proident Lorem deserunt cupidatat reprehenderit aliqua non consequat cupidatat aliqua sit fugiat. Magna elit quis duis ipsum aliqua esse nisi minim. Eiusmod dolore sit voluptate culpa voluptate quis sit sit id. Id commodo laborum officia aute. Cupidatat aliqua magna et adipisicing est anim id ea aliquip ut laborum. Sit reprehenderit sint aliqua eiusmod nostrud fugiat anim veniam excepteur laboris exercitation quis qui enim.\r\n",
    "registered": "2022-01-01T04:28:23 -01:00",
    "latitude": 74.749976,
    "longitude": 67.989052,
    "tags": [
      "officia",
      "eu",
      "cillum",
      "non",
      "et",
      "officia",
      "anim"
    ],
    "friends": [
      {
        "id": 0,
        "name": "Valdez Mccall"
      },
      {
        "id": 1,
        "name": "Estelle Guy"
      },
      {
        "id": 2,
        "name": "Leonor Rutledge"
      }
    ],
    "greeting": "Hello, Berg Grimes! You have 6 unread messages.",
    "favoriteFruit": "apple"
  },
  {
    "_id": "63982bbbda10dd3905c5f782",
    "index": 2,
    "guid": "248d4b91-e549-4b7e-836b-62df5eafbc74",
    "isActive": true,
    "balance": "$1,384.38",
    "picture": "http://placehold.it/32x32",
    "age": 20,
    "eyeColor": "blue",
    "name": "West Porter",
    "gender": "male",
    "company": "SEALOUD",
    "email": "westporter@sealoud.com",
    "phone": "+1 (946) 488-3411",
    "address": "461 Micieli Place, Mulberry, Missouri, 9214",
    "about": "Excepteur fugiat duis irure aliquip proident excepteur quis velit est ex. Tempor sint deserunt dolor mollit eiusmod esse exercitation. Fugiat reprehenderit occaecat exercitation non. Sint nostrud labore eiusmod sit commodo commodo excepteur proident ad ut elit nulla ex nostrud. Ex mollit sint exercitation ut ipsum laboris sint pariatur enim. Sunt ut duis minim exercitation.\r\n",
    "registered": "2022-07-26T07:12:37 -02:00",
    "latitude": -53.154931,
    "longitude": -46.371205,
    "tags": [
      "nostrud",
      "commodo",
      "cillum",
      "id",
      "est",
      "elit",
      "cillum"
    ],
    "friends": [
      {
        "id": 0,
        "name": "Adams Mercer"
      },
      {
        "id": 1,
        "name": "Michele Mcfadden"
      },
      {
        "id": 2,
        "name": "Mathis Holloway"
      }
    ],
    "greeting": "Hello, West Porter! You have 3 unread messages.",
    "favoriteFruit": "banana"
  },
  {
    "_id": "63982bbbee4334f456c19382",
    "index": 3,
    "guid": "cde9a617-1526-4cdb-874b-52bb30608f08",
    "isActive": true,
    "balance": "$3,966.03",
    "picture": "http://placehold.it/32x32",
    "age": 26,
    "eyeColor": "brown",
    "name": "Rutledge Cline",
    "gender": "male",
    "company": "BULLJUICE",
    "email": "rutledgecline@bulljuice.com",
    "phone": "+1 (911) 502-2540",
    "address": "683 Lenox Road, Eggertsville, California, 9880",
    "about": "Laborum Lorem ipsum magna amet proident irure enim aliqua voluptate qui adipisicing. Dolore nulla culpa ullamco consequat est tempor magna et voluptate id non. Ad occaecat exercitation deserunt occaecat et eu aute deserunt adipisicing. Sint consectetur sit enim pariatur pariatur in veniam nostrud sunt esse ullamco voluptate reprehenderit. Esse veniam eiusmod reprehenderit in cupidatat.\r\n",
    "registered": "2021-10-16T01:40:03 -02:00",
    "latitude": -29.16476,
    "longitude": 4.735624,
    "tags": [
      "cillum",
      "et",
      "sunt",
      "adipisicing",
      "ullamco",
      "nostrud",
      "commodo"
    ],
    "friends": [
      {
        "id": 0,
        "name": "Leila Whitfield"
      },
      {
        "id": 1,
        "name": "Chambers Everett"
      },
      {
        "id": 2,
        "name": "Reilly Faulkner"
      }
    ],
    "greeting": "Hello, Rutledge Cline! You have 4 unread messages.",
    "favoriteFruit": "banana"
  },
  {
    "_id": "63982bbbcae9bf5f9c35fdbc",
    "index": 4,
    "guid": "093a812d-11ef-4999-9d13-7976b9e3dcf7",
    "isActive": false,
    "balance": "$2,146.99",
    "picture": "http://placehold.it/32x32",
    "age": 21,
    "eyeColor": "green",
    "name": "Darcy York",
    "gender": "female",
    "company": "REMOLD",
    "email": "darcyyork@remold.com",
    "phone": "+1 (966) 400-3247",
    "address": "831 Flatbush Avenue, Sparkill, Maine, 7252",
    "about": "Voluptate anim ad anim pariatur. Sunt do cillum voluptate laborum. Voluptate fugiat consequat consectetur id.\r\n",
    "registered": "2021-12-31T10:16:32 -01:00",
    "latitude": 29.522778,
    "longitude": -22.331419,
    "tags": [
      "cupidatat",
      "adipisicing",
      "adipisicing",
      "sunt",
      "adipisicing",
      "quis",
      "dolore"
    ],
    "friends": [
      {
        "id": 0,
        "name": "Jefferson Garner"
      },
      {
        "id": 1,
        "name": "Fletcher Dunlap"
      },
      {
        "id": 2,
        "name": "Bridges Flores"
      }
    ],
    "greeting": "Hello, Darcy York! You have 6 unread messages.",
    "favoriteFruit": "apple"
  },
  {
    "_id": "63982bbbb3b319db392ccdbd",
    "index": 5,
    "guid": "4b830898-192f-4adc-a23b-c5f052a0d9ea",
    "isActive": true,
    "balance": "$2,413.00",
    "picture": "http://placehold.it/32x32",
    "age": 40,
    "eyeColor": "blue",
    "name": "Byrd Thornton",
    "gender": "male",
    "company": "QUONATA",
    "email": "byrdthornton@quonata.com",
    "phone": "+1 (907) 469-3117",
    "address": "203 Bainbridge Street, Sisquoc, Idaho, 7074",
    "about": "Minim ad nulla est nisi aliqua sunt aliqua qui nisi ex cupidatat. Nostrud velit deserunt irure officia exercitation ex. Fugiat proident reprehenderit velit id ullamco ipsum occaecat. Magna Lorem labore aliquip ullamco enim exercitation minim cillum mollit commodo adipisicing nulla.\r\n",
    "registered": "2014-09-21T04:11:15 -02:00",
    "latitude": -86.524338,
    "longitude": 143.833307,
    "tags": [
      "nostrud",
      "nulla",
      "Lorem",
      "officia",
      "dolore",
      "non",
      "quis"
    ],
    "friends": [
      {
        "id": 0,
        "name": "Lee Walters"
      },
      {
        "id": 1,
        "name": "Beulah Stafford"
      },
      {
        "id": 2,
        "name": "Cote Copeland"
      }
    ],
    "greeting": "Hello, Byrd Thornton! You have 5 unread messages.",
    "favoriteFruit": "banana"
  },
  {
    "_id": "63982bbbe8eda0da368b9443",
    "index": 6,
    "guid": "2bcde410-5f07-4e08-bf7f-1830705c9d9b",
    "isActive": false,
    "balance": "$3,234.69",
    "picture": "http://placehold.it/32x32",
    "age": 32,
    "eyeColor": "green",
    "name": "Lucas Hicks",
    "gender": "male",
    "company": "ZENSOR",
    "email": "lucashicks@zensor.com",
    "phone": "+1 (972) 498-3155",
    "address": "754 Williams Court, Sunwest, Minnesota, 7650",
    "about": "Ipsum enim tempor ipsum duis exercitation aliqua eiusmod cupidatat officia id labore laboris ea labore. Nostrud sint velit duis ut ex sit pariatur mollit occaecat. Occaecat eiusmod in id dolore irure quis do. Dolor enim do eu aute. Aute veniam excepteur ad aute Lorem anim esse velit et.\r\n",
    "registered": "2014-11-17T04:39:56 -01:00",
    "latitude": 8.965937,
    "longitude": 100.407972,
    "tags": [
      "dolor",
      "occaecat",
      "excepteur",
      "officia",
      "ex",
      "nisi",
      "nulla"
    ],
    "friends": [
      {
        "id": 0,
        "name": "Alexandria Castro"
      },
      {
        "id": 1,
        "name": "Hutchinson Alvarado"
      },
      {
        "id": 2,
        "name": "Beth Mcintosh"
      }
    ],
    "greeting": "Hello, Lucas Hicks! You have 3 unread messages.",
    "favoriteFruit": "banana"
  },
  {
    "_id": "63982bbbadea1eb3b0440626",
    "index": 7,
    "guid": "30544e47-55a7-4144-b8a2-270efed5d814",
    "isActive": true,
    "balance": "$3,666.20",
    "picture": "http://placehold.it/32x32",
    "age": 25,
    "eyeColor": "brown",
    "name": "Hale Albert",
    "gender": "male",
    "company": "EXOSWITCH",
    "email": "halealbert@exoswitch.com",
    "phone": "+1 (895) 504-3842",
    "address": "579 Lloyd Court, Detroit, Massachusetts, 8833",
    "about": "Sit id proident deserunt labore eu dolor irure sit. Anim do tempor proident officia sit et laborum aute. Laboris laborum excepteur elit proident. Ad ipsum fugiat do nulla eu nisi voluptate. Adipisicing fugiat non veniam incididunt non. Velit veniam sunt et aliqua laboris.\r\n",
    "registered": "2019-04-10T09:38:27 -02:00",
    "latitude": -1.02734,
    "longitude": 109.280154,
    "tags": [
      "aute",
      "laboris",
      "incididunt",
      "id",
      "pariatur",
      "esse",
      "reprehenderit"
    ],
    "friends": [
      {
        "id": 0,
        "name": "Brady Velasquez"
      },
      {
        "id": 1,
        "name": "Brewer Suarez"
      },
      {
        "id": 2,
        "name": "Sharpe Hahn"
      }
    ],
    "greeting": "Hello, Hale Albert! You have 8 unread messages.",
    "favoriteFruit": "strawberry"
  },
  {
    "_id": "63982bbb0cad835e718bc2c2",
    "index": 8,
    "guid": "cb9c4665-03f1-41e3-a351-25335e263a58",
    "isActive": false,
    "balance": "$3,310.15",
    "picture": "http://placehold.it/32x32",
    "age": 29,
    "eyeColor": "brown",
    "name": "Constance Olsen",
    "gender": "female",
    "company": "XTH",
    "email": "constanceolsen@xth.com",
    "phone": "+1 (942) 554-2316",
    "address": "991 Jaffray Street, Vandiver, Virgin Islands, 1206",
    "about": "Incididunt proident sit labore dolor quis ullamco. Occaecat pariatur irure incididunt laboris. Fugiat fugiat adipisicing labore mollit reprehenderit laboris ex enim. Ad duis laboris qui excepteur do cupidatat et consequat deserunt exercitation minim adipisicing. Ut sunt consequat eiusmod eiusmod. Laboris laborum ipsum officia ad non aliqua sunt reprehenderit mollit ullamco commodo consequat. Ullamco do amet sunt duis.\r\n",
    "registered": "2017-06-15T05:17:53 -02:00",
    "latitude": -20.584082,
    "longitude": 62.670765,
    "tags": [
      "aliqua",
      "officia",
      "et",
      "aliqua",
      "do",
      "sit",
      "pariatur"
    ],
    "friends": [
      {
        "id": 0,
        "name": "Magdalena Bentley"
      },
      {
        "id": 1,
        "name": "Kirsten Franklin"
      },
      {
        "id": 2,
        "name": "Schultz Puckett"
      }
    ],
    "greeting": "Hello, Constance Olsen! You have 4 unread messages.",
    "favoriteFruit": "banana"
  },
  {
    "_id": "63982bbbe0c1fed51118b0b5",
    "index": 9,
    "guid": "cb47dd3d-f428-4978-a6d9-f2f0add83be6",
    "isActive": true,
    "balance": "$2,006.65",
    "picture": "http://placehold.it/32x32",
    "age": 23,
    "eyeColor": "green",
    "name": "Jerry Raymond",
    "gender": "female",
    "company": "TERAPRENE",
    "email": "jerryraymond@teraprene.com",
    "phone": "+1 (813) 515-3274",
    "address": "881 Garland Court, Gambrills, South Dakota, 3408",
    "about": "Ipsum mollit commodo laborum velit ut. Dolore excepteur ipsum laboris proident irure ullamco. Fugiat fugiat Lorem labore irure cillum exercitation nulla irure.\r\n",
    "registered": "2017-04-07T11:20:14 -02:00",
    "latitude": 47.781002,
    "longitude": 158.696198,
    "tags": [
      "amet",
      "sint",
      "sit",
      "fugiat",
      "sit",
      "mollit",
      "aliquip"
    ],
    "friends": [
      {
        "id": 0,
        "name": "Amanda Woodward"
      },
      {
        "id": 1,
        "name": "Gilliam Lancaster"
      },
      {
        "id": 2,
        "name": "Chan Parker"
      }
    ],
    "greeting": "Hello, Jerry Raymond! You have 10 unread messages.",
    "favoriteFruit": "banana"
  },
  {
    "_id": "63982bbb9818756444474010",
    "index": 10,
    "guid": "9d7e222b-d671-4bdb-bf4a-afc788b11e35",
    "isActive": false,
    "balance": "$2,631.30",
    "picture": "http://placehold.it/32x32",
    "age": 35,
    "eyeColor": "brown",
    "name": "Talley Foster",
    "gender": "male",
    "company": "EMTRAK",
    "email": "talleyfoster@emtrak.com",
    "phone": "+1 (913) 464-2580",
    "address": "606 Lake Street, Barrelville, West Virginia, 3173",
    "about": "Reprehenderit enim excepteur ut enim nisi nisi esse cupidatat pariatur esse reprehenderit ipsum. Quis sit aliquip velit ad magna consectetur dolor nisi esse qui consequat enim sint. Deserunt voluptate eu ullamco irure adipisicing consequat. Dolore est non et elit proident officia aliqua eu commodo.\r\n",
    "registered": "2017-01-03T07:40:24 -01:00",
    "latitude": 33.515357,
    "longitude": 3.177387,
    "tags": [
      "sunt",
      "magna",
      "occaecat",
      "quis",
      "dolore",
      "exercitation",
      "magna"
    ],
    "friends": [
      {
        "id": 0,
        "name": "Wright Wilder"
      },
      {
        "id": 1,
        "name": "King Robertson"
      },
      {
        "id": 2,
        "name": "Jenifer Lindsey"
      }
    ],
    "greeting": "Hello, Talley Foster! You have 6 unread messages.",
    "favoriteFruit": "apple"
  },
  {
    "_id": "63982bbb0c2fe2173ea2dcd1",
    "index": 11,
    "guid": "28932b05-0035-4001-b25c-b41c0bca8c68",
    "isActive": true,
    "balance": "$2,683.63",
    "picture": "http://placehold.it/32x32",
    "age": 34,
    "eyeColor": "green",
    "name": "Mendoza Haney",
    "gender": "male",
    "company": "TALAE",
    "email": "mendozahaney@talae.com",
    "phone": "+1 (810) 546-2679",
    "address": "585 Wilson Street, Biehle, Virginia, 6556",
    "about": "Cupidatat irure adipisicing dolore do non dolore. Duis amet in enim elit. Aliqua aliquip esse qui eu ipsum. Pariatur nisi amet et est pariatur tempor commodo anim exercitation. Est irure ullamco velit sunt cupidatat minim ipsum non Lorem nostrud Lorem commodo nulla duis. Labore exercitation voluptate sit dolore enim nostrud labore exercitation nisi non aliquip. Veniam eiusmod proident incididunt consectetur est.\r\n",
    "registered": "2020-03-27T12:33:00 -01:00",
    "latitude": -37.600396,
    "longitude": 115.135267,
    "tags": [
      "cillum",
      "sit",
      "reprehenderit",
      "laboris",
      "Lorem",
      "culpa",
      "sit"
    ],
    "friends": [
      {
        "id": 0,
        "name": "Yvette Hester"
      },
      {
        "id": 1,
        "name": "Inez Gilbert"
      },
      {
        "id": 2,
        "name": "Gretchen Prince"
      }
    ],
    "greeting": "Hello, Mendoza Haney! You have 3 unread messages.",
    "favoriteFruit": "apple"
  },
  {
    "_id": "63982bbb0d69c16beb2101ea",
    "index": 12,
    "guid": "7d0fdc51-eea4-42bf-a06c-a58ee26f4c22",
    "isActive": false,
    "balance": "$1,479.94",
    "picture": "http://placehold.it/32x32",
    "age": 38,
    "eyeColor": "green",
    "name": "Georgette Rosales",
    "gender": "female",
    "company": "TELLIFLY",
    "email": "georgetterosales@tellifly.com",
    "phone": "+1 (927) 484-2982",
    "address": "454 Bridgewater Street, Aurora, Hawaii, 6718",
    "about": "Culpa aliqua cupidatat nisi cillum ad dolore culpa fugiat mollit Lorem amet velit eiusmod. Est officia reprehenderit velit nulla non ullamco sint adipisicing et mollit aliquip eu nostrud eiusmod. Aute velit velit mollit pariatur reprehenderit dolor irure sint ullamco incididunt pariatur irure aliqua ex. Irure dolore magna eiusmod ea fugiat reprehenderit id in officia. Eiusmod voluptate qui minim aliquip in veniam ex dolor est tempor Lorem.\r\n",
    "registered": "2019-04-13T11:52:09 -02:00",
    "latitude": -6.9915,
    "longitude": 114.111951,
    "tags": [
      "qui",
      "do",
      "Lorem",
      "exercitation",
      "aute",
      "culpa",
      "culpa"
    ],
    "friends": [
      {
        "id": 0,
        "name": "Latisha Fox"
      },
      {
        "id": 1,
        "name": "Sadie Harrington"
      },
      {
        "id": 2,
        "name": "Ford Carson"
      }
    ],
    "greeting": "Hello, Georgette Rosales! You have 10 unread messages.",
    "favoriteFruit": "strawberry"
  },
  {
    "_id": "63982bbb98b70381388c1a5d",
    "index": 13,
    "guid": "5dc560ef-61a0-4753-b773-716efc2e6c73",
    "isActive": false,
    "balance": "$2,236.05",
    "picture": "http://placehold.it/32x32",
    "age": 31,
    "eyeColor": "brown",
    "name": "Walter Cooley",
    "gender": "male",
    "company": "TERRAGO",
    "email": "waltercooley@terrago.com",
    "phone": "+1 (874) 501-3013",
    "address": "189 Holt Court, Rote, Ohio, 4923",
    "about": "Amet occaecat culpa est non aliqua aute ex officia id consequat quis. Ut aliqua velit tempor tempor dolor elit nisi elit. Fugiat ut ut dolor consectetur eu mollit mollit laboris adipisicing.\r\n",
    "registered": "2021-03-11T01:00:42 -01:00",
    "latitude": -19.042168,
    "longitude": 59.12035,
    "tags": [
      "ipsum",
      "et",
      "deserunt",
      "labore",
      "consequat",
      "fugiat",
      "fugiat"
    ],
    "friends": [
      {
        "id": 0,
        "name": "Naomi Cash"
      },
      {
        "id": 1,
        "name": "Wong Whitley"
      },
      {
        "id": 2,
        "name": "Spence Wood"
      }
    ],
    "greeting": "Hello, Walter Cooley! You have 2 unread messages.",
    "favoriteFruit": "apple"
  },
  {
    "_id": "63982bbbafa923271c0e0ee8",
    "index": 14,
    "guid": "dedafcd3-b3ad-428c-9e7d-5367c1799fb4",
    "isActive": true,
    "balance": "$1,091.55",
    "picture": "http://placehold.it/32x32",
    "age": 35,
    "eyeColor": "brown",
    "name": "Jeanette Peck",
    "gender": "female",
    "company": "SAVVY",
    "email": "jeanettepeck@savvy.com",
    "phone": "+1 (868) 430-2833",
    "address": "199 Crooke Avenue, Condon, Illinois, 6047",
    "about": "Amet tempor qui elit minim velit. Consequat do aliquip magna pariatur consectetur cupidatat voluptate pariatur qui voluptate. In esse elit dolor deserunt ipsum. Consequat tempor duis ullamco est aliqua proident eu fugiat consectetur aliqua. Est nisi dolore laboris non Lorem.\r\n",
    "registered": "2017-07-20T05:57:58 -02:00",
    "latitude": -54.308902,
    "longitude": -135.380305,
    "tags": [
      "ex",
      "esse",
      "nisi",
      "consectetur",
      "eu",
      "nulla",
      "id"
    ],
    "friends": [
      {
        "id": 0,
        "name": "Lilia Pace"
      },
      {
        "id": 1,
        "name": "Shari Velez"
      },
      {
        "id": 2,
        "name": "Daugherty Dawson"
      }
    ],
    "greeting": "Hello, Jeanette Peck! You have 6 unread messages.",
    "favoriteFruit": "banana"
  },
  {
    "_id": "63982bbbcb3249d9db42a522",
    "index": 15,
    "guid": "75fefb63-7bee-4ba5-96d2-dfc77eb3ac8b",
    "isActive": true,
    "balance": "$2,457.15",
    "picture": "http://placehold.it/32x32",
    "age": 34,
    "eyeColor": "green",
    "name": "Effie Vasquez",
    "gender": "female",
    "company": "VIAGREAT",
    "email": "effievasquez@viagreat.com",
    "phone": "+1 (871) 461-3813",
    "address": "411 Stillwell Avenue, Disautel, Nevada, 6778",
    "about": "Adipisicing voluptate in id consectetur esse officia aliquip tempor magna. Proident veniam amet velit do esse id occaecat ipsum ipsum do sint et adipisicing. Magna nisi cupidatat tempor mollit consectetur quis id do est veniam quis commodo nostrud minim. Ut ullamco exercitation cillum nostrud nostrud nulla deserunt ipsum velit. Non esse Lorem in occaecat. Labore qui excepteur amet consectetur occaecat duis excepteur non fugiat nisi occaecat laboris. Et aliqua cupidatat quis exercitation nulla aliquip dolor cupidatat sint adipisicing.\r\n",
    "registered": "2022-11-29T08:46:53 -01:00",
    "latitude": -33.26013,
    "longitude": -67.078401,
    "tags": [
      "proident",
      "proident",
      "voluptate",
      "pariatur",
      "cillum",
      "occaecat",
      "culpa"
    ],
    "friends": [
      {
        "id": 0,
        "name": "Bryant Beard"
      },
      {
        "id": 1,
        "name": "Norris Harris"
      },
      {
        "id": 2,
        "name": "Hope Zimmerman"
      }
    ],
    "greeting": "Hello, Effie Vasquez! You have 1 unread messages.",
    "favoriteFruit": "banana"
  },
  {
    "_id": "63982bbbb3ef5a097dad154b",
    "index": 16,
    "guid": "269f3a42-1f45-4c84-835d-d8dd345cf1ce",
    "isActive": false,
    "balance": "$1,207.98",
    "picture": "http://placehold.it/32x32",
    "age": 40,
    "eyeColor": "green",
    "name": "Audra Francis",
    "gender": "female",
    "company": "DRAGBOT",
    "email": "audrafrancis@dragbot.com",
    "phone": "+1 (965) 536-3257",
    "address": "862 Cooper Street, Hatteras, Palau, 3040",
    "about": "Ea nulla nisi est occaecat officia dolor aute sint pariatur ex. Minim irure consequat excepteur irure. In tempor eu quis velit nulla. Labore voluptate ex nostrud ex aliqua minim mollit nulla proident elit.\r\n",
    "registered": "2017-09-19T09:54:13 -02:00",
    "latitude": 81.418622,
    "longitude": 152.000419,
    "tags": [
      "ad",
      "id",
      "tempor",
      "fugiat",
      "ea",
      "commodo",
      "sint"
    ],
    "friends": [
      {
        "id": 0,
        "name": "Valencia Bonner"
      },
      {
        "id": 1,
        "name": "Silvia Mcdaniel"
      },
      {
        "id": 2,
        "name": "Estella Gray"
      }
    ],
    "greeting": "Hello, Audra Francis! You have 6 unread messages.",
    "favoriteFruit": "banana"
  },
  {
    "_id": "63982bbb520942115b97f6d5",
    "index": 17,
    "guid": "7600f4b3-64ce-47fa-9a26-9bfef3921f0d",
    "isActive": true,
    "balance": "$3,304.12",
    "picture": "http://placehold.it/32x32",
    "age": 33,
    "eyeColor": "brown",
    "name": "Lorraine Montgomery",
    "gender": "female",
    "company": "MANTRIX",
    "email": "lorrainemontgomery@mantrix.com",
    "phone": "+1 (832) 423-2242",
    "address": "501 Canarsie Road, Rivereno, Nebraska, 7534",
    "about": "Eiusmod mollit reprehenderit enim non sint sint eu aute commodo in. Enim ad quis adipisicing non dolor ad. Deserunt nulla incididunt sit sit officia magna consectetur cillum velit est ullamco fugiat id. Magna ipsum ex consequat culpa labore consequat et quis. Sit ea commodo non culpa mollit incididunt.\r\n",
    "registered": "2019-11-30T06:16:55 -01:00",
    "latitude": 4.034228,
    "longitude": -27.454824,
    "tags": [
      "eiusmod",
      "ut",
      "in",
      "amet",
      "do",
      "duis",
      "cillum"
    ],
    "friends": [
      {
        "id": 0,
        "name": "Salas Simpson"
      },
      {
        "id": 1,
        "name": "Ruby Andrews"
      },
      {
        "id": 2,
        "name": "April Orr"
      }
    ],
    "greeting": "Hello, Lorraine Montgomery! You have 9 unread messages.",
    "favoriteFruit": "strawberry"
  },
  {
    "_id": "63982bbb9dcc3bf8548762cf",
    "index": 18,
    "guid": "7a47bd9d-54e6-4bc2-a8b8-40cb9b17e9d3",
    "isActive": true,
    "balance": "$3,452.26",
    "picture": "http://placehold.it/32x32",
    "age": 35,
    "eyeColor": "green",
    "name": "Peggy Peters",
    "gender": "female",
    "company": "BIOLIVE",
    "email": "peggypeters@biolive.com",
    "phone": "+1 (895) 589-2624",
    "address": "495 Gatling Place, Bancroft, North Carolina, 4667",
    "about": "Cillum duis consectetur nisi veniam laborum Lorem elit ea velit. Aliquip sit fugiat minim enim anim laboris enim officia fugiat officia. Culpa consequat elit incididunt pariatur in qui duis minim. Aliquip commodo eiusmod velit aliquip Lorem proident nostrud aliquip magna culpa ipsum. Fugiat sit magna tempor eu aliquip aliquip officia ullamco consectetur fugiat occaecat ex eiusmod. Eu duis incididunt dolor incididunt sint elit voluptate irure cillum sint et qui. Nisi nulla Lorem in qui excepteur ad veniam.\r\n",
    "registered": "2015-08-31T08:15:16 -02:00",
    "latitude": -55.953844,
    "longitude": -42.142933,
    "tags": [
      "qui",
      "amet",
      "aliquip",
      "proident",
      "fugiat",
      "exercitation",
      "quis"
    ],
    "friends": [
      {
        "id": 0,
        "name": "Hester Crawford"
      },
      {
        "id": 1,
        "name": "Shields Booth"
      },
      {
        "id": 2,
        "name": "Blair Griffith"
      }
    ],
    "greeting": "Hello, Peggy Peters! You have 8 unread messages.",
    "favoriteFruit": "strawberry"
  },
  {
    "_id": "63982bbbc96ee6fd4cba47a5",
    "index": 19,
    "guid": "97eb8482-98bd-4d92-b5b1-c93ada1f90b3",
    "isActive": false,
    "balance": "$3,906.90",
    "picture": "http://placehold.it/32x32",
    "age": 31,
    "eyeColor": "blue",
    "name": "Pierce Mccray",
    "gender": "male",
    "company": "EVENTEX",
    "email": "piercemccray@eventex.com",
    "phone": "+1 (811) 426-3872",
    "address": "929 Dobbin Street, Caspar, New Jersey, 3148",
    "about": "Veniam enim incididunt magna cillum. Aliquip non est voluptate magna mollit laboris mollit laboris veniam velit esse anim. Sint magna tempor qui aliqua officia ullamco. Id sint nulla magna veniam eiusmod adipisicing esse consequat labore laborum. Id commodo occaecat minim irure magna esse commodo ex. Eiusmod eiusmod mollit id exercitation eu velit deserunt nulla Lorem. Magna excepteur do ut magna id laboris.\r\n",
    "registered": "2015-04-23T02:32:08 -02:00",
    "latitude": 36.448538,
    "longitude": -4.452943,
    "tags": [
      "laborum",
      "aliqua",
      "qui",
      "veniam",
      "exercitation",
      "officia",
      "ullamco"
    ],
    "friends": [
      {
        "id": 0,
        "name": "Jimmie Carroll"
      },
      {
        "id": 1,
        "name": "Imelda Nolan"
      },
      {
        "id": 2,
        "name": "Ellen Calderon"
      }
    ],
    "greeting": "Hello, Pierce Mccray! You have 9 unread messages.",
    "favoriteFruit": "banana"
  },
  {
    "_id": "63982bbbf454330988365f64",
    "index": 20,
    "guid": "5b198a52-3fac-4996-bd56-7836e014b7bc",
    "isActive": false,
    "balance": "$1,510.22",
    "picture": "http://placehold.it/32x32",
    "age": 25,
    "eyeColor": "green",
    "name": "Sims Cotton",
    "gender": "male",
    "company": "PASTURIA",
    "email": "simscotton@pasturia.com",
    "phone": "+1 (979) 477-2743",
    "address": "519 Nova Court, Lloyd, Rhode Island, 1170",
    "about": "Eu adipisicing excepteur qui nulla mollit aliquip ullamco ullamco incididunt occaecat aliquip dolore aliquip. Minim cupidatat veniam aliqua nostrud. Aute est magna dolore sit cupidatat est magna ad anim commodo enim et ea velit.\r\n",
    "registered": "2018-11-08T04:51:46 -01:00",
    "latitude": 63.451059,
    "longitude": 99.636022,
    "tags": [
      "proident",
      "laborum",
      "aliquip",
      "labore",
      "sit",
      "consectetur",
      "voluptate"
    ],
    "friends": [
      {
        "id": 0,
        "name": "Fowler Hopper"
      },
      {
        "id": 1,
        "name": "Barrett Benjamin"
      },
      {
        "id": 2,
        "name": "Marietta Bond"
      }
    ],
    "greeting": "Hello, Sims Cotton! You have 8 unread messages.",
    "favoriteFruit": "strawberry"
  },
  {
    "_id": "63982bbbeaf620f2f252f5b9",
    "index": 21,
    "guid": "19208dad-11c7-41c1-b97f-5a7df24a1121",
    "isActive": false,
    "balance": "$3,871.72",
    "picture": "http://placehold.it/32x32",
    "age": 26,
    "eyeColor": "green",
    "name": "Higgins Hickman",
    "gender": "male",
    "company": "IDETICA",
    "email": "higginshickman@idetica.com",
    "phone": "+1 (959) 526-2849",
    "address": "626 Greenpoint Avenue, Fairforest, Michigan, 2480",
    "about": "Fugiat proident dolor dolore qui sit. Quis officia ullamco anim in Lorem non incididunt velit fugiat veniam culpa occaecat. Voluptate duis tempor occaecat eiusmod pariatur Lorem culpa quis enim dolore ullamco non. Culpa fugiat consectetur consequat id officia magna et laborum in esse et culpa ut tempor. Lorem adipisicing esse voluptate exercitation. Minim irure id pariatur eu laboris ullamco sit fugiat amet ipsum enim in. Nulla pariatur fugiat pariatur deserunt cillum eu cupidatat ullamco aliqua qui qui qui.\r\n",
    "registered": "2017-08-23T03:09:09 -02:00",
    "latitude": -87.732126,
    "longitude": -49.738661,
    "tags": [
      "voluptate",
      "anim",
      "nulla",
      "nostrud",
      "nostrud",
      "et",
      "irure"
    ],
    "friends": [
      {
        "id": 0,
        "name": "Bridgette Tate"
      },
      {
        "id": 1,
        "name": "Becker Hunt"
      },
      {
        "id": 2,
        "name": "Jeanie Solomon"
      }
    ],
    "greeting": "Hello, Higgins Hickman! You have 9 unread messages.",
    "favoriteFruit": "strawberry"
  },
  {
    "_id": "63982bbbc4d3411529c8c019",
    "index": 22,
    "guid": "ede82353-7079-4797-9409-05cd99d7cceb",
    "isActive": true,
    "balance": "$2,033.75",
    "picture": "http://placehold.it/32x32",
    "age": 21,
    "eyeColor": "green",
    "name": "Jacobs Shields",
    "gender": "male",
    "company": "SECURIA",
    "email": "jacobsshields@securia.com",
    "phone": "+1 (838) 482-3491",
    "address": "524 Prince Street, Salix, Colorado, 293",
    "about": "Occaecat Lorem incididunt duis voluptate officia ad eiusmod est. Laborum consequat nulla cillum voluptate nulla do. Enim consequat veniam duis labore. Est sunt voluptate mollit non consequat laboris sint consectetur pariatur. Consequat ipsum eiusmod magna do ut excepteur non velit excepteur culpa magna reprehenderit sit proident.\r\n",
    "registered": "2018-03-28T04:22:49 -02:00",
    "latitude": -42.962424,
    "longitude": 23.688183,
    "tags": [
      "exercitation",
      "reprehenderit",
      "proident",
      "consectetur",
      "deserunt",
      "amet",
      "eiusmod"
    ],
    "friends": [
      {
        "id": 0,
        "name": "Solis Dean"
      },
      {
        "id": 1,
        "name": "Montoya Schultz"
      },
      {
        "id": 2,
        "name": "Kathryn Clark"
      }
    ],
    "greeting": "Hello, Jacobs Shields! You have 8 unread messages.",
    "favoriteFruit": "strawberry"
  },
  {
    "_id": "63982bbbce1e3a8c657c0d5c",
    "index": 23,
    "guid": "ccd3614d-5bfb-4dce-9b67-62871f3ca937",
    "isActive": true,
    "balance": "$1,720.03",
    "picture": "http://placehold.it/32x32",
    "age": 40,
    "eyeColor": "green",
    "name": "Collier Weeks",
    "gender": "male",
    "company": "EMTRAC",
    "email": "collierweeks@emtrac.com",
    "phone": "+1 (938) 468-3126",
    "address": "109 Friel Place, Turah, Federated States Of Micronesia, 7732",
    "about": "Adipisicing pariatur labore Lorem culpa dolor veniam. Mollit et adipisicing commodo ullamco. Nisi veniam anim officia adipisicing reprehenderit veniam ipsum. In laboris esse ut voluptate sint veniam anim ad adipisicing labore irure sit consequat. Fugiat incididunt officia voluptate elit cupidatat fugiat commodo sunt consectetur.\r\n",
    "registered": "2017-09-26T12:48:33 -02:00",
    "latitude": -75.12708,
    "longitude": 76.408015,
    "tags": [
      "sit",
      "voluptate",
      "eiusmod",
      "mollit",
      "aliqua",
      "ipsum",
      "nulla"
    ],
    "friends": [
      {
        "id": 0,
        "name": "Suzanne Bell"
      },
      {
        "id": 1,
        "name": "Briana Chang"
      },
      {
        "id": 2,
        "name": "Russell Watkins"
      }
    ],
    "greeting": "Hello, Collier Weeks! You have 2 unread messages.",
    "favoriteFruit": "strawberry"
  },
  {
    "_id": "63982bbb8e4252c4027df0c4",
    "index": 24,
    "guid": "6d3087b4-d86d-4165-9323-c1308598103c",
    "isActive": false,
    "balance": "$2,713.10",
    "picture": "http://placehold.it/32x32",
    "age": 21,
    "eyeColor": "green",
    "name": "Huber Stephenson",
    "gender": "male",
    "company": "VINCH",
    "email": "huberstephenson@vinch.com",
    "phone": "+1 (904) 460-3098",
    "address": "122 Lorraine Street, Craig, Marshall Islands, 7773",
    "about": "Id consectetur incididunt commodo ut dolor aliquip nisi laborum reprehenderit tempor reprehenderit minim. Sit quis Lorem duis adipisicing veniam ea ad irure mollit excepteur mollit id aliqua non. Ex ullamco id consectetur ullamco pariatur eu pariatur enim ullamco tempor anim cupidatat sunt. Nostrud enim voluptate cillum aliquip esse ad deserunt do consequat occaecat voluptate.\r\n",
    "registered": "2020-12-01T07:30:47 -01:00",
    "latitude": -37.471696,
    "longitude": -102.18016,
    "tags": [
      "esse",
      "excepteur",
      "enim",
      "magna",
      "anim",
      "ad",
      "nostrud"
    ],
    "friends": [
      {
        "id": 0,
        "name": "Merle Potts"
      },
      {
        "id": 1,
        "name": "Calhoun Mcgee"
      },
      {
        "id": 2,
        "name": "Paul Burgess"
      }
    ],
    "greeting": "Hello, Huber Stephenson! You have 4 unread messages.",
    "favoriteFruit": "banana"
  },
  {
    "_id": "63982bbb64cc8d07b40e24e7",
    "index": 25,
    "guid": "1ddccb73-be6a-4b2e-8cf8-a2ac86bf5615",
    "isActive": true,
    "balance": "$2,628.53",
    "picture": "http://placehold.it/32x32",
    "age": 25,
    "eyeColor": "brown",
    "name": "Moody Hanson",
    "gender": "male",
    "company": "INTERODEO",
    "email": "moodyhanson@interodeo.com",
    "phone": "+1 (904) 590-2356",
    "address": "787 Kermit Place, Wyano, Alabama, 6939",
    "about": "Ut laborum laboris nulla minim commodo aliqua dolor magna et commodo commodo laborum pariatur nostrud. Ex proident sunt elit quis dolor id quis aliqua sit. Occaecat aliqua laborum ut laboris ipsum exercitation do nisi laboris nulla ex. Duis enim officia et ex labore Lorem irure elit do. Incididunt dolore amet aute dolor sit aute ea laboris nostrud mollit est nisi irure. Consequat magna amet reprehenderit exercitation elit Lorem aliquip consectetur occaecat. Sit nostrud pariatur nostrud voluptate magna veniam ut cillum incididunt enim ipsum esse tempor fugiat.\r\n",
    "registered": "2015-09-17T09:51:49 -02:00",
    "latitude": 74.768436,
    "longitude": 103.50778,
    "tags": [
      "irure",
      "exercitation",
      "velit",
      "ex",
      "non",
      "voluptate",
      "laborum"
    ],
    "friends": [
      {
        "id": 0,
        "name": "Tyler Guerrero"
      },
      {
        "id": 1,
        "name": "Mollie Doyle"
      },
      {
        "id": 2,
        "name": "Lester Stein"
      }
    ],
    "greeting": "Hello, Moody Hanson! You have 9 unread messages.",
    "favoriteFruit": "apple"
  },
  {
    "_id": "63982bbbfc578ca80559c67f",
    "index": 26,
    "guid": "0e80a627-8244-4430-90c0-701b6c4b8b91",
    "isActive": false,
    "balance": "$3,555.88",
    "picture": "http://placehold.it/32x32",
    "age": 31,
    "eyeColor": "blue",
    "name": "Francis Greene",
    "gender": "male",
    "company": "MINGA",
    "email": "francisgreene@minga.com",
    "phone": "+1 (836) 488-3047",
    "address": "966 Blake Court, Sultana, Tennessee, 435",
    "about": "Sit proident eu irure anim fugiat cupidatat proident voluptate labore nostrud fugiat quis incididunt cillum. Ipsum enim consequat quis mollit amet velit sit aliqua. Veniam enim excepteur Lorem pariatur est officia ut in aliqua commodo deserunt cupidatat. Sunt irure dolor enim occaecat dolor voluptate voluptate nostrud ex mollit nisi proident. Adipisicing nostrud amet consectetur ipsum duis sunt mollit laborum irure consequat in ea qui veniam. Proident aute ut tempor ut ullamco.\r\n",
    "registered": "2014-01-17T03:09:45 -01:00",
    "latitude": 68.718883,
    "longitude": -149.292358,
    "tags": [
      "adipisicing",
      "amet",
      "eiusmod",
      "veniam",
      "fugiat",
      "cupidatat",
      "nostrud"
    ],
    "friends": [
      {
        "id": 0,
        "name": "Clark Rosario"
      },
      {
        "id": 1,
        "name": "Mckay King"
      },
      {
        "id": 2,
        "name": "Holcomb Riley"
      }
    ],
    "greeting": "Hello, Francis Greene! You have 1 unread messages.",
    "favoriteFruit": "apple"
  },
  {
    "_id": "63982bbbcf74546977bf0fd0",
    "index": 27,
    "guid": "b5e7514d-e235-43a0-8a90-20c80158369e",
    "isActive": false,
    "balance": "$1,707.72",
    "picture": "http://placehold.it/32x32",
    "age": 40,
    "eyeColor": "blue",
    "name": "Courtney Horn",
    "gender": "female",
    "company": "TINGLES",
    "email": "courtneyhorn@tingles.com",
    "phone": "+1 (866) 414-3334",
    "address": "838 Juliana Place, Chloride, American Samoa, 7595",
    "about": "Lorem eiusmod officia enim cupidatat commodo aute. Cupidatat magna occaecat proident nulla incididunt laboris id duis in velit dolore laboris. Incididunt anim mollit proident ipsum tempor est ipsum pariatur occaecat ex. Velit veniam laborum pariatur quis quis proident. Aute aliqua est cillum id ex non elit. Elit officia tempor anim proident proident eu veniam.\r\n",
    "registered": "2017-01-29T04:46:23 -01:00",
    "latitude": -53.44384,
    "longitude": -163.096359,
    "tags": [
      "fugiat",
      "et",
      "mollit",
      "non",
      "ea",
      "et",
      "exercitation"
    ],
    "friends": [
      {
        "id": 0,
        "name": "Sheppard Barry"
      },
      {
        "id": 1,
        "name": "Wolfe Clay"
      },
      {
        "id": 2,
        "name": "Bernard Donaldson"
      }
    ],
    "greeting": "Hello, Courtney Horn! You have 9 unread messages.",
    "favoriteFruit": "banana"
  },
  {
    "_id": "63982bbb5b10d3e628b91829",
    "index": 28,
    "guid": "877e6328-05ce-4b40-87a1-863f03a3c08e",
    "isActive": false,
    "balance": "$1,872.73",
    "picture": "http://placehold.it/32x32",
    "age": 29,
    "eyeColor": "green",
    "name": "Millie Garrett",
    "gender": "female",
    "company": "QNEKT",
    "email": "milliegarrett@qnekt.com",
    "phone": "+1 (911) 500-2695",
    "address": "866 Gaylord Drive, Odessa, Utah, 4665",
    "about": "Enim tempor nostrud nostrud cillum labore proident tempor. Tempor quis duis ad occaecat id laboris enim excepteur aliquip nostrud proident sunt cupidatat reprehenderit. Veniam cupidatat sunt incididunt velit irure sunt in pariatur qui. Cupidatat occaecat sint esse voluptate aute nostrud laborum et. Laborum exercitation nulla consequat nisi quis aliquip laboris. Reprehenderit ullamco ad irure in.\r\n",
    "registered": "2019-09-20T08:32:58 -02:00",
    "latitude": -84.692507,
    "longitude": 121.323285,
    "tags": [
      "duis",
      "cupidatat",
      "velit",
      "labore",
      "pariatur",
      "irure",
      "eiusmod"
    ],
    "friends": [
      {
        "id": 0,
        "name": "Katrina Christensen"
      },
      {
        "id": 1,
        "name": "Colon Payne"
      },
      {
        "id": 2,
        "name": "Wilma Hatfield"
      }
    ],
    "greeting": "Hello, Millie Garrett! You have 9 unread messages.",
    "favoriteFruit": "strawberry"
  },
  {
    "_id": "63982bbbf28fb6a7ca8db328",
    "index": 29,
    "guid": "3bdab7cb-2090-4da9-ab22-d540af95b909",
    "isActive": false,
    "balance": "$2,899.86",
    "picture": "http://placehold.it/32x32",
    "age": 23,
    "eyeColor": "blue",
    "name": "Marcella Conner",
    "gender": "female",
    "company": "QUANTASIS",
    "email": "marcellaconner@quantasis.com",
    "phone": "+1 (901) 446-3919",
    "address": "165 Lloyd Street, Rodanthe, Louisiana, 5729",
    "about": "Amet est aute laboris irure ut sit reprehenderit ea dolore voluptate. Cupidatat nulla nulla sit laborum elit sint velit sint aute et. Labore consectetur elit amet velit aliqua culpa consequat nostrud nulla ipsum. Consequat deserunt nulla minim deserunt ex aute. Duis sit esse voluptate consequat consectetur voluptate ipsum nisi pariatur commodo esse laboris sint. Laboris aliquip ipsum quis exercitation dolore. Voluptate quis anim deserunt velit laboris.\r\n",
    "registered": "2017-01-27T09:03:19 -01:00",
    "latitude": 85.369697,
    "longitude": -98.005533,
    "tags": [
      "cillum",
      "non",
      "voluptate",
      "quis",
      "ex",
      "sint",
      "esse"
    ],
    "friends": [
      {
        "id": 0,
        "name": "Olsen Williamson"
      },
      {
        "id": 1,
        "name": "Banks Adams"
      },
      {
        "id": 2,
        "name": "Tasha Sharp"
      }
    ],
    "greeting": "Hello, Marcella Conner! You have 4 unread messages.",
    "favoriteFruit": "apple"
  },
  {
    "_id": "63982bbb8d4d511f77eab080",
    "index": 30,
    "guid": "188b70d7-a68e-48ec-bae0-7411540f6aea",
    "isActive": true,
    "balance": "$3,609.76",
    "picture": "http://placehold.it/32x32",
    "age": 28,
    "eyeColor": "green",
    "name": "Marylou Mckinney",
    "gender": "female",
    "company": "TASMANIA",
    "email": "maryloumckinney@tasmania.com",
    "phone": "+1 (864) 596-2566",
    "address": "310 Homecrest Avenue, Brogan, Washington, 5058",
    "about": "Amet reprehenderit sint laboris cillum sunt dolor veniam. Qui incididunt Lorem velit eiusmod voluptate Lorem. Adipisicing eiusmod qui laboris id. Eiusmod dolore consequat eiusmod ex. Reprehenderit ex sint ut incididunt.\r\n",
    "registered": "2016-04-22T07:55:52 -02:00",
    "latitude": 51.211632,
    "longitude": 70.827193,
    "tags": [
      "ullamco",
      "esse",
      "commodo",
      "dolore",
      "ad",
      "tempor",
      "qui"
    ],
    "friends": [
      {
        "id": 0,
        "name": "Allison Beck"
      },
      {
        "id": 1,
        "name": "James Fry"
      },
      {
        "id": 2,
        "name": "Boone Allen"
      }
    ],
    "greeting": "Hello, Marylou Mckinney! You have 4 unread messages.",
    "favoriteFruit": "apple"
  },
  {
    "_id": "63982bbbb2257721f4b89bbb",
    "index": 31,
    "guid": "55db166e-1e7f-44cc-8da8-849a30fcaba6",
    "isActive": false,
    "balance": "$2,972.15",
    "picture": "http://placehold.it/32x32",
    "age": 22,
    "eyeColor": "brown",
    "name": "Shelton Cochran",
    "gender": "male",
    "company": "KINDALOO",
    "email": "sheltoncochran@kindaloo.com",
    "phone": "+1 (952) 477-3247",
    "address": "795 Irving Street, Dola, Alaska, 7507",
    "about": "Cupidatat excepteur ea veniam adipisicing labore eu mollit irure non cillum. Ut adipisicing ut ut minim enim minim ea fugiat. Duis officia cupidatat Lorem officia eiusmod mollit tempor anim mollit aute adipisicing. Nisi minim laboris reprehenderit minim occaecat aliquip sunt Lorem quis exercitation duis.\r\n",
    "registered": "2019-01-27T02:03:03 -01:00",
    "latitude": 22.344867,
    "longitude": 118.41184,
    "tags": [
      "aute",
      "voluptate",
      "exercitation",
      "deserunt",
      "proident",
      "magna",
      "ut"
    ],
    "friends": [
      {
        "id": 0,
        "name": "Deann Church"
      },
      {
        "id": 1,
        "name": "Bennett Rowe"
      },
      {
        "id": 2,
        "name": "Heather Mckee"
      }
    ],
    "greeting": "Hello, Shelton Cochran! You have 3 unread messages.",
    "favoriteFruit": "apple"
  },
  {
    "_id": "63982bbb9d816bc4c646a41e",
    "index": 32,
    "guid": "5cead8ee-a509-4021-9d39-22780f7bbb44",
    "isActive": true,
    "balance": "$3,969.70",
    "picture": "http://placehold.it/32x32",
    "age": 20,
    "eyeColor": "blue",
    "name": "Sonya Justice",
    "gender": "female",
    "company": "FURNIGEER",
    "email": "sonyajustice@furnigeer.com",
    "phone": "+1 (869) 425-3571",
    "address": "851 Krier Place, Advance, Maryland, 6740",
    "about": "Sint adipisicing officia consequat aliqua velit. Duis qui nostrud duis excepteur cupidatat. Officia elit in ullamco id proident.\r\n",
    "registered": "2015-10-30T11:49:04 -01:00",
    "latitude": -60.327778,
    "longitude": -78.285943,
    "tags": [
      "id",
      "adipisicing",
      "cupidatat",
      "elit",
      "excepteur",
      "mollit",
      "mollit"
    ],
    "friends": [
      {
        "id": 0,
        "name": "Corina Richardson"
      },
      {
        "id": 1,
        "name": "Bertie Ashley"
      },
      {
        "id": 2,
        "name": "Boyle Johns"
      }
    ],
    "greeting": "Hello, Sonya Justice! You have 4 unread messages.",
    "favoriteFruit": "strawberry"
  },
  {
    "_id": "63982bbb8d2ccc395f036cb6",
    "index": 33,
    "guid": "a56614bd-0ee2-4196-860e-8cd0b6f88605",
    "isActive": false,
    "balance": "$3,632.97",
    "picture": "http://placehold.it/32x32",
    "age": 40,
    "eyeColor": "blue",
    "name": "Burke Wheeler",
    "gender": "male",
    "company": "EMOLTRA",
    "email": "burkewheeler@emoltra.com",
    "phone": "+1 (910) 579-2475",
    "address": "520 Vermont Court, Juntura, Montana, 7816",
    "about": "Laboris do ipsum ad qui minim. Ullamco sunt magna do occaecat dolor qui duis dolore dolor consequat tempor nostrud. Eu culpa voluptate esse sunt eu culpa. Dolor reprehenderit proident ipsum esse sit tempor exercitation. Veniam ipsum excepteur pariatur mollit Lorem ad in.\r\n",
    "registered": "2015-03-04T12:46:21 -01:00",
    "latitude": 69.860157,
    "longitude": -168.320256,
    "tags": [
      "do",
      "eiusmod",
      "Lorem",
      "esse",
      "laborum",
      "sint",
      "ullamco"
    ],
    "friends": [
      {
        "id": 0,
        "name": "Gray Boyd"
      },
      {
        "id": 1,
        "name": "Hawkins Schmidt"
      },
      {
        "id": 2,
        "name": "Gwen Barr"
      }
    ],
    "greeting": "Hello, Burke Wheeler! You have 1 unread messages.",
    "favoriteFruit": "banana"
  },
  {
    "_id": "63982bbb0c404e009fe15a04",
    "index": 34,
    "guid": "a874512a-118a-4116-afc5-81cfe3001f4b",
    "isActive": false,
    "balance": "$2,937.95",
    "picture": "http://placehold.it/32x32",
    "age": 34,
    "eyeColor": "green",
    "name": "Johanna Mcconnell",
    "gender": "female",
    "company": "COMBOGEN",
    "email": "johannamcconnell@combogen.com",
    "phone": "+1 (801) 476-3319",
    "address": "324 Cropsey Avenue, Bourg, Arizona, 9887",
    "about": "Dolore irure Lorem aliqua in voluptate enim duis ex elit velit mollit cillum veniam occaecat. Ex esse nisi Lorem cupidatat laborum aliqua laborum excepteur esse laborum non. Aliqua consequat reprehenderit proident ut magna id deserunt. Non ad aliquip ut nisi dolore cillum tempor sint duis est. Ut fugiat dolore amet id fugiat excepteur.\r\n",
    "registered": "2017-07-27T11:35:05 -02:00",
    "latitude": -40.910205,
    "longitude": -126.850462,
    "tags": [
      "in",
      "aliqua",
      "non",
      "do",
      "elit",
      "pariatur",
      "sint"
    ],
    "friends": [
      {
        "id": 0,
        "name": "Emerson Frank"
      },
      {
        "id": 1,
        "name": "Douglas Hewitt"
      },
      {
        "id": 2,
        "name": "Schneider Gilmore"
      }
    ],
    "greeting": "Hello, Johanna Mcconnell! You have 4 unread messages.",
    "favoriteFruit": "strawberry"
  },
  {
    "_id": "63982bbbe2cebb17ca1eba97",
    "index": 35,
    "guid": "0ea62817-0b08-4c95-99de-8aaa9aceb937",
    "isActive": true,
    "balance": "$3,090.43",
    "picture": "http://placehold.it/32x32",
    "age": 23,
    "eyeColor": "green",
    "name": "Selena Winters",
    "gender": "female",
    "company": "MANTRO",
    "email": "selenawinters@mantro.com",
    "phone": "+1 (949) 443-2656",
    "address": "881 Harrison Place, Whitestone, District Of Columbia, 1932",
    "about": "Eu anim ad deserunt incididunt excepteur enim. In non ad mollit aliqua exercitation duis adipisicing cupidatat nostrud id. Duis cillum incididunt adipisicing do eu dolor ea aliquip deserunt tempor excepteur occaecat consectetur. Ullamco veniam ipsum non sit cupidatat proident nostrud veniam. Consectetur consectetur sint occaecat nulla Lorem esse pariatur.\r\n",
    "registered": "2021-03-22T06:16:00 -01:00",
    "latitude": 50.584526,
    "longitude": 59.53996,
    "tags": [
      "amet",
      "ea",
      "incididunt",
      "do",
      "voluptate",
      "ex",
      "velit"
    ],
    "friends": [
      {
        "id": 0,
        "name": "Curry Burns"
      },
      {
        "id": 1,
        "name": "Lacey Ramsey"
      },
      {
        "id": 2,
        "name": "Angelia Fitzpatrick"
      }
    ],
    "greeting": "Hello, Selena Winters! You have 10 unread messages.",
    "favoriteFruit": "strawberry"
  },
  {
    "_id": "63982bbb034bcb97eb4aada2",
    "index": 36,
    "guid": "2fe7cc16-ad8a-459e-b5b6-49492f9f4ce9",
    "isActive": false,
    "balance": "$2,505.35",
    "picture": "http://placehold.it/32x32",
    "age": 32,
    "eyeColor": "brown",
    "name": "Bradford Summers",
    "gender": "male",
    "company": "INTRAWEAR",
    "email": "bradfordsummers@intrawear.com",
    "phone": "+1 (894) 526-2585",
    "address": "569 Oxford Street, Mappsville, Oregon, 6953",
    "about": "Ipsum enim aute officia eu incididunt reprehenderit et voluptate occaecat Lorem fugiat esse labore. Pariatur enim do occaecat amet dolore ad reprehenderit Lorem laborum pariatur ullamco sunt in. Velit deserunt nisi incididunt aute nostrud ipsum aliquip elit duis eiusmod. Minim qui velit culpa non veniam. Minim ad do labore esse duis reprehenderit cillum nostrud ex in sint.\r\n",
    "registered": "2015-12-20T04:55:24 -01:00",
    "latitude": -10.390758,
    "longitude": -179.700483,
    "tags": [
      "eiusmod",
      "nostrud",
      "sunt",
      "cupidatat",
      "ullamco",
      "cupidatat",
      "exercitation"
    ],
    "friends": [
      {
        "id": 0,
        "name": "Merritt Drake"
      },
      {
        "id": 1,
        "name": "Kelley Patrick"
      },
      {
        "id": 2,
        "name": "Hopper Garza"
      }
    ],
    "greeting": "Hello, Bradford Summers! You have 10 unread messages.",
    "favoriteFruit": "apple"
  },
  {
    "_id": "63982bbb5e86ad453305d689",
    "index": 37,
    "guid": "7484b6ef-958b-4311-8a4e-b35008b3c15c",
    "isActive": true,
    "balance": "$2,133.24",
    "picture": "http://placehold.it/32x32",
    "age": 29,
    "eyeColor": "brown",
    "name": "Valentine Jacobs",
    "gender": "male",
    "company": "EARGO",
    "email": "valentinejacobs@eargo.com",
    "phone": "+1 (883) 574-2041",
    "address": "818 Tillary Street, Martinez, Indiana, 7893",
    "about": "Fugiat proident sint irure veniam nostrud esse duis cupidatat cupidatat non. Proident cillum ullamco velit elit eiusmod qui sit excepteur sunt magna ullamco nostrud. Minim enim reprehenderit nostrud laborum.\r\n",
    "registered": "2022-08-31T07:57:19 -02:00",
    "latitude": 42.440225,
    "longitude": -99.730521,
    "tags": [
      "consequat",
      "fugiat",
      "amet",
      "fugiat",
      "deserunt",
      "consequat",
      "adipisicing"
    ],
    "friends": [
      {
        "id": 0,
        "name": "Janelle Robles"
      },
      {
        "id": 1,
        "name": "Claire Spears"
      },
      {
        "id": 2,
        "name": "Clare Huber"
      }
    ],
    "greeting": "Hello, Valentine Jacobs! You have 7 unread messages.",
    "favoriteFruit": "apple"
  },
  {
    "_id": "63982bbbf5e3eec8ce5850e6",
    "index": 38,
    "guid": "c62f7435-084b-4523-8f5e-a6984e2968f0",
    "isActive": true,
    "balance": "$1,715.52",
    "picture": "http://placehold.it/32x32",
    "age": 26,
    "eyeColor": "blue",
    "name": "Shawna Berry",
    "gender": "female",
    "company": "CINCYR",
    "email": "shawnaberry@cincyr.com",
    "phone": "+1 (975) 410-3356",
    "address": "452 Lyme Avenue, Edgewater, New Hampshire, 5784",
    "about": "Ex ut ex commodo ipsum duis consectetur dolore dolore adipisicing cupidatat laborum. Minim tempor occaecat mollit magna sit ea aliqua qui do officia aute incididunt et voluptate. Laboris velit dolor exercitation aliqua ut dolor in et.\r\n",
    "registered": "2019-08-14T09:21:54 -02:00",
    "latitude": 55.42195,
    "longitude": 68.966927,
    "tags": [
      "cillum",
      "aute",
      "do",
      "veniam",
      "aliqua",
      "ad",
      "non"
    ],
    "friends": [
      {
        "id": 0,
        "name": "Reed Sanders"
      },
      {
        "id": 1,
        "name": "Mayra Cummings"
      },
      {
        "id": 2,
        "name": "Baldwin Robinson"
      }
    ],
    "greeting": "Hello, Shawna Berry! You have 4 unread messages.",
    "favoriteFruit": "strawberry"
  },
  {
    "_id": "63982bbbc2af44bb74d25066",
    "index": 39,
    "guid": "6837e3fb-89fd-44be-bf11-1d625f3d7808",
    "isActive": true,
    "balance": "$2,172.26",
    "picture": "http://placehold.it/32x32",
    "age": 36,
    "eyeColor": "brown",
    "name": "Lesley Levy",
    "gender": "female",
    "company": "UPLINX",
    "email": "lesleylevy@uplinx.com",
    "phone": "+1 (924) 591-2834",
    "address": "785 Middleton Street, Cetronia, Wyoming, 4495",
    "about": "Ad incididunt adipisicing sunt pariatur ullamco sunt amet magna reprehenderit nulla esse. In est laboris duis reprehenderit fugiat mollit officia in exercitation. Cupidatat proident enim est irure esse sunt officia reprehenderit ea ea et. Lorem est irure dolore anim officia aute occaecat excepteur ex tempor eu aliquip. Ut consequat sunt duis incididunt.\r\n",
    "registered": "2021-09-14T10:56:00 -02:00",
    "latitude": 63.270833,
    "longitude": 46.504682,
    "tags": [
      "minim",
      "sint",
      "elit",
      "aliqua",
      "elit",
      "mollit",
      "minim"
    ],
    "friends": [
      {
        "id": 0,
        "name": "Mary Henry"
      },
      {
        "id": 1,
        "name": "York Ware"
      },
      {
        "id": 2,
        "name": "Howe Shaffer"
      }
    ],
    "greeting": "Hello, Lesley Levy! You have 3 unread messages.",
    "favoriteFruit": "strawberry"
  },
  {
    "_id": "63982bbbbc48a831d014a269",
    "index": 40,
    "guid": "d6a6d24f-a8a0-4722-8f76-fe579e9bee97",
    "isActive": true,
    "balance": "$2,944.72",
    "picture": "http://placehold.it/32x32",
    "age": 24,
    "eyeColor": "brown",
    "name": "Copeland Petersen",
    "gender": "male",
    "company": "ENQUILITY",
    "email": "copelandpetersen@enquility.com",
    "phone": "+1 (981) 564-3199",
    "address": "764 Ide Court, Wilmington, North Dakota, 5807",
    "about": "Exercitation voluptate fugiat qui qui ullamco elit. Velit consectetur sint eu id non nisi. Voluptate nostrud dolore cupidatat exercitation laborum dolore pariatur sunt amet officia consectetur aliquip. Do sunt duis exercitation laborum esse pariatur. Aliquip qui eiusmod elit ut aliqua exercitation fugiat aliquip fugiat eiusmod duis eiusmod.\r\n",
    "registered": "2015-03-02T05:51:27 -01:00",
    "latitude": -38.472508,
    "longitude": 18.120785,
    "tags": [
      "ut",
      "sint",
      "consectetur",
      "ipsum",
      "ullamco",
      "voluptate",
      "duis"
    ],
    "friends": [
      {
        "id": 0,
        "name": "Trevino Goodwin"
      },
      {
        "id": 1,
        "name": "Hilda Gould"
      },
      {
        "id": 2,
        "name": "Lindsey Gibbs"
      }
    ],
    "greeting": "Hello, Copeland Petersen! You have 2 unread messages.",
    "favoriteFruit": "banana"
  },
  {
    "_id": "63982bbb667b6ff14e8cbef8",
    "index": 41,
    "guid": "8a4e57e6-9b4f-4831-8d6e-93fd9f23f3ce",
    "isActive": true,
    "balance": "$3,653.16",
    "picture": "http://placehold.it/32x32",
    "age": 34,
    "eyeColor": "green",
    "name": "Pugh Collins",
    "gender": "male",
    "company": "PREMIANT",
    "email": "pughcollins@premiant.com",
    "phone": "+1 (952) 501-2630",
    "address": "274 Beaumont Street, Madrid, Oklahoma, 1556",
    "about": "Aute labore nostrud sunt nostrud ut commodo consequat do amet dolor amet. Nostrud sint consectetur tempor velit ex. Enim et qui est magna ex. Eiusmod voluptate ad voluptate ipsum voluptate culpa fugiat. Magna nostrud duis nostrud officia dolore id do amet officia amet mollit.\r\n",
    "registered": "2019-11-12T01:27:34 -01:00",
    "latitude": -6.408152,
    "longitude": 13.515945,
    "tags": [
      "cupidatat",
      "nisi",
      "ipsum",
      "officia",
      "cillum",
      "esse",
      "deserunt"
    ],
    "friends": [
      {
        "id": 0,
        "name": "Patsy Sawyer"
      },
      {
        "id": 1,
        "name": "David Witt"
      },
      {
        "id": 2,
        "name": "Wilson Ramirez"
      }
    ],
    "greeting": "Hello, Pugh Collins! You have 6 unread messages.",
    "favoriteFruit": "banana"
  },
  {
    "_id": "63982bbbac3b39f32338d544",
    "index": 42,
    "guid": "b859c092-94ae-4424-b039-ac8cd7e353d7",
    "isActive": false,
    "balance": "$1,982.28",
    "picture": "http://placehold.it/32x32",
    "age": 32,
    "eyeColor": "green",
    "name": "Alma Schneider",
    "gender": "female",
    "company": "ZOMBOID",
    "email": "almaschneider@zomboid.com",
    "phone": "+1 (910) 487-2478",
    "address": "155 Woodruff Avenue, Greenwich, Texas, 3825",
    "about": "Est elit aute in magna dolor velit cillum. Aliquip enim Lorem ipsum pariatur et exercitation. Tempor in irure occaecat ullamco dolore nostrud. Mollit laboris consectetur pariatur est magna amet ipsum exercitation.\r\n",
    "registered": "2019-02-06T06:45:03 -01:00",
    "latitude": -18.047115,
    "longitude": -45.389687,
    "tags": [
      "irure",
      "anim",
      "sunt",
      "sit",
      "nisi",
      "elit",
      "ad"
    ],
    "friends": [
      {
        "id": 0,
        "name": "Barlow Santana"
      },
      {
        "id": 1,
        "name": "Flora Pena"
      },
      {
        "id": 2,
        "name": "Booth Emerson"
      }
    ],
    "greeting": "Hello, Alma Schneider! You have 7 unread messages.",
    "favoriteFruit": "banana"
  },
  {
    "_id": "63982bbb7030e6c102927b2d",
    "index": 43,
    "guid": "1f099374-f619-4564-8223-b8588402c51b",
    "isActive": true,
    "balance": "$1,395.84",
    "picture": "http://placehold.it/32x32",
    "age": 27,
    "eyeColor": "brown",
    "name": "Whitney Walls",
    "gender": "male",
    "company": "MAINELAND",
    "email": "whitneywalls@maineland.com",
    "phone": "+1 (988) 569-3402",
    "address": "307 Whitney Avenue, Dragoon, South Carolina, 7009",
    "about": "Qui nisi exercitation nulla dolor pariatur aliquip enim deserunt est mollit mollit deserunt. Laborum culpa esse ipsum enim irure in id. Nostrud esse consectetur eu cupidatat do exercitation. Mollit ad sint nisi enim sit culpa excepteur nisi.\r\n",
    "registered": "2021-02-13T11:49:37 -01:00",
    "latitude": 47.187302,
    "longitude": 42.726542,
    "tags": [
      "cillum",
      "laborum",
      "ea",
      "aute",
      "proident",
      "enim",
      "magna"
    ],
    "friends": [
      {
        "id": 0,
        "name": "Harding Dotson"
      },
      {
        "id": 1,
        "name": "Jennifer Price"
      },
      {
        "id": 2,
        "name": "Holly Carr"
      }
    ],
    "greeting": "Hello, Whitney Walls! You have 8 unread messages.",
    "favoriteFruit": "banana"
  },
  {
    "_id": "63982bbbd52d3307f6b5932a",
    "index": 44,
    "guid": "6fe90ead-bc2c-41fb-b8b8-5474f5cc8542",
    "isActive": false,
    "balance": "$1,627.20",
    "picture": "http://placehold.it/32x32",
    "age": 40,
    "eyeColor": "brown",
    "name": "Atkins Mcintyre",
    "gender": "male",
    "company": "ENVIRE",
    "email": "atkinsmcintyre@envire.com",
    "phone": "+1 (863) 547-3599",
    "address": "541 Rewe Street, Ahwahnee, Pennsylvania, 9083",
    "about": "Id ex laborum amet sunt officia Lorem velit esse. Voluptate ad commodo dolor in eiusmod qui ipsum eu esse dolor dolore dolor. Nostrud est culpa commodo enim officia ut anim ea incididunt qui tempor nisi Lorem. Ex aliqua occaecat non aute.\r\n",
    "registered": "2014-05-26T04:08:20 -02:00",
    "latitude": -30.12721,
    "longitude": 135.041274,
    "tags": [
      "proident",
      "Lorem",
      "voluptate",
      "ea",
      "est",
      "minim",
      "sunt"
    ],
    "friends": [
      {
        "id": 0,
        "name": "Ferguson Hayden"
      },
      {
        "id": 1,
        "name": "Stuart Owens"
      },
      {
        "id": 2,
        "name": "Rhodes Guthrie"
      }
    ],
    "greeting": "Hello, Atkins Mcintyre! You have 9 unread messages.",
    "favoriteFruit": "strawberry"
  },
  {
    "_id": "63982bbbb8d6e722b5aa4966",
    "index": 45,
    "guid": "e3240b41-5d7e-4cec-b4d1-7957a4018cb1",
    "isActive": false,
    "balance": "$2,574.41",
    "picture": "http://placehold.it/32x32",
    "age": 30,
    "eyeColor": "blue",
    "name": "Ava Martin",
    "gender": "female",
    "company": "VETRON",
    "email": "avamartin@vetron.com",
    "phone": "+1 (876) 488-3007",
    "address": "862 Landis Court, Esmont, Connecticut, 416",
    "about": "Sit pariatur voluptate enim cupidatat consectetur anim irure do aliqua dolore laboris. Cupidatat qui dolor est anim in in fugiat. Elit dolore id elit minim ut veniam ut ipsum ut exercitation mollit ut ea duis. Ullamco enim irure ea eu enim veniam sint nostrud exercitation.\r\n",
    "registered": "2016-08-07T12:12:33 -02:00",
    "latitude": -8.605701,
    "longitude": 161.736723,
    "tags": [
      "aliquip",
      "do",
      "quis",
      "do",
      "cupidatat",
      "ad",
      "incididunt"
    ],
    "friends": [
      {
        "id": 0,
        "name": "Natasha Alford"
      },
      {
        "id": 1,
        "name": "Hardy Odom"
      },
      {
        "id": 2,
        "name": "Huff Perkins"
      }
    ],
    "greeting": "Hello, Ava Martin! You have 7 unread messages.",
    "favoriteFruit": "strawberry"
  },
  {
    "_id": "63982bbbf702abf17c088cb5",
    "index": 46,
    "guid": "ffc43f4f-4963-4fbe-8321-2a7ed36e7f00",
    "isActive": true,
    "balance": "$1,291.58",
    "picture": "http://placehold.it/32x32",
    "age": 21,
    "eyeColor": "green",
    "name": "Maribel Blevins",
    "gender": "female",
    "company": "ASSITIA",
    "email": "maribelblevins@assitia.com",
    "phone": "+1 (886) 422-2277",
    "address": "305 Waldorf Court, Ruckersville, Iowa, 7412",
    "about": "Id commodo magna anim voluptate veniam irure Lorem incididunt ut ad esse. Voluptate minim ullamco commodo officia laborum Lorem id veniam commodo labore reprehenderit. Qui labore aliqua qui adipisicing incididunt ea mollit ad nostrud ut reprehenderit labore magna. Sint commodo pariatur consectetur ea adipisicing. Proident ut magna id aliquip cupidatat.\r\n",
    "registered": "2016-04-09T06:44:10 -02:00",
    "latitude": -80.281854,
    "longitude": -109.823522,
    "tags": [
      "aute",
      "irure",
      "occaecat",
      "magna",
      "enim",
      "excepteur",
      "consequat"
    ],
    "friends": [
      {
        "id": 0,
        "name": "Hurst Merrill"
      },
      {
        "id": 1,
        "name": "Kline Koch"
      },
      {
        "id": 2,
        "name": "Hopkins Potter"
      }
    ],
    "greeting": "Hello, Maribel Blevins! You have 1 unread messages.",
    "favoriteFruit": "apple"
  },
  {
    "_id": "63982bbbd6ba292bc9110efb",
    "index": 47,
    "guid": "168a1be4-82c3-4ea4-aecb-4771c5ab6f3a",
    "isActive": true,
    "balance": "$1,745.55",
    "picture": "http://placehold.it/32x32",
    "age": 33,
    "eyeColor": "blue",
    "name": "Jaime Weiss",
    "gender": "female",
    "company": "QUIZKA",
    "email": "jaimeweiss@quizka.com",
    "phone": "+1 (816) 412-2911",
    "address": "766 Stryker Court, Mammoth, Wisconsin, 2605",
    "about": "Culpa tempor ipsum nostrud qui culpa velit cillum consectetur quis. Mollit eiusmod nulla ad mollit in ullamco. Et dolor deserunt qui exercitation excepteur pariatur culpa incididunt proident ut id. Ullamco magna voluptate anim proident commodo laborum labore anim labore aute et cupidatat. Sunt voluptate sint sunt cillum fugiat reprehenderit mollit reprehenderit.\r\n",
    "registered": "2017-05-29T01:06:33 -02:00",
    "latitude": -67.546787,
    "longitude": -155.329368,
    "tags": [
      "non",
      "mollit",
      "commodo",
      "ullamco",
      "sunt",
      "esse",
      "sit"
    ],
    "friends": [
      {
        "id": 0,
        "name": "Tabitha Hawkins"
      },
      {
        "id": 1,
        "name": "Knapp Langley"
      },
      {
        "id": 2,
        "name": "Christi Randall"
      }
    ],
    "greeting": "Hello, Jaime Weiss! You have 9 unread messages.",
    "favoriteFruit": "apple"
  },
  {
    "_id": "63982bbb1ecbe99124df41fd",
    "index": 48,
    "guid": "e9152d63-ed2e-4918-ad5c-b56afbb676aa",
    "isActive": false,
    "balance": "$2,405.34",
    "picture": "http://placehold.it/32x32",
    "age": 35,
    "eyeColor": "green",
    "name": "Murphy Bradshaw",
    "gender": "male",
    "company": "ZOARERE",
    "email": "murphybradshaw@zoarere.com",
    "phone": "+1 (829) 453-3763",
    "address": "799 Irwin Street, Ilchester, Mississippi, 2852",
    "about": "Laboris do pariatur veniam sunt labore dolor enim proident proident. Ea nulla amet eiusmod occaecat amet ad. Qui labore anim pariatur occaecat ex nostrud dolor. Minim elit adipisicing veniam quis nulla ipsum ut velit anim ipsum.\r\n",
    "registered": "2019-12-09T07:33:43 -01:00",
    "latitude": 35.630305,
    "longitude": 145.733042,
    "tags": [
      "ullamco",
      "sint",
      "id",
      "qui",
      "excepteur",
      "ea",
      "velit"
    ],
    "friends": [
      {
        "id": 0,
        "name": "Waters Frazier"
      },
      {
        "id": 1,
        "name": "Malinda Fletcher"
      },
      {
        "id": 2,
        "name": "Chapman Kelley"
      }
    ],
    "greeting": "Hello, Murphy Bradshaw! You have 5 unread messages.",
    "favoriteFruit": "strawberry"
  },
  {
    "_id": "63982bbb247c23c1af03c64b",
    "index": 49,
    "guid": "89758573-2981-483a-8b45-ffecb5573bf0",
    "isActive": false,
    "balance": "$3,160.51",
    "picture": "http://placehold.it/32x32",
    "age": 22,
    "eyeColor": "blue",
    "name": "Franks Mckenzie",
    "gender": "male",
    "company": "DIGIRANG",
    "email": "franksmckenzie@digirang.com",
    "phone": "+1 (971) 515-3101",
    "address": "501 Elmwood Avenue, Alfarata, Puerto Rico, 6181",
    "about": "Tempor exercitation est laborum veniam do aute excepteur dolor aute exercitation aliqua laboris Lorem. Aliquip sunt adipisicing dolor ex labore et consectetur in amet nisi exercitation deserunt nostrud. Deserunt non et qui officia ea laboris nulla reprehenderit eu. Est aute in ut exercitation ut dolor velit. Irure esse non enim anim ea deserunt. Incididunt ad dolor velit elit non voluptate enim cillum ea sint cillum aliquip exercitation.\r\n",
    "registered": "2014-02-28T02:25:20 -01:00",
    "latitude": -22.353443,
    "longitude": 65.765953,
    "tags": [
      "pariatur",
      "aliquip",
      "occaecat",
      "officia",
      "elit",
      "officia",
      "sit"
    ],
    "friends": [
      {
        "id": 0,
        "name": "Bailey Gonzales"
      },
      {
        "id": 1,
        "name": "Brittney Lloyd"
      },
      {
        "id": 2,
        "name": "Danielle Dixon"
      }
    ],
    "greeting": "Hello, Franks Mckenzie! You have 10 unread messages.",
    "favoriteFruit": "strawberry"
  },
  {
    "_id": "63982bbbad66e42d08b9096b",
    "index": 50,
    "guid": "35b720a6-1016-4e80-9964-3dbd73e326c6",
    "isActive": false,
    "balance": "$2,319.31",
    "picture": "http://placehold.it/32x32",
    "age": 40,
    "eyeColor": "green",
    "name": "Lang Sargent",
    "gender": "male",
    "company": "ZAPHIRE",
    "email": "langsargent@zaphire.com",
    "phone": "+1 (921) 430-2413",
    "address": "628 Brighton Court, Avoca, New York, 4026",
    "about": "Tempor velit cupidatat sunt laborum irure aliquip cillum veniam. Excepteur est officia ad ad irure minim consequat. Ad qui dolore incididunt qui Lorem laborum exercitation elit ipsum tempor occaecat ea. Sint consequat cillum do minim occaecat deserunt esse reprehenderit ut fugiat culpa eu commodo ullamco. Amet ut sit voluptate duis.\r\n",
    "registered": "2018-11-02T06:44:13 -01:00",
    "latitude": -9.279828,
    "longitude": -4.96464,
    "tags": [
      "ad",
      "dolor",
      "cillum",
      "Lorem",
      "elit",
      "ea",
      "tempor"
    ],
    "friends": [
      {
        "id": 0,
        "name": "Martina Farley"
      },
      {
        "id": 1,
        "name": "Perkins Wolf"
      },
      {
        "id": 2,
        "name": "Krista Morgan"
      }
    ],
    "greeting": "Hello, Lang Sargent! You have 10 unread messages.",
    "favoriteFruit": "banana"
  },
  {
    "_id": "63982bbb40a8b8ee60adea20",
    "index": 51,
    "guid": "fae35982-67f2-424b-8398-c449f8c0df87",
    "isActive": false,
    "balance": "$2,754.36",
    "picture": "http://placehold.it/32x32",
    "age": 26,
    "eyeColor": "green",
    "name": "Riddle Turner",
    "gender": "male",
    "company": "HAWKSTER",
    "email": "riddleturner@hawkster.com",
    "phone": "+1 (903) 557-2154",
    "address": "792 Fenimore Street, Celeryville, Guam, 1602",
    "about": "In ipsum magna fugiat officia magna mollit cillum fugiat culpa cupidatat aute deserunt in aute. Laboris qui ullamco elit ut labore. Enim aliqua irure consectetur adipisicing aute velit incididunt laboris tempor. Eu laboris ut enim voluptate proident ut eiusmod duis est. Laboris dolor aliquip occaecat ullamco proident sit velit nisi Lorem eu quis exercitation.\r\n",
    "registered": "2020-03-10T02:25:30 -01:00",
    "latitude": -68.289861,
    "longitude": 95.827879,
    "tags": [
      "dolore",
      "nisi",
      "proident",
      "culpa",
      "fugiat",
      "do",
      "qui"
    ],
    "friends": [
      {
        "id": 0,
        "name": "Whitehead Benton"
      },
      {
        "id": 1,
        "name": "Maxwell Parrish"
      },
      {
        "id": 2,
        "name": "Buckley Colon"
      }
    ],
    "greeting": "Hello, Riddle Turner! You have 4 unread messages.",
    "favoriteFruit": "apple"
  },
  {
    "_id": "63982bbb4a781bb374a73a48",
    "index": 52,
    "guid": "0412b788-c257-4636-8a83-20098abe6195",
    "isActive": true,
    "balance": "$1,665.73",
    "picture": "http://placehold.it/32x32",
    "age": 29,
    "eyeColor": "green",
    "name": "Sanders Morrison",
    "gender": "male",
    "company": "IZZBY",
    "email": "sandersmorrison@izzby.com",
    "phone": "+1 (916) 474-3496",
    "address": "956 Harman Street, Layhill, Kansas, 8002",
    "about": "Proident enim veniam velit sint ex quis ullamco id incididunt ipsum consequat. Ipsum elit officia culpa minim laboris velit dolore quis anim in fugiat dolor. Sint et ipsum reprehenderit ea aliquip exercitation deserunt esse ullamco magna qui. Nostrud consectetur ea dolore ullamco velit aute eu labore et.\r\n",
    "registered": "2017-06-29T05:10:21 -02:00",
    "latitude": 30.545053,
    "longitude": -125.149516,
    "tags": [
      "ad",
      "amet",
      "quis",
      "ut",
      "mollit",
      "laboris",
      "commodo"
    ],
    "friends": [
      {
        "id": 0,
        "name": "Victoria Gutierrez"
      },
      {
        "id": 1,
        "name": "Irma Day"
      },
      {
        "id": 2,
        "name": "Lesa Larsen"
      }
    ],
    "greeting": "Hello, Sanders Morrison! You have 4 unread messages.",
    "favoriteFruit": "banana"
  },
  {
    "_id": "63982bbb8700b76986d86382",
    "index": 53,
    "guid": "3ad90ba6-8761-47ef-a87d-2f277e1008e0",
    "isActive": false,
    "balance": "$1,638.90",
    "picture": "http://placehold.it/32x32",
    "age": 37,
    "eyeColor": "green",
    "name": "Dollie Irwin",
    "gender": "female",
    "company": "VITRICOMP",
    "email": "dollieirwin@vitricomp.com",
    "phone": "+1 (964) 415-2228",
    "address": "860 Baycliff Terrace, Noblestown, Georgia, 5374",
    "about": "Eiusmod magna laboris mollit dolor dolore eu reprehenderit ad Lorem ullamco. Velit aliqua cupidatat incididunt sit consequat quis magna id non nisi ea cillum dolor. Reprehenderit labore eiusmod est enim irure sint enim dolore in officia ea aliqua fugiat. Adipisicing fugiat cillum officia cupidatat.\r\n",
    "registered": "2020-11-17T07:26:50 -01:00",
    "latitude": -14.538183,
    "longitude": 76.183924,
    "tags": [
      "deserunt",
      "occaecat",
      "sunt",
      "cillum",
      "voluptate",
      "id",
      "velit"
    ],
    "friends": [
      {
        "id": 0,
        "name": "Elvia Baker"
      },
      {
        "id": 1,
        "name": "Lora Coffey"
      },
      {
        "id": 2,
        "name": "Yvonne Jackson"
      }
    ],
    "greeting": "Hello, Dollie Irwin! You have 5 unread messages.",
    "favoriteFruit": "strawberry"
  },
  {
    "_id": "63982bbb852c165d398c41f3",
    "index": 54,
    "guid": "1bbf2d94-2741-40c1-acf4-9ac0d52feed5",
    "isActive": true,
    "balance": "$3,430.80",
    "picture": "http://placehold.it/32x32",
    "age": 30,
    "eyeColor": "green",
    "name": "Virgie Lynn",
    "gender": "female",
    "company": "SATIANCE",
    "email": "virgielynn@satiance.com",
    "phone": "+1 (803) 456-3921",
    "address": "368 Bushwick Court, Gordon, Vermont, 5960",
    "about": "Ut nulla veniam consequat sunt enim sit labore nulla qui duis labore dolore veniam aliquip. Eiusmod velit do dolore cupidatat ipsum excepteur labore aliquip sit excepteur mollit tempor aute commodo. In aliqua ex Lorem exercitation ullamco adipisicing. Proident consequat enim culpa consequat excepteur aliquip tempor pariatur. Nisi voluptate elit voluptate amet tempor enim tempor cillum non nostrud enim.\r\n",
    "registered": "2019-02-09T10:34:16 -01:00",
    "latitude": 88.18842,
    "longitude": -106.67028,
    "tags": [
      "quis",
      "nulla",
      "tempor",
      "ut",
      "minim",
      "do",
      "consequat"
    ],
    "friends": [
      {
        "id": 0,
        "name": "Pat Woodard"
      },
      {
        "id": 1,
        "name": "Adkins Avery"
      },
      {
        "id": 2,
        "name": "Wyatt Stone"
      }
    ],
    "greeting": "Hello, Virgie Lynn! You have 4 unread messages.",
    "favoriteFruit": "strawberry"
  },
  {
    "_id": "63982bbb53167e2c5e618376",
    "index": 55,
    "guid": "aa93ab85-036f-417d-bac0-99a2b5a5d482",
    "isActive": false,
    "balance": "$3,443.45",
    "picture": "http://placehold.it/32x32",
    "age": 37,
    "eyeColor": "green",
    "name": "Christine Barlow",
    "gender": "female",
    "company": "COLAIRE",
    "email": "christinebarlow@colaire.com",
    "phone": "+1 (992) 582-2328",
    "address": "222 Anthony Street, Bison, Arkansas, 286",
    "about": "Cillum occaecat sunt aliqua consequat laborum cupidatat aliqua proident tempor officia eiusmod irure consectetur. Laboris commodo elit labore laboris dolore labore magna. Sint anim officia amet laborum veniam eu ut aliquip laboris dolor veniam non ipsum quis.\r\n",
    "registered": "2019-01-28T08:13:18 -01:00",
    "latitude": -29.506551,
    "longitude": -22.703734,
    "tags": [
      "proident",
      "minim",
      "reprehenderit",
      "in",
      "anim",
      "aliqua",
      "Lorem"
    ],
    "friends": [
      {
        "id": 0,
        "name": "Sue Obrien"
      },
      {
        "id": 1,
        "name": "Payne Powell"
      },
      {
        "id": 2,
        "name": "Hughes Green"
      }
    ],
    "greeting": "Hello, Christine Barlow! You have 8 unread messages.",
    "favoriteFruit": "apple"
  },
  {
    "_id": "63982bbb354c6c72085b1afc",
    "index": 56,
    "guid": "4edb41f8-c1cb-451b-8972-3df1acb5a0ed",
    "isActive": false,
    "balance": "$2,880.29",
    "picture": "http://placehold.it/32x32",
    "age": 23,
    "eyeColor": "blue",
    "name": "Noel Stewart",
    "gender": "male",
    "company": "NEOCENT",
    "email": "noelstewart@neocent.com",
    "phone": "+1 (840) 405-3119",
    "address": "689 Duryea Place, Garnet, Kentucky, 2680",
    "about": "Labore consequat duis est aute pariatur do laborum ex pariatur magna deserunt deserunt veniam. Mollit dolor et culpa ea exercitation do anim. Pariatur sunt ut minim labore eiusmod aliquip sit eiusmod ipsum do excepteur dolore cupidatat cillum.\r\n",
    "registered": "2022-07-01T08:28:55 -02:00",
    "latitude": 85.312488,
    "longitude": -127.307117,
    "tags": [
      "id",
      "magna",
      "nostrud",
      "id",
      "velit",
      "deserunt",
      "voluptate"
    ],
    "friends": [
      {
        "id": 0,
        "name": "Ethel Lane"
      },
      {
        "id": 1,
        "name": "Greene Delacruz"
      },
      {
        "id": 2,
        "name": "Billie Bowers"
      }
    ],
    "greeting": "Hello, Noel Stewart! You have 7 unread messages.",
    "favoriteFruit": "banana"
  },
  {
    "_id": "63982bbb596e62bb899a959b",
    "index": 57,
    "guid": "cfe701f5-42c3-40ce-93ce-ecf2a7212aba",
    "isActive": true,
    "balance": "$1,671.78",
    "picture": "http://placehold.it/32x32",
    "age": 29,
    "eyeColor": "green",
    "name": "Sheila Mcpherson",
    "gender": "female",
    "company": "VENOFLEX",
    "email": "sheilamcpherson@venoflex.com",
    "phone": "+1 (906) 459-2483",
    "address": "300 Arlington Avenue, Steinhatchee, New Mexico, 8367",
    "about": "Aute culpa eu exercitation voluptate anim qui anim. Duis voluptate ipsum qui irure reprehenderit. Laborum sint commodo Lorem est exercitation laborum. Ullamco consectetur incididunt minim elit ut esse eiusmod. Sit officia excepteur velit enim amet adipisicing reprehenderit. Esse eu do do aute sit nulla culpa consectetur aliqua nostrud consectetur ex laborum nulla. Velit nulla veniam et minim dolor duis ipsum qui amet voluptate pariatur.\r\n",
    "registered": "2017-02-01T10:24:35 -01:00",
    "latitude": -68.484274,
    "longitude": 19.564195,
    "tags": [
      "ipsum",
      "ullamco",
      "id",
      "cupidatat",
      "voluptate",
      "nisi",
      "ullamco"
    ],
    "friends": [
      {
        "id": 0,
        "name": "Todd Solis"
      },
      {
        "id": 1,
        "name": "Kathleen Adkins"
      },
      {
        "id": 2,
        "name": "Bonita Wiley"
      }
    ],
    "greeting": "Hello, Sheila Mcpherson! You have 9 unread messages.",
    "favoriteFruit": "banana"
  },
  {
    "_id": "63982bbb7fbe326aaea557bc",
    "index": 58,
    "guid": "485cf919-7d13-4fb3-b0e1-ade405648bc2",
    "isActive": true,
    "balance": "$1,336.84",
    "picture": "http://placehold.it/32x32",
    "age": 21,
    "eyeColor": "green",
    "name": "Crane Mcleod",
    "gender": "male",
    "company": "ZILLACOM",
    "email": "cranemcleod@zillacom.com",
    "phone": "+1 (910) 486-3915",
    "address": "728 Havemeyer Street, Deltaville, Northern Mariana Islands, 5521",
    "about": "Qui laboris duis quis occaecat. Non officia irure id veniam et occaecat consequat tempor anim adipisicing. Incididunt commodo ad non tempor nostrud do mollit occaecat quis sunt duis. Commodo consequat exercitation consequat fugiat elit deserunt do fugiat laboris. Aliquip eu et minim proident nisi qui eiusmod irure. Enim reprehenderit dolor exercitation cillum. Aliquip proident in minim occaecat do.\r\n",
    "registered": "2021-03-22T12:30:32 -01:00",
    "latitude": -74.901849,
    "longitude": 168.959433,
    "tags": [
      "aute",
      "sint",
      "deserunt",
      "proident",
      "ut",
      "voluptate",
      "ullamco"
    ],
    "friends": [
      {
        "id": 0,
        "name": "Miles Sykes"
      },
      {
        "id": 1,
        "name": "Crawford Burke"
      },
      {
        "id": 2,
        "name": "Stevens Harvey"
      }
    ],
    "greeting": "Hello, Crane Mcleod! You have 10 unread messages.",
    "favoriteFruit": "strawberry"
  },
  {
    "_id": "63982bbb608bb897b1c1b18e",
    "index": 59,
    "guid": "0e8ef046-24f6-49b5-a325-245dfbbfe394",
    "isActive": true,
    "balance": "$2,518.40",
    "picture": "http://placehold.it/32x32",
    "age": 27,
    "eyeColor": "green",
    "name": "Dolores Hale",
    "gender": "female",
    "company": "COGNICODE",
    "email": "doloreshale@cognicode.com",
    "phone": "+1 (924) 517-2338",
    "address": "415 Doone Court, Rosedale, Florida, 2590",
    "about": "Sint duis excepteur enim sit tempor reprehenderit amet mollit. Nostrud sunt deserunt ex anim deserunt laboris. Non ut minim dolore amet anim commodo mollit. Aliqua excepteur dolore amet eu incididunt sit officia magna esse. Nostrud consectetur magna veniam do cupidatat qui quis reprehenderit cupidatat pariatur aliqua laboris.\r\n",
    "registered": "2015-02-20T09:32:42 -01:00",
    "latitude": 43.998915,
    "longitude": -25.545833,
    "tags": [
      "pariatur",
      "cupidatat",
      "in",
      "consectetur",
      "duis",
      "dolore",
      "cupidatat"
    ],
    "friends": [
      {
        "id": 0,
        "name": "Marianne Hoover"
      },
      {
        "id": 1,
        "name": "Ronda Harper"
      },
      {
        "id": 2,
        "name": "Ashley Clarke"
      }
    ],
    "greeting": "Hello, Dolores Hale! You have 7 unread messages.",
    "favoriteFruit": "apple"
  },
  {
    "_id": "63982bbb2f94308985552c65",
    "index": 60,
    "guid": "5504a595-8aa5-462b-b52c-122b4e7f7f12",
    "isActive": true,
    "balance": "$2,383.25",
    "picture": "http://placehold.it/32x32",
    "age": 34,
    "eyeColor": "brown",
    "name": "Reynolds Barker",
    "gender": "male",
    "company": "TEMORAK",
    "email": "reynoldsbarker@temorak.com",
    "phone": "+1 (821) 573-2768",
    "address": "741 Seeley Street, Gloucester, Missouri, 708",
    "about": "Irure aute laborum laboris dolor ad enim. Deserunt tempor anim do nulla pariatur velit consectetur est. Esse enim amet cupidatat nisi et anim. Ullamco nostrud sit in incididunt. Sint excepteur cupidatat occaecat nostrud sunt dolor. Reprehenderit sint in labore laboris eu velit est.\r\n",
    "registered": "2015-03-09T09:38:48 -01:00",
    "latitude": 38.121914,
    "longitude": -129.517879,
    "tags": [
      "et",
      "cillum",
      "ex",
      "aliqua",
      "non",
      "pariatur",
      "laborum"
    ],
    "friends": [
      {
        "id": 0,
        "name": "Marisol Bird"
      },
      {
        "id": 1,
        "name": "Renee Cooke"
      },
      {
        "id": 2,
        "name": "Jeannette Thomas"
      }
    ],
    "greeting": "Hello, Reynolds Barker! You have 2 unread messages.",
    "favoriteFruit": "banana"
  },
  {
    "_id": "63982bbb45698543708beb92",
    "index": 61,
    "guid": "e118ca1a-ca63-4396-9e55-7a98ddbfcc1a",
    "isActive": true,
    "balance": "$1,808.17",
    "picture": "http://placehold.it/32x32",
    "age": 39,
    "eyeColor": "blue",
    "name": "Poole Gentry",
    "gender": "male",
    "company": "GEEKUS",
    "email": "poolegentry@geekus.com",
    "phone": "+1 (824) 409-3094",
    "address": "487 Kimball Street, Vale, California, 9632",
    "about": "Sit laboris eu in elit voluptate laboris esse tempor velit aute in. Dolore aliqua nisi dolore id sunt ut ut veniam magna exercitation culpa sit id officia. Fugiat proident minim laborum eu occaecat et adipisicing consectetur aute nostrud laboris adipisicing commodo sit. Elit pariatur ad veniam reprehenderit labore non. Aute consequat cillum incididunt adipisicing pariatur ut magna.\r\n",
    "registered": "2018-12-02T10:08:12 -01:00",
    "latitude": -64.951344,
    "longitude": 169.23513,
    "tags": [
      "velit",
      "qui",
      "ad",
      "in",
      "voluptate",
      "commodo",
      "eiusmod"
    ],
    "friends": [
      {
        "id": 0,
        "name": "Chaney Valencia"
      },
      {
        "id": 1,
        "name": "Curtis Hull"
      },
      {
        "id": 2,
        "name": "Valenzuela Heath"
      }
    ],
    "greeting": "Hello, Poole Gentry! You have 6 unread messages.",
    "favoriteFruit": "apple"
  }
]

--------------------------------------------------------------------------------

/==============================================================================\
| FILE: core\filesystem\filesystem.go
| PATH: C:\go\src\hydraide\app\core\filesystem\filesystem.go
| SIZE: 17.2 KB
\==============================================================================/

// Package filesystem provides thread-safe operations for low-level file and folder handling,
// including compression, atomic writes, and binary-slice storage.
//
// This package is designed to support high-performance embedded storage systems,
// where data is stored as compressed binary segments in single files.
//
// Key features:
//   - Safe concurrent access using mutexes per file/folder
//   - Transparent compression (e.g. Snappy) via the Compressor interface
//   - Append and overwrite modes for structured binary data
//   - Recursive deletion with depth limit
//   - Metadata-friendly structure for integration with higher-level swamp logic
//
// All read/write operations use lock granularity (per file or folder), enabling controlled parallelism.
// Intended use cases include embedded databases, in-process file systems, and edge-node persistence.
package filesystem

import (
	"bytes"
	"encoding/binary"
	"errors"
	"github.com/hydraide/hydraide/app/core/compressor"
	"io"
	"log/slog"
	"os"
	"path/filepath"
	"sync"
)

// Filesystem defines thread-safe file and folder operations with support for
// compression, binary-encoded content, and controlled deletion.
//
// All methods are designed for use in embedded systems, persistent layers,
// and modular storage engines.

type Filesystem interface {
	// CreateFolder creates the given folder path if it doesn't already exist.
	CreateFolder(folderPath string) error

	// DeleteFolder attempts to delete the folder if it's empty, then recursively
	// checks and deletes its parent folders up to maxDepth levels.
	DeleteFolder(folderPath string, maxDepth int) error

	// SaveFile stores or updates the given file with binary-encoded and compressed content.
	// If appendFile is true, the new content is appended to the existing file content.
	// If false, the file is overwritten with the new content.
	SaveFile(filePath string, content [][]byte, appendFile bool) error

	// DeleteFile removes the specified file if it exists.
	DeleteFile(filePath string) error

	// DeleteAllFiles removes all files within the given folder. Subfolders are not deleted.
	DeleteAllFiles(folderPath string) error

	// GetFile reads and decompresses the specified file, returning its content
	// as a slice of binary segments ([][]byte).
	GetFile(filePath string) ([][]byte, error)

	// GetAllFileContents reads all files in the given folder (excluding listed ones),
	// and returns a map of filename to binary content segments.
	GetAllFileContents(folderPath string, excludedFiles ...string) (map[string][][]byte, error)

	// GetFileSize returns the size of the file in bytes.
	GetFileSize(filePath string) (int64, error)

	// IsFolderExists checks whether the given folder path exists.
	IsFolderExists(folderPath string) bool
}

type filesystem struct {
	folderLocks         sync.Map              // Mappa zárolások kezelése
	compressorInterface compressor.Compressor // compressorInterface a fájlok be és -kitömörítését kezeli
}

func New() Filesystem {
	fs := &filesystem{
		compressorInterface: compressor.New(compressor.Snappy),
	}
	return fs
}

// CreateFolder creates the specified absolute folder path if it does not already exist.
func (fs *filesystem) CreateFolder(folderPath string) error {

	// Validate the folder path
	if folderPath == "" {
		return errors.New("invalid folder path")
	}

	// Acquire a dedicated lock for the folder (folder-level lock)
	folderLock := fs.getFolderLock(folderPath)
	folderLock.Lock()
	defer folderLock.Unlock()

	// Create the folder if it doesn't exist
	return os.MkdirAll(folderPath, os.ModePerm)

}

// DeleteFolder deletes the specified absolute folder path if it's empty,
// and recursively checks and removes parent folders up to maxDepth levels.
func (fs *filesystem) DeleteFolder(folderPath string, maxDepth int) error {

	// Normalize the folder path to ensure consistent comparison
	folderPath = filepath.Clean(folderPath)

	// Check if the folder exists
	if _, err := os.Stat(folderPath); os.IsNotExist(err) {
		return nil // Ha a mappa már nem létezik, nincs mit törölni
	}

	// Acquire lock for folder deletion (folder-level lock)
	folderLock := fs.getFolderLock(folderPath)
	folderLock.Lock()

	// Check if the folder is empty and delete it if so
	err := fs.deleteIfEmpty(folderPath)

	// Release the lock after deletion
	folderLock.Unlock()

	if err != nil {
		return err // Ha a mappa nem üres, térjünk vissza hibával
	}

	// If folder is not empty, return with error

	// Check and delete parent folders up to maxDepth
	for i := 0; i < maxDepth; i++ {
		parentPath := filepath.Dir(folderPath)
		// Lock the parent folder
		parentLock := fs.getFolderLock(parentPath)
		parentLock.Lock()
		// Check if the parent is empty and delete it if so
		err := fs.deleteIfEmpty(parentPath)
		// Unlock the parent after deletion
		parentLock.Unlock()
		if err != nil {
			break // Ha egy szülő nem üres, kilépünk
		}
		// Stop if a parent is not empty
		folderPath = parentPath
	}

	return nil

}

// SaveFile creates or updates a file with the given binary content.
// If appendFile is true, the new content is appended to the existing file content.
// If appendFile is false, the file is fully overwritten with the new content.
func (fs *filesystem) SaveFile(filePath string, content [][]byte, appendFile bool) error {
	// Validate the file path
	if filePath == "" {
		return errors.New("invalid file path")
	}

	// Acquire a lock for file-level operations
	fileLock := fs.getFolderLock(filePath)
	fileLock.Lock()
	defer fileLock.Unlock()

	// Check if the file exists
	if _, err := os.Stat(filePath); err != nil {
		if errors.Is(err, os.ErrNotExist) {

			// If the file doesn't exist locally, optionally check a remote backup (e.g., aegisInterface)
			// TODO: implement remote check and download logic
			// Example:
			// if fs.aegisInterface.Exists(filePath) {
			//     return fs.aegisInterface.Download(filePath)
			// }

			// Create necessary folders if the file and its path do not exist
			if err := os.MkdirAll(filepath.Dir(filePath), os.ModePerm); err != nil {
				return err
			}
		} else {
			return err // Return other stat errors
		}
	}

	var finalContent []byte

	if appendFile {
		// Read existing file content if appending
		existingContent, err := os.ReadFile(filePath)
		if err != nil && !errors.Is(err, os.ErrNotExist) {
			return err
		}

		// Decompress existing content (if any)
		if len(existingContent) > 0 {
			decompressedContent, err := fs.compressorInterface.Decompress(existingContent)
			if err != nil {
				return err
			}
			finalContent = decompressedContent
		}

		// Append new binary parts to the decompressed content
		for _, part := range content {
			finalContent = append(finalContent, encodeBinaryLength(part)...)
			finalContent = append(finalContent, part...)
		}

	} else {
		// If not appending, build content from scratch
		for _, part := range content {
			finalContent = append(finalContent, encodeBinaryLength(part)...)
			finalContent = append(finalContent, part...)
		}
	}

	// Compress the final binary content
	compressedContent, err := fs.compressorInterface.Compress(finalContent)
	if err != nil {
		return err
	}

	// Write the compressed content to the file
	return os.WriteFile(filePath, compressedContent, os.ModePerm)
}

// DeleteFile removes the specified file if it exists.
func (fs *filesystem) DeleteFile(filePath string) error {
	// Validate the file path
	if filePath == "" {
		return errors.New("invalid file path")
	}

	// Acquire a lock for the file (file-level lock)
	fileLock := fs.getFolderLock(filePath)
	fileLock.Lock()
	defer fileLock.Unlock()

	// Check if the file exists
	if _, err := os.Stat(filePath); err != nil {
		if errors.Is(err, os.ErrNotExist) {
			// If the file doesn't exist locally, optionally delete it from remote storage (e.g., aegisInterface)
			// TODO: implement deletion from aegis
		}
		return err // Return other stat errors
	}

	// Delete the file from the local filesystem
	err := os.Remove(filePath)
	if err != nil {
		return err // Return error if deletion failed
	}

	// Delete the file from remote storage (e.g., aegisInterface)
	// TODO: implement remote file deletion
	return nil
}

// DeleteAllFiles removes all files within the specified folder.
// Only regular files are deleted — subdirectories are ignored.
// Each file is locked individually to ensure safe concurrent access.
func (fs *filesystem) DeleteAllFiles(folderPath string) error {
	// Validate the folder path
	if folderPath == "" {
		return errors.New("invalid folder path")
	}

	// Check if the folder exists
	dirEntries, err := os.ReadDir(folderPath)
	if err != nil {
		if os.IsNotExist(err) {
			return nil // If the folder doesn't exist, there's nothing to delete
		}
		return err // Return error if folder check failed
	}

	// Iterate over each entry in the folder
	for _, entry := range dirEntries {
		// Skip subdirectories — we only delete files
		if entry.IsDir() {
			continue
		}

		// Full path to the file
		filePath := filepath.Join(folderPath, entry.Name())

		// Acquire lock for the file (file-level lock)
		fileLock := fs.getFolderLock(filePath)
		fileLock.Lock()

		// Delete the file from the local filesystem
		err := os.Remove(filePath)
		if err != nil {
			fileLock.Unlock() // Always release the lock before returning
			return err
		}

		// TODO: Implement deletion from remote Aegis storage
		// Example:
		// err = fs.aegisInterface.Delete(filePath)
		// if err != nil {
		//     fileLock.Unlock()
		//     return err
		// }

		// Release the file lock
		fileLock.Unlock()
	}

	return nil
}

// GetFile returns the contents of the specified file as a slice of binary segments.
// The file is expected to be compressed and structured as length-prefixed binary blocks.
func (fs *filesystem) GetFile(filePath string) ([][]byte, error) {
	// Validate the file path
	if filePath == "" {
		return nil, errors.New("invalid file path")
	}

	// Acquire file-level lock
	fileLock := fs.getFolderLock(filePath)
	fileLock.Lock()
	defer fileLock.Unlock()

	// Open the file for reading
	file, err := os.Open(filePath)
	if err != nil {
		if errors.Is(err, os.ErrNotExist) {
			// If the file doesn't exist, attempt to download it from remote storage (e.g., aegisInterface)
			// TODO: implement download from aegis
			return nil, err
		}
		return nil, err // Return other file open errors
	}

	// Read the full file content
	fileContent, err := io.ReadAll(file)
	if err != nil {
		if err := file.Close(); err != nil {
			slog.Error("Error closing file after read failure", "file", filePath, "error", err.Error())
		}
		return nil, err
	}

	// Close the file
	if err := file.Close(); err != nil {
		return nil, err
	}

	// Decompress the content
	decompressedContent, err := fs.compressorInterface.Decompress(fileContent)
	if err != nil {
		return nil, err // Return if decompression failed
	}

	// Parse the binary content into individual byte slices
	fileParts, err := parseBinaryData(decompressedContent)
	if err != nil {
		return nil, err
	}

	return fileParts, nil
}

// GetAllFileContents reads the contents of all files in the specified folder,
// excluding any files listed in excludedFiles.
// Returns a map where each filename maps to a slice of binary segments ([]byte).
func (fs *filesystem) GetAllFileContents(folderPath string, excludedFiles ...string) (map[string][][]byte, error) {

	// Validate the folder path
	if folderPath == "" {
		return nil, errors.New("invalid folder path")
	}

	// Result container for all file contents
	allFileContents := make(map[string][][]byte)

	// Build a fast lookup set for excluded file names
	excluded := make(map[string]struct{}, len(excludedFiles))
	for _, file := range excludedFiles {
		excluded[file] = struct{}{}
	}

	// Read all entries in the folder
	files, err := os.ReadDir(folderPath)
	if err != nil {
		return nil, err
	}

	// Lock the folder to ensure safe access
	folderLock := fs.getFolderLock(folderPath)
	folderLock.Lock()
	defer folderLock.Unlock()

	// Iterate over each file in the folder
	for _, fileInfo := range files {

		// Skip excluded files
		if _, skip := excluded[fileInfo.Name()]; skip {
			continue
		}

		// Full path to the file
		filePath := filepath.Join(folderPath, fileInfo.Name())

		// Lock the file for reading
		fileLock := fs.getFolderLock(filePath)
		fileLock.Lock()

		// Open the file for reading
		file, err := os.Open(filePath)
		if err != nil {
			fileLock.Unlock()
			continue // Skip this file if it can't be opened
		}

		// Read file content
		fileContent, err := io.ReadAll(file)
		if err != nil {
			func() {
				if closeErr := file.Close(); closeErr != nil {
					slog.Error("Error closing file after read failure", "file", filePath, "error", closeErr.Error())
				}
			}()

			fileLock.Unlock()
			continue // Skip on read failure
		}

		// Close the file
		err = file.Close()
		if err != nil {
			fileLock.Unlock()
			continue
		}

		// Release the file lock
		fileLock.Unlock()

		// Decompress file content
		decompressedContent, err := fs.compressorInterface.Decompress(fileContent)
		if err != nil {
			continue // Skip on decompression failure
		}

		// Parse binary data segments
		fileParts, err := parseBinaryData(decompressedContent)
		if err != nil {
			continue // Skip on parse failure
		}

		// Store the parsed content under the filename
		allFileContents[fileInfo.Name()] = fileParts
	}

	return allFileContents, nil
}

// GetFileSize returns the size of the specified file in bytes.
func (fs *filesystem) GetFileSize(filePath string) (int64, error) {
	// Validate the file path
	if filePath == "" {
		return 0, errors.New("invalid file path")
	}

	// Acquire file-level lock
	fileLock := fs.getFolderLock(filePath)
	fileLock.Lock()
	defer fileLock.Unlock()

	// Retrieve file info
	fileInfo, err := os.Stat(filePath)
	if err != nil {
		return 0, err // Return error if file does not exist or can't be accessed
	}

	// Return the file size in bytes
	return fileInfo.Size(), nil
}

// parseBinaryData iterates over a decompressed binary stream and splits it into
// separate byte slices based on length-prefixed blocks.
// Each block is prefixed with a 4-byte little-endian length header.
func parseBinaryData(data []byte) ([][]byte, error) {
	var result [][]byte
	reader := bytes.NewReader(data)

	// Read through the binary stream
	for {
		// Read the next 4-byte length header (uint32)
		var length uint32
		err := binary.Read(reader, binary.LittleEndian, &length)
		if err != nil {
			if errors.Is(err, io.EOF) {
				break // End of file reached
			}
			return nil, err // Failed to read length
		}

		// Read the data block of the given length
		dataBlock := make([]byte, length)
		_, err = reader.Read(dataBlock)
		if err != nil {
			return nil, err // Failed to read block
		}

		// Append to the result set
		result = append(result, dataBlock)
	}
	return result, nil
}

// encodeBinaryLength encodes the length of a binary slice
// as a 4-byte little-endian value (used as a prefix).
func encodeBinaryLength(data []byte) []byte {
	length := uint32(len(data)) // Determine length of data
	buf := new(bytes.Buffer)
	// Write length in binary format
	if err := binary.Write(buf, binary.LittleEndian, length); err != nil {
		slog.Error("Failed to encode binary length, returning nil", "error", err.Error(), "data_length", len(data))
		return nil // Return nil if encoding fails
	}
	return buf.Bytes() // Return length bytes
}

// getFolderLock returns a mutex for the given folder path.
// If no lock exists yet, it creates and stores one.
func (fs *filesystem) getFolderLock(folder string) *sync.Mutex {
	actual, _ := fs.folderLocks.LoadOrStore(folder, &sync.Mutex{})
	return actual.(*sync.Mutex)
}

// deleteIfEmpty removes the given folder if it is empty.
// If the folder does not exist, it returns nil.
func (fs *filesystem) deleteIfEmpty(folderPath string) error {
	// Attempt to open the directory
	dir, err := os.Open(folderPath)
	if err != nil {
		if errors.Is(err, os.ErrNotExist) {
			// Nothing to delete if directory doesn't exist
			return nil
		}
		return err // Failed to open directory
	}
	defer func() {
		if closeErr := dir.Close(); closeErr != nil {
			slog.Error("Error closing directory after checking emptiness", "folder", folderPath, "error", closeErr.Error())
		}
	}()

	// Try reading one entry to check if it's empty
	files, readErr := dir.Readdirnames(1)
	if readErr != nil && !errors.Is(readErr, io.EOF) {
		return readErr // Error while reading directory
	}

	// If EOF is returned and no files were read, it's empty
	if len(files) == 0 && errors.Is(readErr, io.EOF) {
		return os.Remove(folderPath) // Safe to remove
	}

	// Directory is not empty
	return errors.New("directory not empty")
}

func (fs *filesystem) IsFolderExists(folderPath string) bool {

	folderLock := fs.getFolderLock(folderPath)
	folderLock.Lock()
	defer folderLock.Unlock()

	_, err := os.Stat(folderPath)
	if err != nil {
		if os.IsNotExist(err) {
			return false
		}
	}
	return true

}

--------------------------------------------------------------------------------

/==============================================================================\
| FILE: core\filesystem\filesystem_test.go
| PATH: C:\go\src\hydraide\app\core\filesystem\filesystem_test.go
| SIZE: 13.3 KB
\==============================================================================/

package filesystem

import (
	"bytes"
	"github.com/hydraide/hydraide/app/core/compressor"
	"os"
	"path/filepath"
	"sync"
	"testing"
	"time"
)

const (
	testRootFolder = "./test_data"
	maxDepth       = 3
)

// setupTestEnvironment prepares the test directory structure before each test run.
func setupTestEnvironment() error {
	// Create base folder structure for tests
	return os.MkdirAll(testRootFolder, os.ModePerm)
}

// cleanupTestEnvironment removes the entire test environment after each test.
func cleanupTestEnvironment() {
	// Delete the test root folder and all its contents
	if err := os.RemoveAll(testRootFolder); err != nil {
		panic(err)
	}
}

// TestCreateFolder tests the CreateFolder function for basic behavior and error handling.
func TestCreateFolder(t *testing.T) {
	fs := New()

	// Set up test environment
	err := setupTestEnvironment()
	if err != nil {
		t.Fatalf("Failed to set up test environment: %v", err)
	}
	defer cleanupTestEnvironment()

	// Test 1: Create a folder that doesn't exist
	testFolder := filepath.Join(testRootFolder, "folder1")
	err = fs.CreateFolder(testFolder)
	if err != nil {
		t.Errorf("Failed to create folder: %v", err)
	}
	// Verify that the folder actually exists
	if _, err := os.Stat(testFolder); os.IsNotExist(err) {
		t.Errorf("Expected folder %s to exist, but it does not", testFolder)
	}

	// Test 2: Create a folder that already exists
	err = fs.CreateFolder(testFolder)
	if err != nil {
		t.Errorf("Failed to create an already existing folder: %v", err)
	}

	// Test 3: Try creating a folder with an empty path
	err = fs.CreateFolder("")
	if err == nil {
		t.Errorf("Expected error for empty folder path, but got nil")
	}
}

// TestConcurrentCreateAndDelete tests concurrent use of CreateFolder and DeleteFolder.
func TestConcurrentCreateAndDelete(t *testing.T) {
	fs := New()

	// Set up test environment
	err := setupTestEnvironment()
	if err != nil {
		t.Fatalf("Failed to set up test environment: %v", err)
	}
	defer cleanupTestEnvironment()

	// Folder path for concurrent access test
	testFolder := filepath.Join(testRootFolder, "concurrent_test")

	const goroutineCount = 10 // Number of concurrent goroutines

	// Use a WaitGroup to sync the goroutines
	var wg sync.WaitGroup
	wg.Add(goroutineCount * 2) // 10 for create, 10 for delete

	// Concurrent folder creation
	for i := 0; i < goroutineCount; i++ {
		go func(id int) {
			defer wg.Done()
			// Random sleep to increase race condition likelihood
			time.Sleep(time.Duration(id) * 10 * time.Millisecond)
			err := fs.CreateFolder(testFolder)
			if err != nil {
				t.Errorf("Goroutine %d: failed to create folder: %v", id, err)
			}
		}(i)
	}

	// Concurrent folder deletion
	for i := 0; i < goroutineCount; i++ {
		go func(id int) {
			defer wg.Done()
			// Random sleep to increase race condition likelihood
			time.Sleep(time.Duration(id) * 20 * time.Millisecond)
			err := fs.DeleteFolder(testFolder, maxDepth)
			if err != nil && !os.IsNotExist(err) {
				t.Errorf("Goroutine %d: failed to delete folder: %v", id, err)
			}
		}(i)
	}

	// Wait for all goroutines to finish
	wg.Wait()

	// Final check: folder should not exist
	if _, err := os.Stat(testFolder); !os.IsNotExist(err) {
		t.Errorf("Expected folder %s to be deleted, but it still exists", testFolder)
	}
}

// TestSaveGetDeleteFile tests the SaveFile, GetFile, and DeleteFile functionalities end-to-end.
func TestSaveGetDeleteFile(t *testing.T) {
	fs := New()

	// Set up the test environment
	err := setupTestEnvironment()
	if err != nil {
		t.Fatalf("Failed to set up test environment: %v", err)
	}
	defer cleanupTestEnvironment()

	// Prepare test data
	filePath := filepath.Join(testRootFolder, "test_file.dat")
	initialContent := [][]byte{
		[]byte("block1"),
		[]byte("block2"),
		[]byte("block3"),
	}

	// Test 1: Save file with initial content (append = false)
	err = fs.SaveFile(filePath, initialContent, false)
	if err != nil {
		t.Fatalf("Failed to save file with initial content: %v", err)
	}

	// Ensure file exists
	if _, err := os.Stat(filePath); os.IsNotExist(err) {
		t.Fatalf("Expected file %s to be created, but it does not exist", filePath)
	}

	// Test 2: Read file and verify content
	readContent, err := fs.GetFile(filePath)
	if err != nil {
		t.Fatalf("Failed to get file content: %v", err)
	}
	if !compareContent(initialContent, readContent) {
		t.Errorf("Content mismatch: expected %v, got %v", initialContent, readContent)
	}

	// Test 3: Overwrite file with new content (append = false)
	newContent := [][]byte{
		[]byte("new_block1"),
		[]byte("new_block2"),
	}
	err = fs.SaveFile(filePath, newContent, false)
	if err != nil {
		t.Fatalf("Failed to overwrite file content: %v", err)
	}

	// Verify content after overwrite
	readContent, err = fs.GetFile(filePath)
	if err != nil {
		t.Fatalf("Failed to get file content after overwrite: %v", err)
	}
	if !compareContent(newContent, readContent) {
		t.Errorf("Content mismatch after overwrite: expected %v, got %v", newContent, readContent)
	}

	// Test 4: Append new blocks (append = true)
	appendContent := [][]byte{
		[]byte("appended_block1"),
		[]byte("appended_block2"),
	}
	err = fs.SaveFile(filePath, appendContent, true)
	if err != nil {
		t.Fatalf("Failed to append to file: %v", err)
	}

	// Verify final content after append
	expectedContent := append(newContent, appendContent...)
	readContent, err = fs.GetFile(filePath)
	if err != nil {
		t.Fatalf("Failed to get file content after append: %v", err)
	}
	if !compareContent(expectedContent, readContent) {
		t.Errorf("Content mismatch after append: expected %v, got %v", expectedContent, readContent)
	}

	// Test 5: Delete file
	err = fs.DeleteFile(filePath)
	if err != nil {
		t.Fatalf("Failed to delete file: %v", err)
	}

	// Ensure file is deleted
	if _, err := os.Stat(filePath); !os.IsNotExist(err) {
		t.Errorf("Expected file %s to be deleted, but it still exists", filePath)
	}
}

// compareContent compares two [][]byte slices for deep equality.
func compareContent(content1, content2 [][]byte) bool {
	if len(content1) != len(content2) {
		return false
	}
	for i := range content1 {
		if !bytes.Equal(content1[i], content2[i]) {
			return false
		}
	}
	return true
}

// generateTestContent returns a simple generated set of binary blocks for testing.
func generateTestContent(blocks int, baseValue int) [][]byte {
	content := make([][]byte, blocks)
	for i := 0; i < blocks; i++ {
		content[i] = []byte{byte(baseValue), byte(i)}
	}
	return content
}

// TestGetFileSize verifies the correctness of the GetFileSize function,
// including compressed size accuracy and error handling for edge cases.
func TestGetFileSize(t *testing.T) {

	compressorInterface := compressor.New(compressor.Snappy)
	fs := New()

	// Set up test environment
	err := setupTestEnvironment()
	if err != nil {
		t.Fatalf("Failed to set up test environment: %v", err)
	}
	defer cleanupTestEnvironment()

	// Create a test folder
	testFolder := filepath.Join(testRootFolder, "file_size_test")
	err = fs.CreateFolder(testFolder)
	if err != nil {
		t.Fatalf("Failed to create test folder: %v", err)
	}

	// 1. Test: Create files with known content and verify their compressed size
	fileContents := map[string][][]byte{
		"file1.dat": generateTestContent(10, 1), // 10 blocks
		"file2.dat": generateTestContent(20, 2), // 20 blocks
		"file3.dat": generateTestContent(5, 3),  // 5 blocks
	}

	for fileName, content := range fileContents {
		// Save file
		filePath := filepath.Join(testFolder, fileName)
		err = fs.SaveFile(filePath, content, false)
		if err != nil {
			t.Fatalf("Failed to save file %s: %v", fileName, err)
		}

		// Compute expected compressed size
		compressedContent, err := compressorInterface.Compress(flattenContent(content))
		if err != nil {
			t.Fatalf("Failed to compress content for %s: %v", fileName, err)
		}
		expectedSize := int64(len(compressedContent))

		// Get actual file size
		size, err := fs.GetFileSize(filePath)
		if err != nil {
			t.Errorf("Failed to get file size for %s: %v", fileName, err)
		}
		if size != expectedSize {
			t.Errorf("File size mismatch for %s: expected %d bytes (compressed), got %d bytes", fileName, expectedSize, size)
		}
	}

	// 2. Test: Create and check the size of an empty file
	emptyFilePath := filepath.Join(testFolder, "empty_file.dat")
	_, err = os.Create(emptyFilePath)
	if err != nil {
		t.Fatalf("Failed to create empty file: %v", err)
	}

	size, err := fs.GetFileSize(emptyFilePath)
	if err != nil {
		t.Errorf("Failed to get file size for empty file: %v", err)
	}
	if size != 0 {
		t.Errorf("File size mismatch for empty file: expected 0 bytes, got %d bytes", size)
	}

	// 3. Test: Try to get size of a non-existent file
	nonExistentFile := filepath.Join(testFolder, "non_existent_file.dat")
	_, err = fs.GetFileSize(nonExistentFile)
	if err == nil {
		t.Errorf("Expected error for non-existent file %s, but got nil", nonExistentFile)
	}
}

// flattenContent prepares [][]byte data into a single binary slice,
// encoding length headers for compression or write operations.
func flattenContent(content [][]byte) []byte {
	var flattened []byte
	for _, part := range content {
		flattened = append(flattened, encodeBinaryLength(part)...)
		flattened = append(flattened, part...)
	}
	return flattened
}

// TestDeleteAllFiles tests the DeleteAllFiles method across multiple edge cases.
func TestDeleteAllFiles(t *testing.T) {
	fs := New()

	// Set up the test environment
	err := setupTestEnvironment()
	if err != nil {
		t.Fatalf("Failed to set up test environment: %v", err)
	}
	defer cleanupTestEnvironment()

	// Create test folder
	testFolder := filepath.Join(testRootFolder, "delete_all_files_test")
	err = fs.CreateFolder(testFolder)
	if err != nil {
		t.Fatalf("Failed to create test folder: %v", err)
	}

	// 1. Test: Delete all files in a folder
	files := []string{"file1.txt", "file2.log", "file3.dat", "file4.bin", "file5.tmp"}
	for _, file := range files {
		filePath := filepath.Join(testFolder, file)
		err := os.WriteFile(filePath, []byte("test content"), os.ModePerm)
		if err != nil {
			t.Fatalf("Failed to create file %s: %v", filePath, err)
		}
	}

	err = fs.DeleteAllFiles(testFolder)
	if err != nil {
		t.Errorf("Failed to delete all files in folder %s: %v", testFolder, err)
	}

	for _, file := range files {
		filePath := filepath.Join(testFolder, file)
		if _, err := os.Stat(filePath); !os.IsNotExist(err) {
			t.Errorf("Expected file %s to be deleted, but it still exists", filePath)
		}
	}

	// 2. Test: Empty folder handling
	emptyFolder := filepath.Join(testFolder, "empty_folder")
	err = fs.CreateFolder(emptyFolder)
	if err != nil {
		t.Fatalf("Failed to create empty test folder: %v", err)
	}

	err = fs.DeleteAllFiles(emptyFolder)
	if err != nil {
		t.Errorf("Failed to delete all files in empty folder %s: %v", emptyFolder, err)
	}

	if _, err := os.Stat(emptyFolder); os.IsNotExist(err) {
		t.Errorf("Expected empty folder %s to exist, but it was deleted", emptyFolder)
	}

	// 3. Test: Subfolder preservation
	subFolder := filepath.Join(testFolder, "subfolder")
	err = fs.CreateFolder(subFolder)
	if err != nil {
		t.Fatalf("Failed to create subfolder: %v", err)
	}
	subFile := filepath.Join(subFolder, "subfile.txt")
	err = os.WriteFile(subFile, []byte("subfolder content"), os.ModePerm)
	if err != nil {
		t.Fatalf("Failed to create subfile %s: %v", subFile, err)
	}

	rootFile := filepath.Join(testFolder, "rootfile.txt")
	err = os.WriteFile(rootFile, []byte("root file content"), os.ModePerm)
	if err != nil {
		t.Fatalf("Failed to create root file %s: %v", rootFile, err)
	}

	err = fs.DeleteAllFiles(testFolder)
	if err != nil {
		t.Errorf("Failed to delete all files in folder %s: %v", testFolder, err)
	}

	if _, err := os.Stat(rootFile); !os.IsNotExist(err) {
		t.Errorf("Expected root file %s to be deleted, but it still exists", rootFile)
	}
	if _, err := os.Stat(subFolder); os.IsNotExist(err) {
		t.Errorf("Expected subfolder %s to exist, but it was deleted", subFolder)
	}
	if _, err := os.Stat(subFile); os.IsNotExist(err) {
		t.Errorf("Expected file %s inside subfolder to exist, but it was deleted", subFile)
	}

	// 4. Test: Non-existent folder handling
	nonExistentFolder := filepath.Join(testRootFolder, "non_existent_folder")
	err = fs.DeleteAllFiles(nonExistentFolder)
	if err != nil {
		t.Errorf("Expected no error for non-existent folder %s, but got: %v", nonExistentFolder, err)
	}

	// 5. Test: Delete files with various extensions
	fileFormats := []string{"file1.txt", "file2.log", "file3.csv", "file4.json", "file5.xml"}
	for _, file := range fileFormats {
		filePath := filepath.Join(testFolder, file)
		err := os.WriteFile(filePath, []byte("format test content"), os.ModePerm)
		if err != nil {
			t.Fatalf("Failed to create file %s: %v", filePath, err)
		}
	}

	err = fs.DeleteAllFiles(testFolder)
	if err != nil {
		t.Errorf("Failed to delete all files in folder %s: %v", testFolder, err)
	}

	for _, file := range fileFormats {
		filePath := filepath.Join(testFolder, file)
		if _, err := os.Stat(filePath); !os.IsNotExist(err) {
			t.Errorf("Expected file %s to be deleted, but it still exists", filePath)
		}
	}
}

--------------------------------------------------------------------------------

/==============================================================================\
| FILE: core\hydra\gobber\go_test.go
| PATH: C:\go\src\hydraide\app\core\hydra\gobber\go_test.go
| SIZE: 1.8 KB
\==============================================================================/

package gobber

import (
	"reflect"
	"testing"
)

// Serialize and Deserialize functions from the previous example

// A test struct to demonstrate nested serialization
type TestStruct struct {
	Name   string
	Values []int
	Nested struct {
		Flag    bool
		Message string
	}
}

func TestSerialization(t *testing.T) {
	// Test cases
	cases := []struct {
		name     string
		input    interface{}
		expected interface{}
	}{
		{
			name:     "Slice of ints",
			input:    []int{1, 2, 3, 4, 5},
			expected: []int{1, 2, 3, 4, 5},
		},
		{
			name: "Nested struct",
			input: TestStruct{
				Name:   "Test",
				Values: []int{5, 4, 3, 2, 1},
				Nested: struct {
					Flag    bool
					Message string
				}{Flag: true, Message: "Nested message"},
			},
			expected: TestStruct{
				Name:   "Test",
				Values: []int{5, 4, 3, 2, 1},
				Nested: struct {
					Flag    bool
					Message string
				}{Flag: true, Message: "Nested message"},
			},
		},
	}

	for _, tc := range cases {
		t.Run(tc.name, func(t *testing.T) {
			// Serialize the input
			serializedData, err := Serialize(tc.input)
			if err != nil {
				t.Fatalf("Failed to serialize %v: %v", tc.input, err)
			}

			// Prepare a variable of the expected type
			resultPtr := reflect.New(reflect.TypeOf(tc.expected)).Interface()

			// Deserialize into the new variable
			if err := Deserialize(serializedData, resultPtr); err != nil {
				t.Fatalf("Failed to deserialize into %T: %v", resultPtr, err)
			}

			// Dereference the pointer to get the result
			result := reflect.ValueOf(resultPtr).Elem().Interface()

			// Compare the deserialized data to the expected data
			if !reflect.DeepEqual(result, tc.expected) {
				t.Errorf("Deserialized data (%v) does not match expected data (%v)", result, tc.expected)
			}
		})
	}
}

--------------------------------------------------------------------------------

/==============================================================================\
| FILE: core\hydra\gobber\gobber.go
| PATH: C:\go\src\hydraide\app\core\hydra\gobber\gobber.go
| SIZE: 1.5 KB
\==============================================================================/

// Package gobber provides functions for serializing and deserializing Go objects using the Gob encoding format.
// Gob encoding is a way to convert Go data structures into a stream of bytes for transmission or storage,
// and then back into data structures again.
// This package offers two main functions: Serialize, which serializes any Go object into a byte slice,
// and Deserialize, which deserializes a byte slice back into a Go object.
// These functions are useful for efficiently transmitting and storing data in Go applications.
package gobber

import (
	"bytes"
	"encoding/gob"
)

// Serialize takes any object and returns a byte slice.
func Serialize(data interface{}) ([]byte, error) {
	// Create a buffer to store the serialized data
	var buffer bytes.Buffer

	// Initialize a new encoder with the buffer
	encoder := gob.NewEncoder(&buffer)

	// Encode the data into the buffer
	err := encoder.Encode(data)
	if err != nil {
		return nil, err
	}

	// Return the content of the buffer as a byte slice
	return buffer.Bytes(), nil
}

// Deserialize takes a byte slice and a pointer to an object,
// and fills the object with the deserialized data.
func Deserialize(data []byte, obj interface{}) error {
	// Create a buffer and fill it with the serialized data
	buffer := bytes.NewBuffer(data)

	// Initialize a new decoder with the buffer
	decoder := gob.NewDecoder(buffer)

	// Decode the data from the buffer into the provided object
	err := decoder.Decode(obj)
	if err != nil {
		return err
	}

	return nil
}

--------------------------------------------------------------------------------

/==============================================================================\
| FILE: core\hydra\hydra.go
| PATH: C:\go\src\hydraide\app\core\hydra\hydra.go
| SIZE: 36.1 KB
\==============================================================================/

package hydra

import (
	"context"
	"errors"
	"github.com/google/uuid"
	"github.com/hydraide/hydraide/app/core/filesystem"
	"github.com/hydraide/hydraide/app/core/hydra/lock"
	"github.com/hydraide/hydraide/app/core/hydra/swamp"
	"github.com/hydraide/hydraide/app/core/hydra/swamp/chronicler"
	"github.com/hydraide/hydraide/app/core/hydra/swamp/metadata"
	"github.com/hydraide/hydraide/app/core/safeops"
	"github.com/hydraide/hydraide/app/core/settings"
	"github.com/hydraide/hydraide/app/core/settings/setting"
	"github.com/hydraide/hydraide/app/name"
	"log/slog"
	"strings"
	"sync"
	"sync/atomic"
	"time"
)

type Hydra interface {

	// GetLocker returns the locker interface
	GetLocker() lock.Lock

	// SummonSwamp retrieves a single Swamp object based on its deterministic Island location,
	// and loads all associated Treasures from disk into memory.
	//
	// Parameters:
	// - `islandID`: the ID of the Island (i.e. top-level storage folder) where the Swamp physically resides.
	//               This ID is always provided by the client. It is deterministically computed from the full Swamp name
	//               (Sanctuary / Realm / Swamp) using a fixed hash function. It is not the HydrAIDE server's
	//               responsibility to calculate this value.
	// - `swampName`: the unique logical name of the Swamp.
	//
	// 🧭 Why does the IslandID come from the client?
	// - The routing logic is entirely client-driven: only the client computes the IslandID via hashing.
	// - This ensures that the HydrAIDE server remains stateless and does not make routing decisions.
	// - The same Swamp name will always map to the same IslandID, enabling deterministic access.
	//
	// 🏝️ Why is this important for scaling?
	// - Islands are the smallest physical storage units in HydrAIDE.
	// - They can be freely moved between servers (e.g. via rsync or ZFS) to balance load.
	// - Once moved, only the client’s IslandID → server mapping needs to change — Swamp names remain untouched.
	// - This allows orchestrator-free horizontal scaling and seamless server rebalancing.
	//
	// 💾 Behavior:
	// - If the Swamp is already in memory, the existing instance is returned.
	// - Otherwise, the function uses the provided IslandID and SwampName to construct the disk path,
	//   loads all associated Treasures, and returns the hydrated Swamp.
	//
	// Returns:
	// - A `swamp.Swamp` interface to interact with the loaded Swamp
	// - An error if the Swamp is missing or invalid
	//
	// Example:
	//
	//     island := swampName.GetIslandID(1000)
	//     mySwamp, err := myHydra.SummonSwamp(ctx, island, swampName)
	//     if err != nil {
	//         log.Fatal(err)
	//     }
	//
	//     // Interact with Swamp and its Treasures fully loaded into memory
	SummonSwamp(ctx context.Context, islandID uint64, swampName name.Name) (swampObj swamp.Swamp, err error)

	// IsExistSwamp checks whether the specified Swamp physically exists in the system.
	// This function does not load the Swamp into memory and does not create a new Swamp if it is missing —
	// it performs a non-intrusive existence check, either in-memory or on-disk.
	//
	// Parameters:
	// - `islandID`: the deterministic storage location (Island) where the Swamp is expected to reside.
	//               This must be computed on the client side using the full Swamp name.
	//               See the `SummonSwamp` function for detailed explanation on IslandID usage.
	// - `swampName`: the logical name of the Swamp to check.
	//
	// Returns:
	// - `true` if the Swamp exists (either in memory or on disk)
	// - `false` if the Swamp does not exist
	// - An error if an access or I/O issue occurs
	//
	// Example:
	//
	//     island := swampName.GetIslandID(1000)
	//     exists, err := myHydra.IsExistSwamp(island, swampName)
	//     if err != nil {
	//         log.Fatal(err)
	//     }
	//     if exists {
	//         // Swamp exists
	//     } else {
	//         // Swamp does not exist
	//     }
	IsExistSwamp(islandID uint64, swampName name.Name) (bool, error)

	// SubscribeToSwampEvents enables a Head to subscribe to events from a specific Swamp using a callback function,
	// allowing real-time monitoring or triggering business logic. This is a NON blocking function.
	//
	// This function takes three parameters:
	// - clientID of type uuid.UUID: Uniquely identifies the subscribing Head.
	// - swampName of type name.Name: Specifies the Swamp whose events the Head is interested in.
	// - subscriberEventCallbackFunction of type func(event *swamp.Event): A callback function that is invoked with each event related to the specified Swamp.
	//
	// Once subscribed, the provided callback function is executed in real-time whenever an event occurs in the specified Swamp.
	// This approach simplifies handling events by abstracting away channel management.
	//
	// Example:
	//
	//     myCallback := func(event *swamp.Event) {
	//         // Handle the received event
	//         ...
	//     }
	//
	//     // Subscribe to events of a specific Swamp
	//     err := myHydra.SubscribeToSwampEvents(uuid.New(), name.New("someSwamp"), myCallback)
	//     if err != nil {
	//         // Handle subscription error
	//         ...
	//     }
	//
	// Returns:
	// - An error value: Returns nil if the subscription was successful, otherwise returns an error detailing the issue.
	//
	// Use-cases:
	// 1. Real-time monitoring of a specific Swamp, enabling a Head to react quickly to changes.
	// 2. Triggering other business logic or actions based on events occurring within a Swamp.
	SubscribeToSwampEvents(clientID uuid.UUID, swampName name.Name, subscriberEventCallbackFunction func(event *swamp.Event)) (err error)

	// UnsubscribeFromSwampEvents allows a Head to unsubscribe from events of a specific Swamp, effectively stopping
	// real-time monitoring or triggering of business logic based on those events.
	//
	// This function takes two parameters:
	// - clientID of type uuid.UUID to uniquely identify the unsubscribing Head.
	// - swampName of type name.Name to specify which Swamp's events the Head wants to unsubscribe from.
	//
	// Once unsubscribed, the Head will no longer receive any events related to the specified Swamp. This is useful
	// when a Head no longer needs to monitor the Swamp, or when business logic tied to the Swamp's events is no longer relevant.
	//
	// Example:
	//
	//     // Unsubscribe from events of a specific Swamp
	//     myHydra.UnsubscribeFromSwampEvents(myExistingUUID, name.New("someSwamp"))
	//
	//     // The Head will no longer receive events from the specified Swamp
	//
	// Returns:
	// - No direct return value; the Head will stop receiving events related to the specified Swamp.
	//
	// Use-cases:
	// 1. Ending real-time monitoring of a specific Swamp when it's no longer needed.
	// 2. Preventing unnecessary triggering of business logic or actions that were previously dependent on the Swamp's events.
	//
	// It's in our interest to manage resources efficiently; unsubscribing when monitoring is no longer necessary helps in resource optimization.
	UnsubscribeFromSwampEvents(clientID uuid.UUID, swampName name.Name) (err error)

	// SubscribeToSwampInfo allows a Head to subscribe to specific updates about the state of a given Swamp, particularly
	// changes in the number of Treasures stored within.
	//
	// This function takes three parameters:
	// - clientID of type uuid.UUID: Uniquely identifies the subscribing Head.
	// - swampName of type name.Name: Specifies the Swamp whose state updates the Head wants to receive.
	// - subscriberInfoCallbackFunction of type func(info *swamp.Info): A callback function that is invoked whenever a significant state change occurs.
	//
	// The function provides updates only when the total number of Treasures in the Swamp decreases or becomes zero.
	// This approach ensures performance optimization by limiting notifications to significant changes.
	//
	// If a Swamp with 100 Treasures is destroyed, the last update will indicate that the total count of Treasures is now zero.
	// The subscriber will not be notified of each individual Treasure being destroyed.
	//
	// Example:
	//
	//     myCallback := func(info *swamp.Info) {
	//         // Process the new info update
	//         ...
	//     }
	//
	//     // Subscribe to information updates of a specific Swamp
	//     err := myHydra.SubscribeToSwampInfo(uuid.New(), name.New("someSwamp"), myCallback)
	//     if err != nil {
	//         // Handle subscription error
	//         ...
	//     }
	//
	// Returns:
	// - An error value: Returns nil if the subscription was successful, otherwise returns an error detailing the issue.
	//
	// Use-cases:
	// 1. Real-time analytics related to the Swamp.
	// 2. Dashboard updates to reflect changes in the Swamp's state.
	//
	// It's in our interest to ensure performance efficiency; limiting updates to only significant changes in the Swamp helps achieve this.
	SubscribeToSwampInfo(clientID uuid.UUID, swampName name.Name, subscriberInfoCallbackFunction func(info *swamp.Info)) (err error)

	// UnsubscribeFromSwampInfo allows a Head to unsubscribe from receiving updates about a specific Swamp's state.
	//
	// Parameters:
	// - clientID of type uuid.UUID: Uniquely identifies the unsubscribing Head.
	// - swampName of type name.Name: Specifies which Swamp the Head wants to stop receiving updates about.
	//
	// This function is particularly useful for performance optimization and resource management. Once a Head is unsubscribed,
	// it will no longer receive updates from the specified Swamp, freeing up computational and network resources.
	//
	// Example:
	//
	//     // Unsubscribe from updates of a specific Swamp
	//     myHydra.UnsubscribeFromSwampInfo(myExistingUUID, name.NewName("someSwamp"))
	//
	// Returns:
	// - No direct return value; stops updates from being sent to the Head for the specified Swamp.
	//
	// Use-cases:
	// 1. To stop receiving real-time analytics when no longer required.
	// 2. To manage resources effectively by unsubscribing from Swamps that are no longer of interest.
	//
	// Unsubscribing a Head when updates are no longer needed is in our interest to maintain efficient system performance.
	UnsubscribeFromSwampInfo(clientID uuid.UUID, swampName name.Name) (err error)

	// ListActiveSwamps retrieves and returns a list of currently active Swamps within the system.
	//
	// Parameters: None
	//
	// This function scans the internal data structures to identify Swamps that are currently in an active state,
	// meaning they are either engaged in data processing or are available for task assignment.
	//
	// Example:
	//
	//     // Retrieve the list of active swamps
	//     activeSwamps := myHydra.ListActiveSwamps()
	//
	// Returns:
	// - []string: An array of strings, where each string is the name or identifier of an active Swamp.
	//
	// Use-cases:
	// 1. To monitor the system's current state for debugging or analytical purposes.
	// 2. To identify which Swamps are available for immediate task assignments.
	// 3. To generate reports or dashboards that provide insights into system performance and utilization.
	//
	// Utilizing the ListActiveSwamps function is in our interest when we want to gain visibility into
	// the operational state of our Swamps, thereby enhancing our ability to manage resources and tasks effectively.
	ListActiveSwamps() []string

	// CountActiveSwamps calculates and returns the total number of currently active Swamps in the system.
	//
	// Parameters: None
	//
	// This function is responsible for iterating through the system's internal data structures to count
	// the number of Swamps that are currently active, meaning they are either processing tasks or are ready for new assignments.
	//
	// Example:
	//
	//     // Retrieve the count of active swamps
	//     activeSwampCount := myHydra.CountActiveSwamps()
	//
	// Returns:
	// - int: The total number of active Swamps as an integer.
	//
	// Use-cases:
	// 1. For real-time monitoring of system resource utilization.
	// 2. To help with load balancing decisions by gauging the system’s capacity.
	// 3. To quickly assess the need for scaling the system up or down based on active Swamps.
	//
	// Utilizing the CountActiveSwamps function is in our interest for effective resource allocation and system monitoring,
	// ensuring that we can respond swiftly to changing operational conditions.
	CountActiveSwamps() int

	// GracefulStop cleanly shuts down the server by finishing all ongoing processes and freeing up resources.
	//
	// Important: DO NOT CALL THIS FUNCTION DIRECTLY.
	//
	// This method is invoked automatically by the graceful stop package whenever the server is shutting down.
	// It ensures that all active connections are closed, ongoing tasks are completed, and resources are released,
	// thus enabling a graceful termination of the application.
	//
	// Use-cases:
	// 1. To ensure that no data is lost or corrupted during unplanned shutdowns.
	// 2. To maintain system integrity by safely concluding any in-flight transactions.
	// 3. To prevent abrupt termination that might cause issues in interconnected services or databases.
	//
	// Employing GracefulStop is in our interest as it allows us to maintain high availability and reliability
	// in our services, ensuring a seamless user experience even during maintenance periods.
	GracefulStop()
}

const (
	ErrorHydraIsShuttingDown = "hydra is shutting down"
)

type hydra struct {
	mu           sync.RWMutex
	shuttingDown int32 // Hydra shutting down flag

	// maps that we need to protect by mutexes
	// swamps           map[string]swamp.Swamp
	swamps sync.Map
	// eventSubscribers map[string]map[uuid.UUID]chan *swamp.Event
	eventSubscribers sync.Map
	// infoSubscribers  map[string]map[uuid.UUID]chan *swamp.Info
	infoSubscribers sync.Map

	// summoningSwamps csak olyan swampokat tárol, amiket éppen summonolunk, hogy két rutin ne summonolhassa ugyanazt
	// a swampot, különben képesek lennének egyszerre létrehozni, ugyanazt a swampot. Így ha az egyik summonolja a swampot,
	// akkor meg kell várja a másik, hogy az első visszakapja azt.
	summoningSwamps sync.Map

	// interfaces
	elysiumInterface  safeops.Safeops
	settingsInterface settings.Settings

	// channels
	eventChannel      chan *swamp.Event
	closeEventChannel chan name.Name
	infoChannel       chan *swamp.Info
	// egyedi locker interface
	lockerInterface     lock.Lock
	filesystemInterface filesystem.Filesystem
}

// New creates a new hydra database
func New(settingsInterface settings.Settings, elysiumInterface safeops.Safeops,
	lockerInterface lock.Lock, filesystemInterface filesystem.Filesystem) Hydra {

	h := &hydra{
		// set interfaces
		settingsInterface: settingsInterface,
		elysiumInterface:  elysiumInterface,
		// set channels
		eventChannel:      make(chan *swamp.Event, 100000),
		closeEventChannel: make(chan name.Name, 100000),
		infoChannel:       make(chan *swamp.Info, 100000),

		// set locker interface
		lockerInterface:     lockerInterface,
		filesystemInterface: filesystemInterface,
	}

	return h

}

// GetLocker returns the locker interface
func (h *hydra) GetLocker() lock.Lock {
	return h.lockerInterface
}

// SwampWaiter struct-t használjuk a swampokra várakozásra
type SwampWaiter struct {
	cond  *sync.Cond
	ready bool
	count int32 // store the number of waiting goroutines
}

func newSwampWaiter() *SwampWaiter {
	return &SwampWaiter{
		cond:  sync.NewCond(&sync.Mutex{}),
		ready: false,
	}
}

// SummonSwamp creates a new swamp or returns the existing one
// mutexes: clean
func (h *hydra) SummonSwamp(ctx context.Context, islandID uint64, swampName name.Name) (swampObj swamp.Swamp, err error) {

	if atomic.LoadInt32(&h.shuttingDown) == 1 {
		return nil, errors.New(ErrorHydraIsShuttingDown)
	}

	// the swamp is actually summoning, so we need to wait for the other process to finish the summoning process
	// to prevent the same swamp to be summoned or created twice...
	// if the ok is true then the swamp is already summoning, so we need to wait for the other process to finish the summoning process
	// if the ok is false then the swamp is not summoning, so we can start the summoning process and store the swamp in the map
	// immediately
	result, _ := h.summoningSwamps.LoadOrStore(swampName.Get(), newSwampWaiter())
	waiter, _ := result.(*SwampWaiter)

	// lezárjuk a következő kódrészt, így csak egyetlen rutin futhatja egyszerre egy domain néven belül
	waiter.cond.L.Lock()
	for waiter.ready {
		select {
		case <-ctx.Done():
			// Ha a kontextus megszakad, jelezzük a többi várakozó goroutinnak, hogy ne várjanak tovább
			waiter.cond.Broadcast()
			waiter.cond.L.Unlock()
			return nil, ctx.Err() // Visszatérünk a kontextus hibaüzenetével
		default:
			atomic.AddInt32(&waiter.count, 1)
			waiter.cond.Wait()
		}
	}
	waiter.ready = true
	waiter.cond.L.Unlock()

	defer func() {
		// Swamp véglegesítése után
		waiter.cond.L.Lock()
		waiter.ready = false
		waiter.cond.Broadcast() // Értesítjük a többi várakozót
		waiter.cond.L.Unlock()
		// csökkentjük a várakozó goroutinok számát
		atomic.AddInt32(&waiter.count, -1)
		// ha nincs több várakozó goroutin, akkor töröljük a várakozó mapből a swampot
		if atomic.LoadInt32(&waiter.count) == 0 {
			h.summoningSwamps.Delete(swampName.Get())
		}
	}()

	var swampObject swamp.Swamp

	for {
		select {
		case <-ctx.Done():

			// we can not wait the summoning to finish, because the caller context is done
			// maybe this is a very long-running process, and the caller context is done meanwhile
			slog.Warn("the summoning context is done, summoning is cancelled", "swampName", swampName)

			return nil, errors.New("context is done")

		default:

			// get the info object of the swamp
			swampObject = h.getSwamp(swampName)

			// is the swamp is existing in the hydra
			if swampObject != nil {

				// existing, but it is closing now, so we need to wait for the closing
				// after the closing, the swamp object will be nil, and we will create a new swamp again
				// waiting for the swamp to be closed and deleted from the hydra's map
				// after the closing, the swamp object will be nil, and we will create a new swamp
				// Calling the IsClosing function – if it returns false, it prevents the swamp from closing immediately,
				// giving the caller time to set the BeginVigil instruction so that the swamp doesn't close
				// during the transaction.
				if swampObject.IsClosing() {

					var swampCloseError error

					// We wait until the swamp is removed from the hydra map, so that we can
					// summon it again later. This is a blocking function and will only release
					// once the swamp has been successfully closed.

					func() {

						// For safety reasons, we only wait a maximum of 30 seconds for the swamp to close.
						// If it doesn't close within this time, the swamp must be discarded, as it can't be safely shut down.
						waitingCtx, cancelFunc := context.WithTimeout(context.Background(), 30*time.Second)
						defer cancelFunc()

						// There are two cases where an error may occur:
						// 1. If the waitingCtx is done, which would indicate the swamp couldn't close within 30 seconds.
						// 2. If the swamp is not closing at all, for some reason.
						// In both cases, the swamp must be discarded, as it cannot be closed and the code cannot proceed.
						if closeErr := swampObject.WaitForGracefulClose(waitingCtx); closeErr != nil {
							slog.Error("the swamp can not be closed in 30 seconds, so we need to drop it", "swampName", swampName, "closeError", closeErr)
							swampCloseError = err
							return
						}

					}()

					// Return with an error, because closing took too long — this is a critical failure,
					// and this swamp cannot be summoned again.
					if swampCloseError != nil {
						return nil, swampCloseError
					}

					// No error occurred, the swamp has been successfully closed,
					// so we can move on and begin summoning it again.
					continue

				}

				return swampObject, nil

			}

			// The swamp does not exist in memory, so we need to create it.
			// During creation, other processes trying to access this swamp will still have to wait.
			swampObject = h.createNewSwamp(islandID, swampName)

			// Store the swamp in the hydra map, which is a sync.Map.
			h.swamps.Store(swampName.Get(), swampObject)

			// start sending events to the subscribers if there are any clients subscribed to the events
			if h.hasEventSubscriber(swampName) {
				swampObject.StartSendingEvents()
			}

			// start sending information to the subscribers if there are any clients subscribed to the information
			if h.hasInfoSubscriber(swampName) {
				swampObject.StartSendingInformation()
			}

			return swampObject, nil

		}

	}

}

// IsExistSwamp checks if the swamp is existing in the hydras map or in the filesystem
// mutexes: clean
func (h *hydra) IsExistSwamp(islandID uint64, swampName name.Name) (bool, error) {

	if atomic.LoadInt32(&h.shuttingDown) == 1 {
		return false, errors.New(ErrorHydraIsShuttingDown)
	}

	if h.getSwamp(swampName) != nil {
		return true, nil
	}

	// Construct the full path to the swamp's directory.
	swampDataFolderPath := swampName.GetFullHashPath(h.settingsInterface.GetHydraAbsDataFolderPath(), islandID, h.settingsInterface.GetHashFolderDepth(), h.settingsInterface.GetMaxFoldersPerLevel())

	return h.filesystemInterface.IsFolderExists(swampDataFolderPath), nil

}

// ListActiveSwamps returns the list of opened and active swamps
// mutexes: clean
func (h *hydra) ListActiveSwamps() []string {
	var swampNames []string
	h.swamps.Range(func(key, value interface{}) bool {
		swampNames = append(swampNames, key.(string))
		return true
	})
	return swampNames
}

// CountActiveSwamps count the number of opened and active swamps
// mutexes: clean
func (h *hydra) CountActiveSwamps() int {
	elements := 0
	h.swamps.Range(func(key, value interface{}) bool {
		elements++
		return true
	})
	return elements
}

// SubscribeToSwampInfo subscribes to the information channel of the swamp
// mutexes: clean
func (h *hydra) SubscribeToSwampInfo(clientID uuid.UUID, swampName name.Name, subscriberInfoCallbackFunction func(info *swamp.Info)) error {

	if atomic.LoadInt32(&h.shuttingDown) == 1 {
		return errors.New(ErrorHydraIsShuttingDown)
	}

	canonicalForm := swampName.Get()

	defer func() {
		// starts sending information if the swamp exists in the hydra
		if swampObject, ok := h.swamps.Load(canonicalForm); ok {
			swampObject.(swamp.Swamp).StartSendingInformation()
		}
	}()

	if subscribers, ok := h.infoSubscribers.Load(canonicalForm); ok {
		// Always overwrite the subscriber, since the channel may have changed as well.
		subscribers.(*sync.Map).Store(clientID.String(), subscriberInfoCallbackFunction)
		return nil
	}

	// there is no subscribers to this swamp yet
	subscribers := &sync.Map{}
	subscribers.Store(clientID.String(), subscriberInfoCallbackFunction)
	h.infoSubscribers.Store(canonicalForm, subscribers)

	return nil

}

// UnsubscribeFromSwampInfo unsubscribes the user from the information channel of the swamp
// mutexes: clean
func (h *hydra) UnsubscribeFromSwampInfo(clientID uuid.UUID, swampName name.Name) error {

	if atomic.LoadInt32(&h.shuttingDown) == 1 {
		return errors.New(ErrorHydraIsShuttingDown)
	}

	canonicalForm := swampName.Get()

	if subscribers, ok := h.infoSubscribers.Load(canonicalForm); ok {
		subscribers.(*sync.Map).Delete(clientID.String())
	}

	allSubscribers := 0
	h.infoSubscribers.Range(func(key, value interface{}) bool {
		allSubscribers++
		return true
	})

	// stops sending information if the swamp exists and there are no subscribers to information
	if allSubscribers == 0 {
		if swampObject, ok := h.swamps.Load(canonicalForm); ok {
			swampObject.(swamp.Swamp).StopSendingInformation()
		}
	}

	return nil

}

// SubscribeToSwampEvents subscribes to the events channel of the swamp
// mutexes: clean
func (h *hydra) SubscribeToSwampEvents(clientID uuid.UUID, swampName name.Name, subscriberEventCallbackFunction func(event *swamp.Event)) error {

	if atomic.LoadInt32(&h.shuttingDown) == 1 {
		return errors.New(ErrorHydraIsShuttingDown)
	}

	canonicalForm := swampName.Get()

	defer func() {
		// starts the sending events if the swamp exists
		if swampObject, ok := h.swamps.Load(canonicalForm); ok {
			swampObject.(swamp.Swamp).StartSendingEvents()
		}
	}()

	if subscribers, ok := h.eventSubscribers.Load(canonicalForm); ok {
		// Always overwrite the subscriber, since the channel may have changed as well.
		subscribers.(*sync.Map).Store(clientID.String(), subscriberEventCallbackFunction)
		return nil
	}

	// there is no subscribers to this swamp yet
	subscribers := &sync.Map{}
	subscribers.Store(clientID.String(), subscriberEventCallbackFunction)
	h.eventSubscribers.Store(canonicalForm, subscribers)

	return nil

}

// UnsubscribeFromSwampEvents unsubscribes the user from the events channel of the swamp
// mutexes: clean
func (h *hydra) UnsubscribeFromSwampEvents(clientID uuid.UUID, swampName name.Name) error {

	if atomic.LoadInt32(&h.shuttingDown) == 1 {
		return errors.New(ErrorHydraIsShuttingDown)
	}

	canonicalForm := swampName.Get()

	if subscribers, ok := h.eventSubscribers.Load(canonicalForm); ok {
		// ha létezik a subscriber, akkor töröljük azt a mapből
		if _, ok := subscribers.(*sync.Map).Load(clientID.String()); ok {
			subscribers.(*sync.Map).Delete(clientID.String())
		}
	}

	allSubscribers := 0
	h.eventSubscribers.Range(func(key, value interface{}) bool {
		allSubscribers++
		return true
	})

	// stops sending events if the swamp exists and there are no subscribers to events
	if allSubscribers == 0 {
		if swampObject, ok := h.swamps.Load(canonicalForm); ok {
			swampObject.(swamp.Swamp).StopSendingEvents()
		}
	}

	return nil

}

// GracefulStop close function for the graceful stop package
// DO NOT CALL THIS FUNCTION DIRECTLY
// the graceful stop package calls this function when the server is shutting down
// mutexes: clean
func (h *hydra) GracefulStop() {

	slog.Info("Graceful stop of the hydra executed")

	// set the shutting down flag to true and prevent the creation of new swamps
	// and all public functions will return error, because the hydra is shutting down
	atomic.StoreInt32(&h.shuttingDown, 1)

	// Remove all event and info subscribers to prevent them from waiting for new events or information
	// from Hydra. We close all subscriber channels, which notifies the subscribers accordingly.
	h.eventSubscribers = sync.Map{}
	h.infoSubscribers = sync.Map{}

	// start a new routine and close all swamps
	go h.tryToCloseAllSwamps()

	slog.Info("waiting for graceful stop")

	// wait until all swamps are closed then return
	iterationCounter := 0
	for {

		// check the opened swamps
		openedSwamps := h.CountActiveSwamps()

		slog.Info("opened swamps", "count", openedSwamps)

		// if there is no opened swamps and the there is no process that destroying swamps - kill the server
		if openedSwamps == 0 {
			slog.Info("all swamps are gracefully closed, hydra is shutting down")
			return
		}

		// if we can't close the swamp within 10 seconds....
		if iterationCounter >= 10 {

			slog.Error("can not close all swamps within 10 seconds, Force close all swamps", "activeSwamps", strings.Join(h.ListActiveSwamps(), ", "))

			go func() {
				// iterating over the swamps and close them
				h.swamps.Range(func(key, value interface{}) bool {

					s := value.(swamp.Swamp)

					s.StopSendingInformation()
					s.StopSendingEvents()

					// log the error, because we can't close the swamp
					slog.Error("the swamp still opened and try to write all treasures to the filesystem again",
						"swampName", s.GetName(),
						"swampIsClosing", s.IsClosing(),
						"allTreasures", s.CountTreasures(),
						"treasuresWaitingForWriter", s.CountTreasuresWaitingForWriter(),
						"isFileSystemInitiated", s.GetChronicler().IsFilesystemInitiated())

					// Write treasures to the filesystem
					s.WriteTreasuresToFilesystem()

					slog.Info("the swamp still opened and all treasures are written to the filesystem again, and try to close it again",
						"swampName", s.GetName(),
						"swampIsClosing", s.IsClosing(),
						"allTreasures", s.CountTreasures(),
						"treasuresWaitingForWriter", s.CountTreasuresWaitingForWriter(),
						"isFileSystemInitiated", s.GetChronicler().IsFilesystemInitiated())

					// try to close it again
					s.Close()

					slog.Info("the swamp is closed successfully",
						"swampName", s.GetName(),
						"swampIsClosing", s.IsClosing(),
						"allTreasures", s.CountTreasures(),
						"treasuresWaitingForWriter", s.CountTreasuresWaitingForWriter(),
						"isFileSystemInitiated", s.GetChronicler().IsFilesystemInitiated())

					return true

				})

			}()

			// waiting for 30 seconds then force close the server
			time.Sleep(30 * time.Second)

			return

		}

		iterationCounter++

		time.Sleep(1000 * time.Millisecond)

	}

}

func (h *hydra) tryToCloseAllSwamps() {

	slog.Info("try to closing all open swamps.....")

	// iterating over the swamps and close them
	h.swamps.Range(func(key, value interface{}) bool {

		// Stop it from sending any more information to the channel.
		// This is important in case there are still active subscribers.
		value.(swamp.Swamp).StopSendingInformation()
		value.(swamp.Swamp).StopSendingEvents()
		// close the swamp
		value.(swamp.Swamp).Close()

		return true

	})

}

// createNewSwamp creates a new swamp and adds it to the map
func (h *hydra) createNewSwamp(islandID uint64, swampName name.Name) swamp.Swamp {

	// get the setting of the swamp
	swampSettings := h.settingsInterface.GetBySwampName(swampName)

	swampDataFolderPath := swampName.GetFullHashPath(h.settingsInterface.GetHydraAbsDataFolderPath(), islandID, h.settingsInterface.GetHashFolderDepth(), h.settingsInterface.GetMaxFoldersPerLevel())

	// Instantiate the metadata based on the folder.
	metadataInterface := metadata.New(swampDataFolderPath)
	// Load the metadata from the file.
	metadataInterface.LoadFromFile()
	// Pass the swamp name to it.
	metadataInterface.SetSwampName(swampName)

	// create the new filesystem
	var fss *swamp.FilesystemSettings
	// init chronicler if the swamp is permanent-type
	if swampSettings.GetSwampType() == setting.PermanentSwamp {
		fss = &swamp.FilesystemSettings{}
		fss.ChroniclerInterface = h.loadChronicler(swampSettings, swampDataFolderPath, metadataInterface)
		fss.WriteInterval = swampSettings.GetWriteInterval()
	}

	// create the swamp with the filesystem
	return swamp.New(swampName, swampSettings.GetCloseAfterIdle(), fss, h.eventCallbackFunction, h.infoCallbackFunction, h.closeEventCallbackFunction, metadataInterface)

}

// loadChronicler loads the filesystem of the swamp or create a new one if it is not existing
func (h *hydra) loadChronicler(swampSettings setting.Setting, swampDataFolderPath string, metadataInterface metadata.Metadata) chronicler.Chronicler {

	// Construct the full path to the swamp's directory.
	maxFileSizeBytes := swampSettings.GetMaxFileSizeByte()

	// Create the file handler along with the metadata for the swamp.
	fs := chronicler.New(swampDataFolderPath, maxFileSizeBytes, h.settingsInterface.GetHashFolderDepth(), h.filesystemInterface, metadataInterface)
	fs.CreateDirectoryIfNotExists()

	return fs

}

// getSwamp returns the swamp itself from the map
func (h *hydra) getSwamp(swampName name.Name) (swampObject swamp.Swamp) {
	if swampObj, ok := h.swamps.Load(swampName.Get()); ok {
		s := swampObj.(swamp.Swamp)
		return s
	}
	return nil
}

// hasEventSubscriber checks if the swamp has any event subscribers
func (h *hydra) hasEventSubscriber(swampName name.Name) bool {

	canonicalForm := swampName.Get()

	if subscribers, ok := h.eventSubscribers.Load(canonicalForm); ok {
		eventSubscribers := 0
		subscribers.(*sync.Map).Range(func(key, value interface{}) bool {
			eventSubscribers++
			return true
		})
		if eventSubscribers > 0 {
			return true
		}
	}

	return false

}

// hasEventSubscriber checks if the swamp has any event subscribers
func (h *hydra) hasInfoSubscriber(swampName name.Name) bool {

	canonicalForm := swampName.Get()
	if subscribers, ok := h.infoSubscribers.Load(canonicalForm); ok {
		infoSubscribers := 0
		subscribers.(*sync.Map).Range(func(key, value interface{}) bool {
			infoSubscribers++
			return true
		})
		if infoSubscribers > 0 {
			return true
		}
	}

	return false
}

// eventCallbackFunction send the eventChannelHandler to all subscribed clients
func (h *hydra) eventCallbackFunction(event *swamp.Event) {

	swampName := event.SwampName

	if subscribers, ok := h.eventSubscribers.Load(swampName.Get()); ok {

		treasureID := ""
		if event.Treasure != nil {
			treasureID = event.Treasure.GetKey()
		}
		oldTreasureID := ""
		if event.OldTreasure != nil {
			oldTreasureID = event.OldTreasure.GetKey()
		}

		subscribers.(*sync.Map).Range(func(key, value interface{}) bool {

			if value == nil {

				slog.Error("the callback function is nil, this is a bug, the callback function should not be nil",
					"swampName", swampName,
					"subscriberID", key,
					"eventTreasureKey", treasureID,
					"eventOldTreasureKey", oldTreasureID)

				return true
			}

			// let's try to send the event to the client
			// select for the case when the channel is full or closed
			if function, ok := value.(func(event *swamp.Event)); ok {

				function(event) // Csak akkor hívjuk, ha a type assertion sikeres.

			} else {

				clientUUID, err := uuid.Parse(key.(string))
				if err != nil {

					slog.Error("can not parse the subscriberID to UUID",
						"swampName", swampName,
						"subscriberID", key)

					return true
				}

				// unsubscribe the client from the event channel, because the channel is full or closed
				if err := h.UnsubscribeFromSwampEvents(clientUUID, event.SwampName); err != nil {

					slog.Error("can not unsubscribe the client from the event channel",
						"swampName", swampName,
						"subscriberID", key)

					return true
				}

				slog.Warn("can not send event to the subscribed user because the callback function is not a func(event *swamp.Event) type. The client forced to unsubscribe from the event channel.",
					"swampName", swampName,
					"subscriberID", key)

				return true

			}

			return true

		})
	}

}

func (h *hydra) infoCallbackFunction(si *swamp.Info) {

	if subscribers, ok := h.infoSubscribers.Load(si.SwampName.Get()); ok {

		subscribers.(*sync.Map).Range(func(key, value interface{}) bool {

			if value == nil {

				slog.Error("the callback function is nil, this is a bug, the callback function should not be nil",
					"swampName", si.SwampName,
					"subscriberID", key,
					"info", si.AllElements)

				return true
			}

			if function, ok := value.(func(info *swamp.Info)); ok {
				function(si)
			} else {

				// unsubscribe the client from the event channel if the swamp is closing
				clientUUID, err := uuid.Parse(key.(string))
				if err != nil {

					slog.Error("can not parse the subscriberID to UUID",
						"swampName", si.SwampName,
						"subscriberID", key)

					return true
				}
				// unsubscribe the client from the event channel, because the channel is full or closed
				if err := h.UnsubscribeFromSwampInfo(clientUUID, si.SwampName); err != nil {

					slog.Error("can not unsubscribe the client from the swamp information",
						"swampName", si.SwampName,
						"subscriberID", key)

					return true
				}

				slog.Warn("can not send info to the subscribed user because the callback function is not a func(info *swamp.Info) type. The client forced to unsubscribe from the swamp informations.",
					"swampName", si.SwampName)

				return true

			}

			return true

		})
	}

}

// closeEventCallbackFunction removes the swamp from the opened swamps map
func (h *hydra) closeEventCallbackFunction(swampName name.Name) {
	h.swamps.Delete(swampName.Get())
}

--------------------------------------------------------------------------------

/==============================================================================\
| FILE: core\hydra\hydra_test.go
| PATH: C:\go\src\hydraide\app\core\hydra\hydra_test.go
| SIZE: 31.5 KB
\==============================================================================/

package hydra

import (
	"context"
	"fmt"
	"github.com/google/uuid"
	"github.com/hydraide/hydraide/app/core/filesystem"
	"github.com/hydraide/hydraide/app/core/hydra/lock"
	"github.com/hydraide/hydraide/app/core/hydra/swamp"
	"github.com/hydraide/hydraide/app/core/safeops"
	"github.com/hydraide/hydraide/app/core/settings"
	"github.com/hydraide/hydraide/app/name"
	"github.com/stretchr/testify/assert"
	"log/slog"
	"sync"
	"testing"
	"time"
)

const (
	// testServerNumber      = 100
	testMaxDepth          = 3
	testMaxFolderPerLevel = 2000
	sanctuaryForQuickTest = "hydraquicktest"
)

func TestHydra_SummonSwamp(t *testing.T) {

	elysiumInterface := safeops.New()

	lockerInterface := lock.New()

	fsInterface := filesystem.New()
	settingsInterface := settings.New(testMaxDepth, testMaxFolderPerLevel)
	// gyors filementés és bezárás a tesztekhez
	fss := &settings.FileSystemSettings{
		WriteIntervalSec: 1,
		MaxFileSizeByte:  8192,
	}

	settingsInterface.RegisterPattern(name.New().Sanctuary(sanctuaryForQuickTest).Realm("*").Swamp("*"), false, 1, fss)
	hydraInterface := New(settingsInterface, elysiumInterface, lockerInterface, fsInterface)

	t.Run("should summon a non existing swamp", func(t *testing.T) {

		newSwampName := name.New().Sanctuary("summon").Realm("non-existing").Swamp("swamp")
		swampInterface, _ := hydraInterface.SummonSwamp(context.Background(), 10, newSwampName)

		assert.NotNil(t, swampInterface, "should not be nil")
		assert.Equal(t, newSwampName, swampInterface.GetName(), "should be equal")

		swampInterface.Destroy()

	})

	t.Run("should summon an existing swamp", func(t *testing.T) {

		newSwampName := name.New().Sanctuary("summon").Realm("existing").Swamp("swamp")

		// summon a swamp at the first time
		swampInterface, _ := hydraInterface.SummonSwamp(context.Background(), 10, newSwampName)

		assert.NotNil(t, swampInterface, "should not be nil")
		assert.Equal(t, newSwampName, swampInterface.GetName(), "should be equal")

		// summon the swamp again
		swampInterface, _ = hydraInterface.SummonSwamp(context.Background(), 10, newSwampName)
		assert.NotNil(t, swampInterface, "should not be nil")
		assert.Equal(t, newSwampName, swampInterface.GetName(), "should be equal")

		// destory the swamp after the test
		swampInterface.Destroy()

	})

	t.Run("should exists the swamp", func(t *testing.T) {

		newSwampName := name.New().Sanctuary("summon").Realm("is-existing").Swamp("swamp")

		swampInterface, _ := hydraInterface.SummonSwamp(context.Background(), 10, newSwampName)

		assert.NotNil(t, swampInterface, "should not be nil")
		assert.Equal(t, newSwampName, swampInterface.GetName(), "should be equal")

		isExists, _ := hydraInterface.IsExistSwamp(10, newSwampName)

		assert.True(t, isExists, "should be true")

		// töröljük a swmpot tesztelés után
		swampInterface.Destroy()

	})

	t.Run("should not exists the swamp", func(t *testing.T) {

		newSwampName := name.New().Sanctuary("summon").Realm("should-not-exist").Swamp("swamp")

		isExists, _ := hydraInterface.IsExistSwamp(10, newSwampName)

		assert.False(t, isExists, "should be false")

	})

	t.Run("should list all active swamps", func(t *testing.T) {

		allActiveSwamps := hydraInterface.ListActiveSwamps()
		assert.Equal(t, 0, len(allActiveSwamps), "should be equal")

		var testSwampNames []name.Name
		allTests := 10
		for i := 0; i < allTests; i++ {
			testSwampNames = append(testSwampNames, name.New().Sanctuary("test").Realm("active-swamp-list").Swamp(fmt.Sprintf("swamp-%d", i)))
		}

		for i := 0; i < allTests; i++ {
			_, _ = hydraInterface.SummonSwamp(context.Background(), 10, testSwampNames[i])
		}

		allActiveSwamps = hydraInterface.ListActiveSwamps()
		assert.Equal(t, allTests, len(allActiveSwamps), "should be equal")

		// wait for 7 seconds to close all swamps because of the swamp's default timeout is 5 seconds without any activity
		time.Sleep(7 * time.Second)

		allActiveSwamps = hydraInterface.ListActiveSwamps()
		assert.Equal(t, 0, len(allActiveSwamps), "should be equal")

		// destroy test swamps
		for i := 0; i < allTests; i++ {
			swampInterface, _ := hydraInterface.SummonSwamp(context.Background(), 10, testSwampNames[i])
			swampInterface.Destroy()
		}

	})

	t.Run("should create treasure with same key", func(t *testing.T) {

		swampInterface, err := hydraInterface.SummonSwamp(context.Background(), 10, name.New().Sanctuary(sanctuaryForQuickTest).Realm("treasure-with").Swamp("same-key"))
		assert.Nil(t, err, "should be nil")

		allTests := 10

		wg := sync.WaitGroup{}
		wg.Add(allTests)

		swampInterface.BeginVigil()
		for i := 0; i < allTests; i++ {

			go func(counter int) {
				treasureInterface := swampInterface.CreateTreasure("same-key")
				guardID := treasureInterface.StartTreasureGuard(true)
				treasureInterface.SetContentString(guardID, fmt.Sprintf("my-content-%d", counter))
				treasureInterface.Save(guardID)
				treasureInterface.ReleaseTreasureGuard(guardID)
				wg.Done()
			}(i)

		}
		swampInterface.CeaseVigil()

		wg.Wait()

		// ellenőrizzük és csak 1 treasure-t kellene találnunk
		allTreasures := swampInterface.CountTreasures()
		if err != nil {
			t.Error(err)
		}
		assert.Equal(t, 1, allTreasures, "should be equal")

		time.Sleep(2 * time.Second)

		// destroy the swamp after the test
		swampInterface.Destroy()

	})

	t.Run("insert words with domains per words", func(t *testing.T) {

		allWords := 100
		allDomainsPerWord := 100

		var words []string
		for i := 0; i < allWords; i++ {
			words = append(words, fmt.Sprintf("word-%d", i))
		}

		var domains []string
		for i := 0; i < allDomainsPerWord; i++ {
			domains = append(domains, fmt.Sprintf("domain-%d.com", i))
		}

		wg := sync.WaitGroup{}
		wg.Add(len(words) * len(domains))

		// run tests with all words
		for _, word := range words {

			go func(workingWord string) {

				swampCtx, cancelFunc := context.WithTimeout(context.Background(), 10*time.Second)
				defer cancelFunc()

				swampInterface, err := hydraInterface.SummonSwamp(swampCtx, 10, name.New().Sanctuary(sanctuaryForQuickTest).Realm("test-words-to-domains").Swamp(workingWord))
				if err != nil {
					slog.Error("error while summoning swamp", "error", err)
					return
				}

				swampInterface.BeginVigil()
				defer swampInterface.CeaseVigil()

				for _, domain := range domains {
					treasureInterface := swampInterface.CreateTreasure(domain)
					guardID := treasureInterface.StartTreasureGuard(true)
					treasureInterface.Save(guardID)
					treasureInterface.ReleaseTreasureGuard(guardID)
					wg.Done()
				}

			}(word)

		}

		wg.Wait()

		// nyissuk be az összes swampot és ellenőrizzük, hogy bekerült-e az összes domain
		for _, word := range words {
			swampInterface, err := hydraInterface.SummonSwamp(context.Background(), 10, name.New().Sanctuary(sanctuaryForQuickTest).Realm("test-words-to-domains").Swamp(word))
			assert.NoError(t, err, "should be nil")
			assert.NotNil(t, swampInterface, "should not be nil")
			assert.Equal(t, allDomainsPerWord, swampInterface.CountTreasures(), "should be equal")
			// ha minden ok, akkor töröljük a swampot, hogy a tesztet követően ne maradjon benn a hydra-ban
			swampInterface.Destroy()
		}

	})

	t.Run("should destroy the swamp after all treasures deleted", func(t *testing.T) {

		swampName := name.New().Sanctuary(sanctuaryForQuickTest).Realm("treasure-delete").Swamp("after-all-keys-deleted")

		swampInterface, err := hydraInterface.SummonSwamp(context.Background(), 10, swampName)
		assert.Nil(t, err, "should be nil")

		treasure := swampInterface.CreateTreasure("treasure-1")

		guardID := treasure.StartTreasureGuard(true)
		treasure.Save(guardID)
		treasure.ReleaseTreasureGuard(guardID)

		// megszámoljuk a treasure-ket
		allTreasures := swampInterface.CountTreasures()
		assert.Equal(t, 1, allTreasures, "should be equal")

		// töröljük a treasure-t a kulcsa alapján
		err = swampInterface.DeleteTreasure("treasure-1", false)
		assert.Nil(t, err, "should be nil")

		// várunk egy kci kicsit, hogy a hydra törölje a treasure és a swampot is egyaránt
		time.Sleep(100 * time.Millisecond)

		// a swampnak nem szabadna léteznie
		isExists, err := hydraInterface.IsExistSwamp(10, swampName)
		assert.NoError(t, err, "should be nil")
		assert.False(t, isExists, "should be false")

	})

	t.Run("should create and modify treasure", func(t *testing.T) {

		swampName := name.New().Sanctuary(sanctuaryForQuickTest).Realm("treasure-get-and-modify").Swamp("get-and-modify")

		swampInterface, err := hydraInterface.SummonSwamp(context.Background(), 10, swampName)
		assert.Nil(t, err, "should be nil")

		treasure := swampInterface.CreateTreasure("treasure-1")

		guardID := treasure.StartTreasureGuard(true)
		treasure.SetContentString(guardID, "content1")
		treasure.Save(guardID)
		treasure.ReleaseTreasureGuard(guardID)

		// megszámoljuk a treasure-ket
		allTreasures := swampInterface.CountTreasures()
		assert.Equal(t, 1, allTreasures, "should be equal")

		// visszaolvassuk a treasure-t
		treasure, err = swampInterface.GetTreasure("treasure-1")
		assert.NotNil(t, treasure, "should not be nil")

		// módosítjuk a contentet
		guardID = treasure.StartTreasureGuard(false)
		treasure.SetContentString(guardID, "content2")
		treasure.Save(guardID)
		treasure.ReleaseTreasureGuard(guardID)

		// visszaolvassuk a treasure-t
		treasure, err = swampInterface.GetTreasure("treasure-1")
		assert.NotNil(t, treasure, "should not be nil")

		content, err := treasure.GetContentString()
		assert.NoError(t, err, "should be nil")
		assert.Equal(t, "content2", content, "should be equal")

		// megvárjuk a kiírásokat is
		time.Sleep(3 * time.Second)

		// beolvassuk a contentet megint kiírást követően is
		treasure, err = swampInterface.GetTreasure("treasure-1")
		assert.NoError(t, err, "should be nil")
		content, err = treasure.GetContentString()
		assert.NoError(t, err, "should be nil")
		assert.Equal(t, "content2", content, "should be equal")

		// töröljük a swampot
		swampInterface.Destroy()

	})

	t.Run("should get treasures from the beacon after deleting some treasures through the hydra", func(t *testing.T) {

		swampName := name.New().Sanctuary(sanctuaryForQuickTest).Realm("get-after-delete").Swamp("by-beacon")

		swampInterface, err := hydraInterface.SummonSwamp(context.Background(), 10, swampName)
		swampInterface.BeginVigil()

		assert.Nil(t, err, "should be nil")

		defer func() {
			swampInterface.CeaseVigil()
			// destroy the swamp after the test
			swampInterface.Destroy()
		}()

		allTests := 10

		defaultTime := time.Now()
		wg := sync.WaitGroup{}
		wg.Add(allTests)

		for i := 0; i < allTests; i++ {

			go func(counter int) {
				treasureInterface := swampInterface.CreateTreasure(fmt.Sprintf("key-%d", counter))
				guardID := treasureInterface.StartTreasureGuard(true)
				defer treasureInterface.ReleaseTreasureGuard(guardID)
				treasureInterface.SetContentString(guardID, fmt.Sprintf("my-content-%d", counter))
				treasureInterface.SetCreatedAt(guardID, defaultTime.Add(time.Duration(counter)*time.Nanosecond))
				treasureInterface.Save(guardID)
				wg.Done()
			}(i)

		}

		// wait for all treasures to be saved
		wg.Wait()

		// try to get all items back from the creationType beacon
		beacon, err := swampInterface.GetTreasuresByBeacon(swamp.BeaconTypeCreationTime, swamp.IndexOrderDesc, 0, 100000)
		assert.Nil(t, err, "should be nil")
		assert.Equal(t, allTests, len(beacon), "should be equal")

		// delete 1 treasure (key-15)
		err = swampInterface.DeleteTreasure("key-8", false)
		assert.Nil(t, err, "should be nil")

		// try to get all items back from the creationType beacon
		allTreasures, err := swampInterface.GetTreasuresByBeacon(swamp.BeaconTypeCreationTime, swamp.IndexOrderDesc, 0, 100000)
		assert.Nil(t, err, "should be nil")
		assert.Equal(t, allTests-1, len(allTreasures), "should be equal")

		time.Sleep(2 * time.Second)

	})

	t.Run("should get treasures from beacon after the swamp closed, treasure deleted then got from the beacon", func(t *testing.T) {

		swampName := name.New().Sanctuary(sanctuaryForQuickTest).Realm("get-after-swamp-close-then-delete").Swamp("by-beacon")

		swampInterface, err := hydraInterface.SummonSwamp(context.Background(), 10, swampName)
		swampInterface.BeginVigil()

		assert.Nil(t, err, "should be nil")

		defer func() {
			swampInterface2, err := hydraInterface.SummonSwamp(context.Background(), 10, swampName)
			assert.Nil(t, err, "should be nil")
			// destroy the swamp after the test
			swampInterface2.Destroy()
		}()

		allTests := 10

		defaultTime := time.Now()
		wg := sync.WaitGroup{}
		wg.Add(allTests)

		for i := 0; i < allTests; i++ {

			go func(counter int) {
				treasureInterface := swampInterface.CreateTreasure(fmt.Sprintf("key-%d", counter))
				guardID := treasureInterface.StartTreasureGuard(true)
				defer treasureInterface.ReleaseTreasureGuard(guardID)
				treasureInterface.SetContentString(guardID, fmt.Sprintf("my-content-%d", counter))
				treasureInterface.SetCreatedAt(guardID, defaultTime.Add(time.Duration(counter)*time.Nanosecond))
				treasureInterface.Save(guardID)
				wg.Done()
			}(i)

		}

		// wait for all treasures to be saved
		wg.Wait()

		// try to get all items back from the creationType beacon
		beacon, err := swampInterface.GetTreasuresByBeacon(swamp.BeaconTypeCreationTime, swamp.IndexOrderDesc, 0, 100000)
		assert.Nil(t, err, "should be nil")
		assert.Equal(t, allTests, len(beacon), "should be equal")
		// let the swamp to be closed
		swampInterface.CeaseVigil()

		// wait fo the swamp to be closed
		time.Sleep(7 * time.Second)

		// summon the swamp again
		swampInterface, err = hydraInterface.SummonSwamp(context.Background(), 10, swampName)
		assert.Nil(t, err, "should be nil")
		swampInterface.BeginVigil()
		defer swampInterface.CeaseVigil()

		// delete 1 treasure (key-8)
		err = swampInterface.DeleteTreasure("key-8", false)
		assert.Nil(t, err, "should be nil")

		// try to get all items back from the creationType beacon after deleted the treasure
		allTreasures, err := swampInterface.GetTreasuresByBeacon(swamp.BeaconTypeCreationTime, swamp.IndexOrderDesc, 0, 100000)
		assert.Nil(t, err, "should be nil")
		assert.Equal(t, allTests-1, len(allTreasures), "should be equal")

	})

	t.Run("should metadata work", func(t *testing.T) {

		swampName := name.New().Sanctuary(sanctuaryForQuickTest).Realm("metadata").Swamp("metadatatest")

		swampInterface, err := hydraInterface.SummonSwamp(context.Background(), 10, swampName)
		swampInterface.BeginVigil()

		assert.Nil(t, err, "should be nil")

		defer func() {
			swampInterface2, err := hydraInterface.SummonSwamp(context.Background(), 10, swampName)
			assert.Nil(t, err, "should be nil")
			// destroy the swamp after the test
			swampInterface2.Destroy()
		}()

		allTests := 2

		defaultTime := time.Now()
		wg := sync.WaitGroup{}
		wg.Add(allTests)

		for i := 0; i < allTests; i++ {

			go func(counter int) {
				treasureInterface := swampInterface.CreateTreasure(fmt.Sprintf("key-%d", counter))
				guardID := treasureInterface.StartTreasureGuard(true)
				defer treasureInterface.ReleaseTreasureGuard(guardID)
				treasureInterface.SetContentString(guardID, fmt.Sprintf("my-content-%d", counter))
				treasureInterface.SetCreatedAt(guardID, defaultTime.Add(time.Duration(counter)*time.Nanosecond))
				treasureInterface.Save(guardID)
				wg.Done()
			}(i)

		}

		// wait for all treasures to be saved
		wg.Wait()

		firstCreatedAt := swampInterface.GetMetadata().GetCreatedAt()
		firstUpdatedAt := swampInterface.GetMetadata().GetUpdatedAt()

		assert.NotEqual(t, time.Time{}, firstCreatedAt)
		assert.Less(t, firstCreatedAt, time.Now())

		assert.NotEqual(t, time.Time{}, firstUpdatedAt)
		assert.Less(t, firstUpdatedAt, time.Now())
		swampInterface.CeaseVigil()

		// várunk az írásra és a swamp bezárására
		time.Sleep(5 * time.Second)

		// summon the swamp again
		swampInterface, err = hydraInterface.SummonSwamp(context.Background(), 10, swampName)
		assert.Nil(t, err, "should be nil")
		swampInterface.BeginVigil()

		assert.Equal(t, swampInterface.GetMetadata().GetSwampName().Get(), swampName.Get())

		// add new data
		treasureInterface := swampInterface.CreateTreasure("key-100")
		guardID := treasureInterface.StartTreasureGuard(true)
		treasureInterface.SetContentString(guardID, "my-content-100")
		treasureInterface.Save(guardID)
		treasureInterface.ReleaseTreasureGuard(guardID)

		secondCreatedAt := swampInterface.GetMetadata().GetCreatedAt()
		secondUpdatedAt := swampInterface.GetMetadata().GetUpdatedAt()
		swampInterface.CeaseVigil()

		assert.Equal(t, firstCreatedAt, secondCreatedAt)
		assert.Greater(t, secondUpdatedAt, firstUpdatedAt)

		time.Sleep(5 * time.Second)

		// most csak betöltjük a swampot, de nem módosítjuk
		swampInterface, err = hydraInterface.SummonSwamp(context.Background(), 10, swampName)
		assert.Nil(t, err, "should be nil")

		thirdCreatedAt := swampInterface.GetMetadata().GetCreatedAt()
		thirdUpdatedAt := swampInterface.GetMetadata().GetUpdatedAt()

		assert.True(t, firstCreatedAt.Equal(thirdCreatedAt))
		assert.True(t, secondUpdatedAt.Equal(thirdUpdatedAt))

		time.Sleep(5 * time.Second)

	})

	t.Run("should subscribe to swamp events works", func(t *testing.T) {

		swampName := name.New().Sanctuary(sanctuaryForQuickTest).Realm("subscription-test").Swamp("subscribe-to-event")

		// destroy the swamp before the test, if the swamp exists
		swampInterface, err := hydraInterface.SummonSwamp(context.Background(), 10, swampName)
		assert.Nil(t, err, "should be nil")
		swampInterface.Destroy()

		clientID := uuid.New()

		defer func() {

			// unsubscribe from the event
			err := hydraInterface.UnsubscribeFromSwampEvents(clientID, swampName)
			assert.Nil(t, err, "should be nil")

			// destroy the swamp after the test
			swampInterface, err := hydraInterface.SummonSwamp(context.Background(), 10, swampName)
			assert.Nil(t, err, "should be nil")
			swampInterface.Destroy()

		}()

		alltests := 10
		wg := sync.WaitGroup{}
		wg.Add(alltests)

		err = hydraInterface.SubscribeToSwampEvents(clientID, swampName, func(event *swamp.Event) {
			wg.Done()
		})

		assert.Nil(t, err, "should be nil")

		swampInterface.BeginVigil()
		defer swampInterface.CeaseVigil()

		swampInterface, err = hydraInterface.SummonSwamp(context.Background(), 10, swampName)
		assert.Nil(t, err, "should be nil")
		// insertáljunk be 10 treasure-t
		for i := 0; i < alltests; i++ {
			treasureInterface := swampInterface.CreateTreasure(fmt.Sprintf("key-%d", i))
			guardID := treasureInterface.StartTreasureGuard(true)
			treasureInterface.SetContentString(guardID, fmt.Sprintf("my-content-%d", i))
			treasureInterface.Save(guardID)
			treasureInterface.ReleaseTreasureGuard(guardID)
		}

		// várjuk meg, hogy az esemény megérkezzen és a feliratkozott függvény lefusson
		wg.Wait()

	})

	t.Run("should subscribe to swamp info works", func(t *testing.T) {

		swampName := name.New().Sanctuary(sanctuaryForQuickTest).Realm("subscription-test").Swamp("subscribe-to-swamp-info")

		// destroy the swamp before the test, if the swamp exists
		swampInterface, err := hydraInterface.SummonSwamp(context.Background(), 10, swampName)
		assert.Nil(t, err, "should be nil")
		swampInterface.Destroy()

		clientID := uuid.New()

		defer func() {
			// unsubscribe from the event
			err := hydraInterface.UnsubscribeFromSwampInfo(clientID, swampName)
			assert.Nil(t, err, "should be nil")
			// destroy the swamp after the test
			swampInterface, err := hydraInterface.SummonSwamp(context.Background(), 10, swampName)
			assert.Nil(t, err, "should be nil")
			swampInterface.Destroy()

		}()

		alltests := 10
		wg := sync.WaitGroup{}
		wg.Add(alltests)

		err = hydraInterface.SubscribeToSwampInfo(clientID, swampName, func(info *swamp.Info) {
			wg.Done()
		})
		assert.Nil(t, err, "should be nil")

		swampInterface.BeginVigil()
		defer swampInterface.CeaseVigil()

		swampInterface, err = hydraInterface.SummonSwamp(context.Background(), 10, swampName)
		assert.Nil(t, err, "should be nil")

		// insertáljunk be 10 treasure-t
		for i := 0; i < alltests; i++ {
			treasureInterface := swampInterface.CreateTreasure(fmt.Sprintf("key-%d", i))
			guardID := treasureInterface.StartTreasureGuard(true)
			treasureInterface.SetContentString(guardID, fmt.Sprintf("my-content-%d", i))
			treasureInterface.Save(guardID)
			treasureInterface.ReleaseTreasureGuard(guardID)
		}

		wg.Wait()

	})

	t.Run("should list and count all active swamps", func(t *testing.T) {

		// create 10 swmaps
		var testSwampNames []name.Name
		allTests := 10
		for i := 0; i < allTests; i++ {
			testSwampNames = append(testSwampNames, name.New().Sanctuary("test").Realm("active-swamp-list").Swamp(fmt.Sprintf("swamp-%d", i)))
		}

		// summon the swamps
		for i := 0; i < allTests; i++ {
			_, _ = hydraInterface.SummonSwamp(context.Background(), 10, testSwampNames[i])
		}

		allActiveSwamps := hydraInterface.ListActiveSwamps()
		assert.Equal(t, allTests, len(allActiveSwamps), "should be equal")
		activeSwampCounter := hydraInterface.CountActiveSwamps()
		assert.Equal(t, allTests, activeSwampCounter, "should be equal")

		// delete all swamps
		for i := 0; i < allTests; i++ {
			swampInterface, _ := hydraInterface.SummonSwamp(context.Background(), 10, testSwampNames[i])
			swampInterface.Destroy()
		}

	})

}

// hydra_test.go:690: Total time: 3.989516361s (1000000 op)
// Average per op: 3.989µs
func TestHydraInsertTiming(t *testing.T) {

	elysiumInterface := safeops.New()
	lockerInterface := lock.New()
	fsInterface := filesystem.New()

	settingsInterface := settings.New(testMaxDepth, testMaxFolderPerLevel)
	fss := &settings.FileSystemSettings{
		WriteIntervalSec: 1,
		MaxFileSizeByte:  8192,
	}

	settingsInterface.RegisterPattern(
		name.New().Sanctuary("test").Realm("*").Swamp("*"),
		false, 1, fss,
	)

	hydraInterface := New(settingsInterface, elysiumInterface, lockerInterface, fsInterface)
	swampName := name.New().Sanctuary("test").Realm("timing").Swamp("swamp")

	count := 1000000
	start := time.Now()

	for i := 0; i < count; i++ {
		si, _ := hydraInterface.SummonSwamp(context.Background(), 10, swampName)
		ti := si.CreateTreasure(fmt.Sprintf("treasure-%d", i))
		tg := ti.StartTreasureGuard(true)
		ti.SetContentString(tg, fmt.Sprintf("content-%d", i))
		ti.Save(tg)
		ti.ReleaseTreasureGuard(tg)
	}

	elapsed := time.Since(start)
	perOp := elapsed / time.Duration(count)
	t.Logf("Total time: %s (%d op)\nAverage per op: %s", elapsed, count, perOp)

	// destroy the swamp after the test
	swampInterface, _ := hydraInterface.SummonSwamp(context.Background(), 10, swampName)
	swampInterface.Destroy()

}

// hydra_test.go:732: Total time: 3.930572938s (1000000 op)
// Average per op: 3.93µs
func TestHydraInsertTiming_InMemory(t *testing.T) {

	elysiumInterface := safeops.New()
	lockerInterface := lock.New()
	fsInterface := filesystem.New()

	settingsInterface := settings.New(testMaxDepth, testMaxFolderPerLevel)

	settingsInterface.RegisterPattern(
		name.New().Sanctuary(sanctuaryForQuickTest).Realm("inmemory").Swamp("summonandsave"),
		true, // inMemory = true
		1,
		nil, // nincs szükség FileSystemSettings-re inMemory módban
	)

	hydraInterface := New(settingsInterface, elysiumInterface, lockerInterface, fsInterface)
	swampName := name.New().Sanctuary(sanctuaryForQuickTest).Realm("inmemory").Swamp("summonandsave")

	count := 1000000
	start := time.Now()

	for i := 0; i < count; i++ {
		si, _ := hydraInterface.SummonSwamp(context.Background(), 10, swampName)
		ti := si.CreateTreasure(fmt.Sprintf("treasure-%d", i))
		tg := ti.StartTreasureGuard(true)
		ti.SetContentString(tg, fmt.Sprintf("content-%d", i))
		ti.Save(tg)
		ti.ReleaseTreasureGuard(tg)
	}

	elapsed := time.Since(start)
	perOp := elapsed / time.Duration(count)
	t.Logf("Total time: %s (%d op)\nAverage per op: %s", elapsed, count, perOp)

	// cleanup
	swampInterface, _ := hydraInterface.SummonSwamp(context.Background(), 10, swampName)
	swampInterface.Destroy()

}

// hydra_test.go:773: Total time: 3.576679347s (1000000 op)
// Average per op: 3.576µs
func TestHydraBulkInsertTiming_InMemory(t *testing.T) {
	elysiumInterface := safeops.New()
	lockerInterface := lock.New()
	fsInterface := filesystem.New()

	settingsInterface := settings.New(testMaxDepth, testMaxFolderPerLevel)

	settingsInterface.RegisterPattern(
		name.New().Sanctuary(sanctuaryForQuickTest).Realm("bulk").Swamp("inmemory"),
		true, // inMemory = true
		3500, // closeAfterIdleSec
		nil,  // nincs fájlkorlát
	)

	hydraInterface := New(settingsInterface, elysiumInterface, lockerInterface, fsInterface)
	swampName := name.New().Sanctuary(sanctuaryForQuickTest).Realm("bulk").Swamp("inmemory")

	// Swamp summon egyszer, a benchmark előtt
	si, _ := hydraInterface.SummonSwamp(context.Background(), 10, swampName)

	count := 1000000
	start := time.Now()

	for i := 0; i < count; i++ {
		ti := si.CreateTreasure(fmt.Sprintf("treasure-%d", i))
		tg := ti.StartTreasureGuard(true)
		ti.SetContentString(tg, fmt.Sprintf("content-%d", i))
		ti.Save(tg)
		ti.ReleaseTreasureGuard(tg)
	}

	elapsed := time.Since(start)
	perOp := elapsed / time.Duration(count)
	t.Logf("Total time: %s (%d op)\nAverage per op: %s", elapsed, count, perOp)

	// cleanup
	si.Destroy()
}

// hydra_test.go:816: Total time: 78.091304ms (1000000 op)
// Average per op: 78ns
func TestHydraGetTiming(t *testing.T) {
	elysiumInterface := safeops.New()
	lockerInterface := lock.New()
	fsInterface := filesystem.New()

	settingsInterface := settings.New(testMaxDepth, testMaxFolderPerLevel)
	fss := &settings.FileSystemSettings{
		WriteIntervalSec: 1,
		MaxFileSizeByte:  8192,
	}

	settingsInterface.RegisterPattern(
		name.New().Sanctuary(sanctuaryForQuickTest).Realm("gettest").Swamp("readonly"),
		false, // nem inMemory most, de lehetne az is
		3500,
		fss,
	)

	hydraInterface := New(settingsInterface, elysiumInterface, lockerInterface, fsInterface)

	swampName := name.New().Sanctuary(sanctuaryForQuickTest).Realm("gettest").Swamp("readonly")
	si, _ := hydraInterface.SummonSwamp(context.Background(), 10, swampName)

	// Létrehozzuk a treasure-t, amit olvasni fogunk
	ti := si.CreateTreasure("treasure")
	tg := ti.StartTreasureGuard(true)
	ti.SetContentString(tg, "content")
	ti.Save(tg)
	ti.ReleaseTreasureGuard(tg)

	// Most mérjük a GET-ek sebességét
	count := 1000000
	start := time.Now()

	for i := 0; i < count; i++ {
		_, _ = si.GetTreasure("treasure")
	}

	elapsed := time.Since(start)
	perOp := elapsed / time.Duration(count)
	t.Logf("Total time: %s (%d op)\nAverage per op: %s", elapsed, count, perOp)

	si.Destroy()
}

// hydra_test.go:853: Batch Get – Total: 2.308329ms (10k op)
// Average per op: 230ns
func TestHydraBatchGetTiming(t *testing.T) {
	elysiumInterface := safeops.New()
	lockerInterface := lock.New()
	fsInterface := filesystem.New()

	settingsInterface := settings.New(testMaxDepth, testMaxFolderPerLevel)

	settingsInterface.RegisterPattern(
		name.New().Sanctuary(sanctuaryForQuickTest).Realm("batchget").Swamp("multi"),
		true, // inMemory
		3600,
		nil,
	)

	hydraInterface := New(settingsInterface, elysiumInterface, lockerInterface, fsInterface)
	swampName := name.New().Sanctuary(sanctuaryForQuickTest).Realm("batchget").Swamp("multi")

	si, _ := hydraInterface.SummonSwamp(context.Background(), 10, swampName)

	// Feltöltünk előre 10.000 treasure-t
	for i := 0; i < 10000; i++ {
		ti := si.CreateTreasure(fmt.Sprintf("treasure-%d", i))
		tg := ti.StartTreasureGuard(true)
		ti.SetContentString(tg, fmt.Sprintf("content-%d", i))
		ti.Save(tg)
		ti.ReleaseTreasureGuard(tg)
	}

	// Most mérjük, hogy mennyi idő alatt listázzuk ki őket
	start := time.Now()
	for i := 0; i < 10000; i++ {
		_, _ = si.GetTreasure(fmt.Sprintf("treasure-%d", i))
	}
	elapsed := time.Since(start)
	perOp := elapsed / 10000

	t.Logf("Batch Get – Total: %s (10k op)\nAverage per op: %s", elapsed, perOp)

	si.Destroy()
}

func TestHydraGetTiming_Parallel(t *testing.T) {
	elysiumInterface := safeops.New()
	lockerInterface := lock.New()
	fsInterface := filesystem.New()

	settingsInterface := settings.New(testMaxDepth, testMaxFolderPerLevel)
	settingsInterface.RegisterPattern(
		name.New().Sanctuary(sanctuaryForQuickTest).Realm("parallel").Swamp("get"),
		true,
		3600,
		nil,
	)

	hydraInterface := New(settingsInterface, elysiumInterface, lockerInterface, fsInterface)
	swampName := name.New().Sanctuary(sanctuaryForQuickTest).Realm("parallel").Swamp("get")
	si, _ := hydraInterface.SummonSwamp(context.Background(), 10, swampName)

	// upload the swamp with treasures
	totalTreasures := 10000
	for i := 0; i < totalTreasures; i++ {
		ti := si.CreateTreasure(fmt.Sprintf("treasure-%d", i))
		tg := ti.StartTreasureGuard(true)
		ti.SetContentString(tg, fmt.Sprintf("content-%d", i))
		ti.Save(tg)
		ti.ReleaseTreasureGuard(tg)
	}

	threads := 16
	opsPerThread := 100000
	totalOps := threads * opsPerThread

	var wg sync.WaitGroup
	wg.Add(threads)

	start := time.Now()

	for tIdx := 0; tIdx < threads; tIdx++ {
		go func(thread int) {
			defer wg.Done()
			for i := 0; i < opsPerThread; i++ {
				_, _ = si.GetTreasure(fmt.Sprintf("treasure-%d", i%totalTreasures))
			}
		}(tIdx)
	}

	wg.Wait()
	elapsed := time.Since(start)
	perOp := elapsed / time.Duration(totalOps)

	t.Logf("Parallel GET (%d threads, %d op) — Total: %s\nAverage per op: %s", threads, totalOps, elapsed, perOp)

	si.Destroy()
}

func TestHydraGetTiming_Parallel_MultiSwamp(t *testing.T) {
	elysiumInterface := safeops.New()
	lockerInterface := lock.New()
	fsInterface := filesystem.New()
	settingsInterface := settings.New(testMaxDepth, testMaxFolderPerLevel)

	realm := "multiswamp"
	swampCount := 16
	opsPerSwamp := 100000
	totalOps := swampCount * opsPerSwamp

	swamps := make([]swamp.Swamp, swampCount)

	// registering the pattern for multiple swamps
	for i := 0; i < swampCount; i++ {
		sanctuary := name.New().Sanctuary(sanctuaryForQuickTest).Realm(realm).Swamp(fmt.Sprintf("swamp-%d", i))
		settingsInterface.RegisterPattern(
			sanctuary,
			true, // inMemory
			3600,
			nil,
		)
	}

	hydraInterface := New(settingsInterface, elysiumInterface, lockerInterface, fsInterface)

	// Summon + upload
	for i := 0; i < swampCount; i++ {
		swampName := name.New().Sanctuary(sanctuaryForQuickTest).Realm(realm).Swamp(fmt.Sprintf("swamp-%d", i))
		si, _ := hydraInterface.SummonSwamp(context.Background(), 10, swampName)

		ti := si.CreateTreasure("treasure")
		tg := ti.StartTreasureGuard(true)
		ti.SetContentString(tg, "multiswamp-content")
		ti.Save(tg)
		ti.ReleaseTreasureGuard(tg)

		swamps[i] = si
	}

	var wg sync.WaitGroup
	wg.Add(swampCount)

	start := time.Now()
	for i := 0; i < swampCount; i++ {
		si := swamps[i]
		go func(swampIdx int) {
			defer wg.Done()
			for j := 0; j < opsPerSwamp; j++ {
				_, _ = si.GetTreasure("treasure")
			}
		}(i)
	}

	wg.Wait()
	elapsed := time.Since(start)
	perOp := elapsed / time.Duration(totalOps)

	t.Logf("MultiSwamp Parallel GET (%d swamps × %d op) — Total: %s\nAverage per op: %s", swampCount, opsPerSwamp, elapsed, perOp)

	// Cleanup
	for _, si := range swamps {
		si.Destroy()
	}
}

--------------------------------------------------------------------------------

/==============================================================================\
| FILE: core\hydra\lock\lock.go
| PATH: C:\go\src\hydraide\app\core\hydra\lock\lock.go
| SIZE: 4.4 KB
\==============================================================================/

package lock

import (
	"context"
	"errors"
	"github.com/google/uuid"
	"sync"
	"time"
)

type Lock interface {
	// Lock queues requests based on a unique key. This is a blocking method and only returns
	// once the calling goroutine receives permission — meaning it is next in line.
	//
	// The ttl parameter defines how long the lock should remain valid.
	// The ttl is always required and must never be zero or omitted.
	//
	// If the ttl expires before the lock is released, the function must return with an error,
	// the lock must be freed, and the next caller in the queue should proceed.
	//
	// If the lock cannot be acquired, the function returns an error.
	//
	// If the lock is successfully acquired, the caller receives a unique lockID,
	// which must later be used in the Unlock method to release the lock.
	//
	// However, if the ttl expires, the lock must still be cleaned up by its lockID
	// to avoid deadlocks.
	Lock(ctx context.Context, key string, ttl time.Duration) (lockID string, err error)
	// Unlock releases a lock that was previously acquired via the Lock method.
	// The lock is released based on the provided lockID.
	//
	// If the given lockID does not exist, the function immediately returns an error.
	Unlock(key string, lockID string) error
}

type lock struct {
	// This map stores the waiting goroutines for each key.
	// Each entry holds a queue struct that contains the waiting goroutines.
	queues sync.Map
}

func New() Lock {
	return &lock{}
}

func newQueue() *queue {
	q := &queue{}
	return q
}

type queue struct {
	mu      sync.RWMutex
	callers []string
}

func (q *queue) AddCaller(caller string) {
	q.mu.Lock()
	defer q.mu.Unlock()
	q.callers = append(q.callers, caller)
}

func (q *queue) DeleteCaller(callerID string) error {

	q.mu.Lock()
	defer q.mu.Unlock()

	for i, caller := range q.callers {

		if caller == callerID {

			// If there are more waiting goroutines, remove the first one from the queue.
			// If the queue is empty, delete the entry entirely.
			if len(q.callers) > 1 {
				q.callers = append(q.callers[:i], q.callers[i+1:]...)
			} else {
				q.callers = []string{}
			}
			return nil

		}
	}

	return errors.New("caller not found")

}

func (q *queue) CanExecute(callerID string) bool {

	q.mu.RLock()
	defer q.mu.RUnlock()

	if len(q.callers) == 0 {
		return true
	}

	return q.callers[0] == callerID

}

// StartAutoUnlock ensures that the lock is forcefully released when the TTL expires.
func (q *queue) StartAutoUnlock(ctx context.Context, callerID string, ttl time.Duration) {

	// Remove the caller after the TTL expires. Whichever timeout comes first will be used.
	// Exit the goroutine immediately afterward.
	t := time.NewTicker(ttl)
	defer t.Stop()

	for {
		select {
		case <-ctx.Done():
			// If the callerID is found in the waiting queue, remove it.
			_ = q.DeleteCaller(callerID)
			return
		case <-t.C:
			_ = q.DeleteCaller(callerID)
			return
		}
	}

}

func (l *lock) Lock(ctx context.Context, key string, ttl time.Duration) (lockID string, err error) {

	// generate lockID
	lockID = uuid.NewString()
	// Retrieve the queue associated with the key, or create it if it doesn't exist.
	q := l.getQueue(key)
	// Add the caller as a waiting entry in the queue.
	q.AddCaller(lockID)

	for {
		select {
		case <-ctx.Done():

			// On timeout, remove the caller from the queue since it can no longer wait.
			_ = q.DeleteCaller(lockID)
			return "", errors.New("lock timeout")

		default:

			// Check if the caller is at the front of the queue.
			if q.CanExecute(lockID) {
				// When granting the lock to the caller, start a goroutine
				// that will automatically release the lock after the TTL expires.
				// This prevents deadlocks in the database that could block other callers.
				// If the lock is released this way, Unlock will return an error
				// indicating that a timeout occurred.
				go q.StartAutoUnlock(ctx, lockID, ttl)
				return lockID, nil
			}

			continue

		}
	}

}

func (l *lock) Unlock(key string, lockID string) error {
	// Retrieve the queue associated with the given key.
	q := l.getQueue(key)
	// Remove the caller from the queue.
	return q.DeleteCaller(lockID)
}

func (l *lock) getQueue(key string) *queue {
	actual, _ := l.queues.LoadOrStore(key, newQueue())
	return actual.(*queue)
}

--------------------------------------------------------------------------------

/==============================================================================\
| FILE: core\hydra\lock\lock_test.go
| PATH: C:\go\src\hydraide\app\core\hydra\lock\lock_test.go
| SIZE: 3.8 KB
\==============================================================================/

package lock

import (
	"context"
	"fmt"
	"github.com/stretchr/testify/assert"
	"sync"
	"testing"
	"time"
)

func TestLockUnlock(t *testing.T) {
	l := New()

	ctx := context.Background()

	lockID, err := l.Lock(ctx, "key1", 2*time.Second)
	assert.NoError(t, err)
	assert.NotEmpty(t, lockID)

	err = l.Unlock("key1", lockID)
	assert.NoError(t, err)
}

func TestParallelLockUnlock(t *testing.T) {
	l := New()

	var wg sync.WaitGroup

	for i := 0; i < 10; i++ {
		wg.Add(1)

		go func() {
			defer wg.Done()
			for j := 0; j < 100; j++ {

				func() {

					key := fmt.Sprintf("key%d", j)

					ctx, cancel := context.WithTimeout(context.Background(), 2*time.Second)
					defer cancel()

					lockID, err := l.Lock(ctx, key, 2*time.Second)
					if err != nil {
						t.Errorf("failed to acquire lock: %v", err)
						return
					}
					assert.NotEmpty(t, lockID)

					// Simulate some work with the lock held
					time.Sleep(10 * time.Millisecond)

					err = l.Unlock(key, lockID)
					if err != nil {
						t.Errorf("failed to release lock: %v", err)
						return
					}

				}()

			}
		}()
	}

	wg.Wait()
}

func TestLockTimeout(t *testing.T) {
	l := New()

	ctx := context.Background()

	// Lock megszerzése, ami 1 másodperc múlva lejár
	lockID, err := l.Lock(ctx, "key1", 1*time.Second)
	assert.NoError(t, err)
	assert.NotEmpty(t, lockID)

	time.Sleep(2 * time.Second) // waiting for the lock to expire

	// Próbáljuk meg újra megszerezni a lockot
	lockID2, err := l.Lock(ctx, "key1", 2*time.Second)
	assert.NoError(t, err)
	assert.NotEmpty(t, lockID2)

	err = l.Unlock("key1", lockID2)
	assert.NoError(t, err)

}

// /home/bearbite/.cache/JetBrains/GoLand2024.1/tmp/GoLand/___BenchmarkLockUnlock_in_github_com_trendizz_hydra_hydra_lock.test -test.v -test.paniconexit0 -test.bench ^\QBenchmarkLockUnlock\E$ -test.run ^$
// goos: linux
// goarch: amd64
// pkg: github.com/hydraide/hydraide/app/core/hydra/lock
// cpu: AMD Ryzen 9 5950X 16-Core Processor
// BenchmarkLockUnlock
// BenchmarkLockUnlock-32    	  533826	      3380 ns/op
// PASS
func BenchmarkLockUnlock(b *testing.B) {
	l := New()

	key := "benchmark_key"

	for i := 0; i < b.N; i++ {

		func() {
			// zárjuk le gyorsan a kontextust minél előbb és ezzel szabadítsuk fel a lockot
			ctx, cancel := context.WithTimeout(context.Background(), 2*time.Second)
			defer cancel()
			lockID, err := l.Lock(ctx, key, 2*time.Second)
			if err != nil {
				b.Fatalf("failed to acquire lock: %v", err)
			}
			err = l.Unlock(key, lockID)
			if err != nil {
				b.Fatalf("failed to release lock: %v", err)
			}
		}()

	}

}

// /home/bearbite/.cache/JetBrains/GoLand2024.1/tmp/GoLand/___BenchmarkParallelLockUnlock_in_github_com_trendizz_hydra_hydra_lock.test -test.v -test.paniconexit0 -test.bench ^\QBenchmarkParallelLockUnlock\E$ -test.run ^$
// goos: linux
// goarch: amd64
// pkg: github.com/hydraide/hydraide/app/core/hydra/lock
// cpu: AMD Ryzen 9 5950X 16-Core Processor
// BenchmarkParallelLockUnlock
// BenchmarkParallelLockUnlock-32    	    8298	    281452 ns/op
// PASS
func BenchmarkParallelLockUnlock(b *testing.B) {
	l := New()
	keys := []string{"key1", "key2", "key3", "key4", "key5"}

	b.RunParallel(func(pb *testing.PB) {
		for pb.Next() {
			for _, key := range keys {

				func() {

					ctx, cancel := context.WithTimeout(context.Background(), 2*time.Second)
					defer cancel()

					lockID, err := l.Lock(ctx, key, 2*time.Second)
					if err != nil && err.Error() != "lock timeout" {
						b.Fatalf("failed to acquire lock: %v", err)
					}

					if err == nil {
						err = l.Unlock(key, lockID)
						if err != nil {
							b.Fatalf("failed to release lock: %v", err)
						}
					}

				}()

			}
		}
	})
}

--------------------------------------------------------------------------------

/==============================================================================\
| FILE: core\hydra\stringid\stringid.go
| PATH: C:\go\src\hydraide\app\core\hydra\stringid\stringid.go
| SIZE: 820.0 B
\==============================================================================/

// Package stringid is used to generate strictly increasing, unique string-based IDs
// starting from a given numeric value. These IDs are sortable using plain string sorting,
// either in ascending or descending order.
//
// This allows consistent, predictable ordering of keys (such as treasures) within a swamp.
package stringid

// New generates a unique string ID suitable for lexicographic (ascending) ordering,
// based on the given numeric input. The resulting string looks like:
// 0 -> aaaaaaa, 1 -> aaaaaab, etc.
//
// Swamp returns the number of treasures within a swamp and the next ID to be used.
func New(num int) string {
	chars := "abcdefghijklmnopqrstuvwxyz"
	result := make([]byte, 7)
	for i := 6; i >= 0; i-- {
		result[i] = chars[num%26]
		num /= 26
	}
	return string(result)
}

--------------------------------------------------------------------------------

/==============================================================================\
| FILE: core\hydra\stringid\stringid_test.go
| PATH: C:\go\src\hydraide\app\core\hydra\stringid\stringid_test.go
| SIZE: 1.3 KB
\==============================================================================/

package stringid

import (
	"sort"
	"strconv"
	"testing"
)

// TestNew tests the New function with various input values.
func TestNew(t *testing.T) {
	// Input numbers and their expected string ID results to be tested.
	tests := []struct {
		num  int
		want string
	}{
		{0, "aaaaaaa"},
		{1, "aaaaaab"},
		{25, "aaaaaaz"},
		{26, "aaaaaba"},
		{27, "aaaaabb"},
		{676, "aaaabaa"}, // 26^2
		{703, "aaaabbb"}, // 26^2 + 26
		{1000000, "aacexho"},
	}

	// Check if the generated IDs match the expected results.
	for _, tt := range tests {
		t.Run(strconv.Itoa(tt.num), func(t *testing.T) {
			got := New(tt.num)
			if got != tt.want {
				t.Errorf("New(%d) = %v, want %v", tt.num, got, tt.want)
			}
		})
	}

	// Verify that the generated IDs are in the correct order.
	ids := make([]string, 0, len(tests))
	for _, tt := range tests {
		ids = append(ids, New(tt.num))
	}
	if !sort.StringsAreSorted(ids) {
		t.Error("Generated IDs are not in sorted order")
	}
}

// goos: windows
// goarch: amd64
// pkg: github.com/hydraide/hydraide/app/core/hydra/stringid
// cpu: AMD Ryzen 9 5950X 16-Core Processor
// BenchmarkNew
// BenchmarkNew-32         128173084                9.328 ns/op
// PASS
func BenchmarkNew(b *testing.B) {
	for i := 0; i < b.N; i++ {
		New(i)
	}
}

--------------------------------------------------------------------------------

/==============================================================================\
| FILE: core\hydra\swamp\beacon\beacon.go
| PATH: C:\go\src\hydraide\app\core\hydra\swamp\beacon\beacon.go
| SIZE: 54.0 KB
\==============================================================================/

// Package beacon is the beacon package for the swamp. We can store treasures in different orders in the beacon, and the beacon
// helps us find the treasures in the beacon. The beacon is several maps of treasures, and the beacon is a map of indexes.
// Beacons always exist only in the Memory
package beacon

import (
	"errors"
	"fmt"
	"github.com/hydraide/hydraide/app/core/hydra/swamp/treasure"
	"maps"
	"sort"
	"sync"
	"sync/atomic"
	"time"
)

type Beacon interface {

	// GetAll retrieves all treasures from the beacon's internal data structures.
	// The function ensures thread-safety by acquiring a read transaction to prevent concurrent write operations.
	//
	// Returns:
	// - map[string]treasure.Treasure: A map of treasures, where the keys are the unique identifiers for the treasures.
	//
	// Side Effects:
	// - None.
	//
	// When to Use This Function:
	// 1. When you need to access all treasures stored in the beacon's internal data structures for read-only
	// operations or further processing.
	GetAll() map[string]treasure.Treasure

	// Count retrieves the total number of unique treasures (represented by their keys) in an ordered beacon object.
	// The function is thread-safe, utilizing read locks to prevent race conditions.
	//
	// Returns:
	// - int: The number of unique treasures stored in the beacon's treasuresByKeys map.
	//
	// Side Effects:
	// - Sets the 'initialized' flag of the beacon to 1, indicating that the beacon object has been accessed.
	//
	// Usage:
	// This function is useful in scenarios such as:
	// 1. Monitoring the total number of treasures in the beacon for system health and performance checks.
	// 2. Decision-making based on the current resource count in the beacon.
	// 3. Validating whether a bulk addition or removal operation has achieved the desired state.
	Count() int

	// PushManyFromMap adds multiple treasures to both the beacon's internal unordered map
	// (treasuresByKeys) and to its ordered slice (treasuresByOrder), if the beacon is set
	// to maintain an ordered list.
	//
	// The function is designed to be thread-safe, locking the beacon object to prevent
	// concurrent modifications that could result in data inconsistencies.
	//
	// Parameters:
	// - treasures map[string]treasure.Treasure: A map of treasures to be added.
	//   The keys serve as the unique identifiers for the treasures.
	//
	// Side Effects:
	// - The function modifies the internal map of the beacon object (treasuresByKeys) to
	//   include the new treasures.
	// - If the beacon is set to maintain an ordered list of treasures (isOrdered == true),
	//   the function also appends these new treasures to the internal ordered slice
	//   (treasuresByOrder).
	//
	// When to Use This Function:
	// 1. For batch operations where multiple treasures need to be added simultaneously
	//    for efficiency reasons.
	// 2. When initially populating the beacon object from an external data source,
	//    like a database or another API.
	// 3. During data synchronization tasks where the beacon's internal data structures
	//    need to be updated to match an external source.
	// 4. For any operations involving bulk transfers or modifications of treasures
	//    within or across beacon objects.
	PushManyFromMap(treasures map[string]treasure.Treasure)

	// Add inserts a new treasure into the beacon's internal data structures.
	// The function ensures thread-safety by using a mutex transaction to prevent concurrent
	// modifications. It only adds the treasure if it doesn't already exist in the beacon's
	// map (treasuresByKeys).
	//
	// Parameters:
	// - d treasure.Treasure: The treasure object to be added. The object must implement
	//   a GetKey() method that returns a unique identifier for the treasure.
	//
	// Side Effects:
	// - If the treasure's key is not already in the map, the function adds the treasure
	//   to the internal map of the beacon object (treasuresByKeys).
	// - If the beacon is set to maintain an ordered list (isOrdered == true),
	//   the function also appends the new treasure to the ordered slice (treasuresByOrder).
	//
	// When to Use This Function:
	// 1. When you need to insert a new treasure object into the beacon's internal data
	//    structures and you want to ensure that the object is unique (based on its key).
	// 2. During real-time operations where new treasures are discovered and need to
	//    be immediately added to the beacon.
	// 3. In scenarios where a specific order of the treasures is required, and the beacon
	//    is set to maintain an ordered list.
	Add(d treasure.Treasure)

	// Get retrieves a treasure object from the beacon's internal data structures based on
	// a provided unique key. The function ensures thread-safety by acquiring a read transaction
	// to prevent concurrent write operations.
	//
	// Parameters:
	// - key string: The unique identifier for the treasure object to be retrieved.
	//
	// Returns:
	// - d treasure.Treasure: The treasure object associated with the given key.
	//                        Returns nil if the key does not exist in the map.
	//
	// Side Effects:
	// - None.
	//
	// When to Use This Function:
	// 1. When you need to access a specific treasure object from the beacon's internal data
	//    structures for read-only operations or further processing.
	// 2. For real-time query functionalities where a fast, thread-safe access to a specific
	//    treasure object is required.
	// 3. During debugging or logging procedures where you need to quickly inspect a specific
	//    treasure object based on its unique key.
	Get(key string) (d treasure.Treasure)

	// GetManyFromOrderPosition retrieves a slice of treasure objects from the beacon's
	// ordered list, starting from a specified offset position and up to a specified limit.
	// This function ensures thread-safety by acquiring a read transaction to prevent concurrent
	// write operations.
	//
	// Parameters:
	// - from int: The offset index from where to start retrieving the treasure objects.
	// - limit int: The maximum number of treasure objects to retrieve.
	//
	// Returns:
	// - []treasure.Treasure: A slice containing the retrieved treasure objects.
	// - error: An error object if the operation is unsuccessful. Reasons for failure can
	//          include the beacon not being ordered or if the 'from' parameter exceeds
	//          the number of available elements.
	//
	// Side Effects:
	// - None.
	//
	// When to Use This Function:
	// 1. For paginated retrieval of treasures where you need to fetch a specific range
	//    of treasure objects from the ordered list.
	// 2. For partial loading or 'infinite scroll' functionalities in a frontend application.
	// 3. During logging or debugging procedures to inspect a range of treasure objects.
	// 4. When constructing reports or analytics and you need to access a specific subset
	//    of ordered treasure objects for calculations or summary.
	GetManyFromOrderPosition(from int, limit int) ([]treasure.Treasure, error)

	// GetManyFromKey retrieves a slice of treasure objects starting from a specified key
	// up to a given limit. The function sorts the returned treasures based on their creation time.
	// This function ensures thread-safety by acquiring a read transaction and releases individual treasures'
	// guards after cloning.
	//
	// Parameters:
	// - fromKey *string: The key from where to start retrieving treasure objects.
	//                     If nil, starts from the beginning.
	// - limit *int32: The maximum number of treasure objects to retrieve. If nil, the default limit is 100.
	//
	// Returns:
	// - []treasure.Treasure: A sorted slice containing the retrieved and cloned treasure objects.
	// - error: An error object if the operation is unsuccessful, e.g., if the beacon is not ordered.
	//
	// Side Effects:
	// - Locks and releases individual treasure guards for cloning.
	//
	// When to Use This Function:
	// 1. For filtered retrieval of treasures starting from a specific key in an ordered list.
	// 2. To clone and isolate specific treasures for localized modifications or computations.
	// 3. For constructing analytics reports where the dataset starts from a particular key.
	// 4. For incremental data loading scenarios in both front-end and back-end operations.
	// 5. During logging or debugging procedures to inspect a range of treasure objects based on a key.
	GetManyFromKey(fromKey *string, limit *int32) ([]treasure.Treasure, error)

	// FilterOrderedTreasures filters the treasures stored in a beacon object based on the provided filter function.
	// It returns a slice of treasures that meet the filter criteria and an error if the beacon is not ordered.
	//
	// Parameters:
	// - filterFunc: A callback function that takes a Treasure object as input and returns a boolean.
	//               Only the Treasure objects for which this function returns true will be included in the result.
	// - howMany: The maximum number of Treasure objects to include in the returned slice.
	// - remove: A boolean indicating whether to remove the filtered treasures from the beacon object.
	//
	// Returns:
	// - []Treasure: A slice of Treasure objects that meet the filter criteria.
	// - error: An error object if the beacon is not ordered, otherwise nil.
	//
	// Usage:
	// This function can be useful in various scenarios such as:
	// 1. Finding treasures that are overdue for maintenance and removing them.
	// 2. Quickly locating high-value treasures for a priority task.
	// 3. Extracting a subset of treasures based on certain characteristics (e.g., type, age, value).
	//
	// Thread-Safety:
	// The function is thread-safe, it locks the beacon object during its operation to prevent race conditions.
	//
	// Example:
	// filterFunc := func(t treasure.Treasure) bool {
	//     return t.Value > 10
	// }
	// treasures, err := myBeacon.FilterOrderedTreasures(filterFunc, 5, true)
	// if err != nil {
	//     log.Fatal(err)
	// }
	// fmt.Println("Filtered treasures:", treasures)
	//
	// Example 2:
	// Data Cleanup: Let's say you have a pool of treasures, and you want to clean up those that are not in active use or have been marked as obsolete. You can use this function to find and remove them.
	// filterObsolete := func(t treasure.Treasure) bool {
	//    return t.Status == "obsolete"
	// }
	// _, err := beaconObj.FilterOrderedTreasures(filterObsolete, 10, true)
	// if err != nil {
	//    log.Println("Error:", err)
	// }
	FilterOrderedTreasures(filterFunc func(treasureObj treasure.Treasure) bool, howMany int, remove bool) ([]treasure.Treasure, error)

	// Delete removes a treasure object with a specified key from both the treasuresByKeys map and
	// the treasuresByOrder slice, if ordering is enabled. The function ensures thread-safety by
	// acquiring a write transaction before performing deletion operations.
	//
	// Parameters:
	// - key string: The key of the treasure object to be deleted.
	//
	// Side Effects:
	// - Modifies the treasuresByKeys map by removing the specified key-value pair.
	// - Modifies the treasuresByOrder slice by removing the element with the specified key, if ordering is enabled.
	//
	// When to Use This Function:
	// 1. When you need to remove a specific treasure object identified by its key, either due to user action or some internal condition.
	// 2. To clean up resources or to maintain a cap on the number of stored treasures in certain scenarios.
	// 3. To facilitate dynamic updates to the stored data without restarting the application or service.
	// 4. In caching scenarios where you need to evict certain items based on custom logic or policies.
	// 5. During data synchronization tasks between different systems or services, where certain items need to be removed for consistency.
	Delete(key string)

	// ShiftOne removes a treasure object with a specified key from both the treasuresByKeys map and
	// the treasuresByOrder slice, and returns the removed treasure. The function ensures thread-safety by
	// acquiring a write transaction before performing the deletion and retrieval operations.
	//
	// Parameters:
	// - key string: The key of the treasure object to be deleted and returned.
	//
	// Returns:
	// - d treasure.Treasure: The deleted treasure object, if found. Otherwise, it returns nil.
	//
	// Side Effects:
	// - Modifies the treasuresByKeys map by removing the specified key-value pair.
	// - Modifies the treasuresByOrder slice by removing the element with the specified key, if ordering is enabled.
	//
	// When to Use This Function:
	// 1. When you need to both remove and retrieve a specific treasure object identified by its key.
	// 2. In scenarios where an element needs to be moved from one collection to another.
	// 3. When implementing deque (double-ended queue) behaviors, where an item can be removed from the front or back of the list.
	// 4. During data synchronization tasks between different systems or services, where items need to be processed and then removed.
	// 5. In caching scenarios where you need to evict certain items and move them to a different data structure or storage.
	ShiftOne(key string) (d treasure.Treasure)

	// ShiftMany removes a specified number of treasure objects from the treasuresByOrder slice
	// and the corresponding entries from the treasuresByKeys map. It returns the removed treasures
	// as a slice. Thread-safety is ensured via a write transaction.
	//
	// Parameters:
	// - howMany int: The number of treasures to remove and return.
	//
	// Returns:
	// - []treasure.Treasure: A slice of removed treasure objects.
	//
	// Side Effects:
	// - Modifies treasuresByKeys by removing keys corresponding to shifted treasures.
	// - Modifies treasuresByOrder by removing the shifted treasures.
	//
	// When to Use This Function:
	// 1. When you need to bulk-remove and retrieve a specific number of treasures.
	// 2. In queue-like scenarios, where the first 'howMany' elements should be processed and removed.
	// 3. When you need to move a set number of elements from one data structure to another.
	// 4. For implementing rate-limiting mechanisms or load balancers that distribute a certain number of tasks/items.
	// 5. For evicting a set number of items in a cache as part of a cache eviction strategy.
	ShiftMany(howMany int) []treasure.Treasure

	// ShiftExpired removes and returns a specified number of expired treasure objects
	// from the treasuresByOrder slice and the corresponding entries from the treasuresByKeys map.
	// Expired treasures are identified based on their expiration time. Thread safety is ensured via a write transaction.
	//
	// Parameters:
	// - howMany int: The maximum number of expired treasures to remove and return.
	//
	// Returns:
	// - []treasure.Treasure: A slice of removed, expired treasure objects.
	//
	// Side Effects:
	// - Modifies treasuresByKeys by removing keys corresponding to shifted expired treasures.
	// - Modifies treasuresByOrder by removing the shifted expired treasures.
	//
	// When to Use This Function:
	// 1. In scenarios where stale or outdated data should be removed.
	// 2. For implementing cache eviction based on time expiration.
	// 3. To free up resources or decrease memory footprint by removing expired data.
	// 4. For data archival or backup processes that operate on expired data before removal.
	// 5. When implementing rate-limiting or leasing systems where expired items should be processed separately.
	ShiftExpired(howMany int) []treasure.Treasure

	// CloneOrderedTreasures clones and returns all treasure objects from the treasuresByOrder slice.
	// Optionally, it also resets the internal state of the beacon based on the 'thenReset' flag.
	// Thread safety is ensured via a write transaction.
	//
	// Parameters:
	// - thenReset bool: Flag to determine whether or not to reset the internal state of the beacon.
	//
	// Returns:
	// - []treasure.Treasure: A clone of all the ordered treasure objects in the beacon.
	//
	// Side Effects:
	// - If thenReset is true, empties treasuresByOrder and clears treasuresByKeys map.
	//
	// When to Use This Function:
	// 1. To get a snapshot of the current state of treasures for external processing without affecting the internal state.
	// 2. To reset the internal state after cloning, useful for garbage collection or resource management.
	// 3. When implementing features like data export, data snapshot, or backup.
	// 4. For debugging and testing, where a non-mutating copy of data is required.
	// 5. In cases where you want to pass a copy of the internal data to another service or component without the risk of mutation.
	CloneOrderedTreasures(thenReset bool) []treasure.Treasure

	// CloneUnorderedTreasures clones and returns all treasure objects from the treasuresByKeys map.
	// Optionally, it also resets the internal state of the beacon based on the 'thenReset' flag.
	// Thread safety is ensured via a write transaction.
	//
	// Parameters:
	// - thenReset bool: Flag to determine whether or not to reset the internal state of the beacon.
	//
	// Returns:
	// - map[string]treasure.Treasure: A clone of all the unordered treasure objects in the beacon.
	//
	// Side Effects:
	// - If thenReset is true, empties treasuresByOrder and clears treasuresByKeys map.
	//
	// When to Use This Function:
	// 1. To get a snapshot of the current state of treasures for external processing without affecting the internal state.
	// 2. To reset the internal state after cloning, which can be useful for garbage collection or resource management.
	// 3. When implementing features like data analytics, exporting the data, or backup.
	// 4. For debugging and testing, where a non-mutating copy of data is essential.
	// 5. In scenarios where you want to pass a copy of the internal data to another service or component without the risk of mutation.
	CloneUnorderedTreasures(thenReset bool) map[string]treasure.Treasure

	// SetIsOrdered controls whether the beacon will maintain the order of treasures or not.
	// If set to true, the function makes sure the beacon uses the treasuresByOrder slice for storing and managing treasures.
	// Thread safety is ensured via a write transaction.
	//
	// Parameters:
	// - isOrdered bool: Flag indicating whether or not to maintain order of the treasures.
	//
	// Side Effects:
	// 1. If isOrdered is false, clears the treasuresByOrder slice.
	// 2. If isOrdered is true, copies the treasures from the unordered map to the ordered slice.
	//
	// When to Use This Function:
	// 1. To switch between ordered and unordered storage dynamically based on the requirements.
	// 2. For implementing features like sorting and prioritizing of treasures, enabling functionalities like First-In-First-Out or sorted access.
	// 3. When starting to add new features that require ordering, this function can be used to toggle that behavior on.
	// 4. As a configuration setting that might be tweaked during runtime or for different deployment scenarios.
	//
	// Use-Cases for Trendizz:
	// - When you need to perform ordered operations, like sorted exports or batch processing in a specific sequence, this function is crucial.
	// - During reporting or analytics where the sequence of treasures may carry important information or insights.
	SetIsOrdered(isOrdered bool)

	// IsOrdered checks whether the beacon is set to maintain the order of treasures or not.
	// It's a thread-safe operation, protected by a read transaction.
	//
	// Returns:
	// - bool: The value of the isOrdered flag.
	//
	// Side Effects:
	// - None.
	//
	// When to Use This Function:
	// 1. When you need to conditionally execute code that depends on whether the treasure storage is ordered or not.
	// 2. For logging or debugging purposes, to confirm the internal state of the beacon.
	// 3. As a pre-check before calling other functions that have different behaviors based on ordering.
	// 4. To understand system behavior and settings dynamically during runtime.
	//
	// Use-Cases for Trendizz:
	// - To decide whether to perform operations that rely on the order of elements. For example, in analytics or reporting, the ordered state can affect how data is aggregated or displayed.
	// - For diagnostics and system checks, this function can be used to confirm system behavior or during troubleshooting.
	IsOrdered() bool

	// IsInitialized checks if the beacon is initialized. It's a thread-safe operation, protected by a read transaction.
	//
	// Returns:
	// - bool: Returns true if initialized (b.initialized == 1), false otherwise.
	//
	// Side Effects:
	// - None.
	//
	// When to Use This Function:
	// 1. Before performing operations that should only be executed on an initialized beacon.
	// 2. For logging or debugging to know the initialization state of the beacon.
	// 3. As a condition in tests to ensure the beacon is initialized before running specific test cases.
	//
	// Use-Cases for Trendizz:
	// - To ensure that the system or certain modules/components only interact with an initialized beacon. This is crucial for ensuring data consistency and system integrity.
	// - For diagnostic purposes, you can use this function to understand the system's state at any point.
	IsInitialized() bool

	// SetInitialized sets the initialization status of the beacon object to true or false. This operation is atomic.
	//
	// Parameters:
	// - init: The initialization status to set, either true or false.
	//
	// Returns:
	// - None
	//
	// Side Effects:
	// - Updates the 'initialized' field in the beacon object.
	//
	// When to Use This Function:
	// 1. After the beacon has been fully set up and is ready for use, to signal to other parts of the system that it's safe to interact with this beacon.
	// 2. During testing, to simulate an uninitialized or initialized beacon to see how other components react.
	// 3. When shutting down or resetting the beacon, you may want to set it to uninitialized to prevent other operations.
	//
	// Use-Cases for Trendizz:
	// - Use it to set the initialization status as part of the boot-up sequence.
	// - Before taking the beacon out of service for maintenance or updates, set it to uninitialized to ensure that no unwanted operations are carried out on an inconsistent state.
	// - When dynamically adding or removing beacons, use this to set their initialization state appropriately.
	SetInitialized(init bool)

	// Reset resets the internal state of the beacon object. This clears all treasures and sets the initialization status to false (or uninitialized).
	//
	// Parameters:
	// - None
	//
	// Returns:
	// - None
	//
	// Side Effects:
	// - Resets the 'treasuresByKeys' map to an empty map.
	// - Sets the 'treasuresByOrder' slice to nil.
	// - Sets the 'initialized' flag to 0 (uninitialized).
	//
	// When to Use This Function:
	// 1. When you want to clean up the beacon's internal state for whatever reason (e.g., before re-initialization, before shutting down, or after a certain operation).
	// 2. During testing, to bring the beacon back to an initial state.
	// 3. To reset the beacon state when a fatal error occurs, to restart it clean.
	//
	// Use-Cases for Trendizz:
	// - If we're modifying our treasure storage logic or switching between ordered and unordered modes, this can act as a reset button.
	// - During scheduled maintenance or updates, you can reset the beacon and then initialize it with new data or configurations.
	// - If there's an issue and we detect that the beacon has reached an inconsistent state, reset and reinitialize.
	Reset()

	// IsExists checks if a treasure with the given key exists within the beacon.
	//
	// Parameters:
	// - key: The string identifier for the treasure.
	//
	// Returns:
	// - ContentTypeBoolean: true if the treasure exists, false otherwise.
	//
	// Side Effects:
	// - Sets the 'initialized' flag to 1 (true) before proceeding.
	//
	// When to Use This Function:
	// 1. To confirm the existence of a particular treasure before attempting to read or manipulate it.
	// 2. As a condition check in other methods that require the treasure to exist for their logic.
	// 3. To prevent duplicate entries by checking the existence first before adding a new treasure.
	//
	// Use-Cases for Trendizz:
	// - To verify the existence of a particular indexed page or content before performing search operations.
	// - To check if certain data is already indexed or not, hence optimizing the process of indexing.
	// - To improve error handling by not proceeding with operations that require an existing treasure.
	//
	// Note:
	// The function uses read-transaction (RLock) to ensure multiple read operations can occur simultaneously without blocking each other while preserving data integrity.
	IsExists(key string) bool

	// SortBy... Common Functionality:
	// 1. Each sorting function first locks the beacon instance using the internal mutex `mu` to ensure thread safety during the sorting operation.
	// 2. It then checks if the beacon is ordered (`isOrdered`). If it's not ordered, an error will be returned.
	// 3. Finally, the function uses Go's built-in `sort.Slice()` method to sort the `treasures` slice based on the given attribute.
	//
	// Use Cases:
	// - Dynamic Search Parameters: Allow users to sort results based on their preferred attributes.
	// - Analytics and Reporting: Easily generate sorted lists for further analysis.
	// - Optimized Data Access: Faster retrieval of data due to pre-sorted lists.
	// - Cache Strategy: Facilitate cache eviction strategies by sorting by expiration time.
	//
	// Common Error Handling:
	// - All sorting functions will return an error if the `isOrdered` flag is not set, ensuring uniform error handling across all sorting functions.
	//
	// Performance and Scalability:
	// - Proper implementation of these functions should not introduce significant performance overhead but will increase the codebase's maintainability and readability.
	//
	// Designed to facilitate the development and maintainability of Trendizz's core SaaS offering.

	SortByCreationTimeAsc() error
	SortByCreationTimeDesc() error
	SortByKeyAsc() error
	SortByKeyDesc() error
	SortByExpirationTimeAsc() error
	SortByExpirationTimeDesc() error
	SortByUpdateTimeAsc() error
	SortByUpdateTimeDesc() error

	SortByValueFloat32ASC() error
	SortByValueFloat32DESC() error
	SortByValueFloat64ASC() error
	SortByValueFloat64DESC() error

	SortByValueUint8ASC() error
	SortByValueUint8DESC() error
	SortByValueUint16ASC() error
	SortByValueUint16DESC() error
	SortByValueUint32ASC() error
	SortByValueUint32DESC() error
	SortByValueUint64ASC() error
	SortByValueUint64DESC() error

	SortByValueInt8ASC() error
	SortByValueInt8DESC() error
	SortByValueInt16ASC() error
	SortByValueInt16DESC() error
	SortByValueInt32ASC() error
	SortByValueInt32DESC() error
	SortByValueInt64ASC() error
	SortByValueInt64DESC() error

	SortByValueStringASC() error
	SortByValueStringDESC() error

	// Iterate goes through each treasure in the beacon's `treasuresByKeys` map and calls the given `iterFunc` with the treasure object as its parameter. It's designed to provide a unified approach for iterating over all the elements in a beacon instance while ensuring thread safety.
	//
	// How it Works:
	// 1. Locks the beacon instance for reading using the read-transaction (`RLock()`) from the internal mutex `mu` to prevent any writes during the iteration. The read-transaction allows multiple goroutines to read the beacon concurrently.
	// 2. Iterates over the treasures, invoking the provided `iterFunc` on each. If `iterFunc` returns `false`, the iteration will break immediately.
	// 3. Unlocks the beacon instance automatically using `defer`, ensuring that the transaction is released after the function returns.
	//
	// Usage Scenarios:
	// - Bulk Operations: Perform operations like logging, transformations, or validation on all treasures in a beacon.
	// - Analytics: Extract information or statistics about the current state of treasures in the beacon.
	// - Debugging: A convenient way to examine the current elements during debugging sessions.
	//
	// Considerations:
	// - The function is blocking and locks the entire beacon for reading, so consider the performance implications if you have a large number of treasures or if the `iterFunc` performs time-consuming operations.
	// - Use the `Clone` methods if you need to perform iterations without locking the beacon.
	//
	// Concurrency:
	// - Because the function uses a read-transaction, other goroutines can still read the beacon concurrently, but no writes will be allowed during the iteration.
	//
	// This function is crucial for implementing various features and capabilities in Trendizz's core SaaS offering, ensuring that we maintain the high level of quality and performance that our B2B customers expect.
	//
	Iterate(iterFunc func(treasureObj treasure.Treasure) bool, it IterationType)
}

type beacon struct {
	mu              sync.RWMutex
	treasuresByKeys map[string]treasure.Treasure
	// treasuresByOrder is used for storing Treasures in the order they were added to the beacon, or can be sorted by
	// other sorters like expiration time, creation time, etc...
	treasuresByOrder []treasure.Treasure
	// initialized is used for initializing the treasure only once
	// We use the initialized field to determine whether anything has used the beacon before.
	// Instantiation alone does not initialize the beacon, but its first use does. This is necessary because we need
	// to know if there was anything that wants to use the beacon, as the beacon needs to be built only in this case.
	initialized int32
	// isOrdered true if we want to keep the treasures in treasuresByOrder too.
	// The beacon will also use the treasuresByOrder slice for storing treasures. This becomes necessary when we want to sort
	// the treasures, whether based on the time they were added, or through more complex sorting such as by expiration date
	// etc... Don't forget to set the value to True, otherwise the beacon won't handle the treasuresByOrder array, and it will
	// always be empty!
	isOrdered bool
}

// New returns a new beacon
func New() Beacon {
	return &beacon{
		treasuresByKeys: make(map[string]treasure.Treasure),
	}
}

// GetAll returns all the treasures in the beacon
func (b *beacon) GetAll() map[string]treasure.Treasure {
	b.mu.RLock()
	defer b.mu.RUnlock()
	return b.treasuresByKeys
}

type IterationType int

const (
	// IterationTypeOrdered iteration by the ordered slice
	IterationTypeOrdered IterationType = iota + 1
	// IterationTypeKey iteration by the keys map
	IterationTypeKey
)

// Iterate iterates over the beacon and calls the iterFunc for each treasure
// The whole beacon is locked during the iteration so that no other goroutine can modify or read the beacon while we are
// iterating. Use the Clone methods if you want to iterate over the beacon without locking it.
func (b *beacon) Iterate(iterFunc func(treasureObj treasure.Treasure) bool, it IterationType) {

	b.mu.RLock()
	defer b.mu.RUnlock()

	if it == IterationTypeKey {
		for _, treasureObj := range b.treasuresByKeys {
			if !iterFunc(treasureObj) {
				break
			}
		}
		return
	} else if it == IterationTypeOrdered {
		for _, treasureObj := range b.treasuresByOrder {
			if !iterFunc(treasureObj) {
				break
			}
		}
		return
	}

	return

}

// Get returns the element with the given key
func (b *beacon) Get(key string) (d treasure.Treasure) {
	atomic.StoreInt32(&b.initialized, 1)
	b.mu.RLock()
	defer b.mu.RUnlock()
	if treasureObj, ok := b.treasuresByKeys[key]; ok {
		return treasureObj
	}
	return nil
}

// SetIsOrdered sets the isOrdered flag to true or false
// The beacon will also use the treasuresByOrder slice for storing treasures. This becomes necessary when we want to sort
// the treasures, whether based on the time they were added, or through more complex sorting such as by expiration date
// etc... SetIsOrdered automatically copies the unordered treasures to the ordered slice (reset it, then copy the unordered treasures)
func (b *beacon) SetIsOrdered(isOrdered bool) {

	b.mu.Lock()
	defer b.mu.Unlock()

	if b.isOrdered == isOrdered {
		return
	}

	// clear the isOrdered slice if we don't want to keep the ordered treasures
	if !isOrdered {
		b.treasuresByOrder = nil // reset the ordered treasures slice
		b.isOrdered = isOrdered  // set the isOrdered flag
		return
	}

	// copy the unordered treasures to the ordered treasures
	for _, treasureObj := range b.treasuresByKeys {
		b.treasuresByOrder = append(b.treasuresByOrder, treasureObj)
	}

	b.isOrdered = isOrdered

}

// IsOrdered returns the isOrdered flag that we set when the beacon was created
func (b *beacon) IsOrdered() bool {
	b.mu.RLock()
	defer b.mu.RUnlock()
	return b.isOrdered
}

// SetInitialized set the initialized status to true or false
func (b *beacon) SetInitialized(init bool) {
	if init {
		atomic.StoreInt32(&b.initialized, 1)
		return
	}
	atomic.StoreInt32(&b.initialized, 0)
}

// IsInitialized returns the initialized flag
func (b *beacon) IsInitialized() bool {
	b.mu.RLock()
	defer b.mu.RUnlock()
	return b.initialized == 1
}

func (b *beacon) Reset() {
	b.mu.Lock()
	defer b.mu.Unlock()
	b.treasuresByKeys = make(map[string]treasure.Treasure)
	b.treasuresByOrder = nil
	atomic.StoreInt32(&b.initialized, 0)
}

// PushManyFromMap add elements to the main unordered map and the ordered slice too if,
// the ordered list is enabled
func (b *beacon) PushManyFromMap(treasures map[string]treasure.Treasure) {
	b.mu.Lock()
	defer b.mu.Unlock()
	maps.Copy(b.treasuresByKeys, treasures)
	// add elements to the ordered treasure if there is any ordered treasures
	if b.isOrdered {
		for _, treasureObj := range treasures {
			b.treasuresByOrder = append(b.treasuresByOrder, treasureObj)
		}
	}
}

// Add adds a new element to the beacon
func (b *beacon) Add(d treasure.Treasure) {
	atomic.StoreInt32(&b.initialized, 1)
	// add element if the key is not in the map
	b.mu.Lock()
	defer b.mu.Unlock()
	if _, ok := b.treasuresByKeys[d.GetKey()]; !ok {
		b.treasuresByKeys[d.GetKey()] = d
		if b.isOrdered {
			b.treasuresByOrder = append(b.treasuresByOrder, d)
		}
	}
}

// Delete removes the element with the given key
func (b *beacon) Delete(key string) {

	atomic.StoreInt32(&b.initialized, 1)

	b.mu.Lock()
	defer b.mu.Unlock()

	if _, ok := b.treasuresByKeys[key]; ok {
		delete(b.treasuresByKeys, key)
	}

	//* delete from treasuresByOrder slice
	//* delete from desc slice
	if b.isOrdered {
		for index, treasureObj := range b.treasuresByOrder {
			if treasureObj.GetKey() == key {
				b.treasuresByOrder = append(b.treasuresByOrder[:index], b.treasuresByOrder[index+1:]...)
				break
			}
		}
	}

}

// IsExists checks if the key exists in the beacon
func (b *beacon) IsExists(key string) bool {

	atomic.StoreInt32(&b.initialized, 1)

	b.mu.RLock()
	defer b.mu.RUnlock()

	if _, ok := b.treasuresByKeys[key]; ok {
		return true
	}

	return false

}

func (b *beacon) Count() int {

	atomic.StoreInt32(&b.initialized, 1)

	b.mu.RLock()
	defer b.mu.RUnlock()

	return len(b.treasuresByKeys)

}

// ShiftOne removes the element with the given key and returns it
func (b *beacon) ShiftOne(key string) (d treasure.Treasure) {

	atomic.StoreInt32(&b.initialized, 1)

	b.mu.Lock()
	defer b.mu.Unlock()

	if _, ok := b.treasuresByKeys[key]; ok {
		d = b.treasuresByKeys[key]
		delete(b.treasuresByKeys, key)

		if b.isOrdered {
			for indx, treasureObj := range b.treasuresByOrder {
				if treasureObj.GetKey() == key {
					b.treasuresByOrder = append(b.treasuresByOrder[:indx], b.treasuresByOrder[indx+1:]...)
					break
				}
			}
		}
	}
	return
}

// ShiftMany removes the element with the given numbers and returns them
func (b *beacon) ShiftMany(howMany int) []treasure.Treasure {

	atomic.StoreInt32(&b.initialized, 1)

	b.mu.Lock()
	defer b.mu.Unlock()

	var shiftedTreasures []treasure.Treasure
	var remainingTreasures []treasure.Treasure
	counter := 0
	for _, treasureObj := range b.treasuresByOrder {
		if counter < howMany {
			lockID := treasureObj.StartTreasureGuard(true)
			clonedTreasure := treasureObj.Clone(lockID)
			treasureObj.ReleaseTreasureGuard(lockID)
			shiftedTreasures = append(shiftedTreasures, clonedTreasure)
			delete(b.treasuresByKeys, treasureObj.GetKey())
			counter++
		} else {
			remainingTreasures = append(remainingTreasures, treasureObj)
		}
	}
	b.treasuresByOrder = remainingTreasures
	return shiftedTreasures

}

func (b *beacon) ShiftExpired(howMany int) []treasure.Treasure {

	atomic.StoreInt32(&b.initialized, 1)

	b.mu.Lock()
	defer b.mu.Unlock()

	var shiftedTreasures []treasure.Treasure
	var remainingTreasures []treasure.Treasure

	counter := 0
	for _, treasureObj := range b.treasuresByOrder {
		lockerID := treasureObj.StartTreasureGuard(true)
		if counter < howMany && treasureObj.GetExpirationTime() < time.Now().UTC().UnixNano() {
			clonedTreasure := treasureObj.Clone(lockerID)
			shiftedTreasures = append(shiftedTreasures, clonedTreasure)
			delete(b.treasuresByKeys, treasureObj.GetKey())
			counter++
		} else {
			remainingTreasures = append(remainingTreasures, treasureObj)
		}
		treasureObj.ReleaseTreasureGuard(lockerID)
	}
	b.treasuresByOrder = remainingTreasures
	return shiftedTreasures

}

// CloneOrderedTreasures returns the clone of all the orderedTreasures in the beacon
func (b *beacon) CloneOrderedTreasures(thenReset bool) []treasure.Treasure {

	atomic.StoreInt32(&b.initialized, 1)

	b.mu.Lock()
	defer b.mu.Unlock()

	// clone the slice because we don't want to expose the internal slice
	clone := make([]treasure.Treasure, len(b.treasuresByOrder))
	for index, treasureObj := range b.treasuresByOrder {
		lockerID := treasureObj.StartTreasureGuard(true)
		clone[index] = treasureObj.Clone(lockerID)
		treasureObj.ReleaseTreasureGuard(lockerID)
	}

	if thenReset {
		b.treasuresByOrder = nil
		b.treasuresByKeys = make(map[string]treasure.Treasure)
	}

	return clone

}

// CloneUnorderedTreasures returns the clone of all the unorderedTreasures in the beacon
func (b *beacon) CloneUnorderedTreasures(thenReset bool) map[string]treasure.Treasure {

	atomic.StoreInt32(&b.initialized, 1)

	b.mu.Lock()
	defer b.mu.Unlock()

	treasuresClone := make(map[string]treasure.Treasure)
	for key, value := range b.treasuresByKeys {
		guardID := value.StartTreasureGuard(true)
		treasuresClone[key] = value.Clone(guardID)
		value.ReleaseTreasureGuard(guardID)
	}

	if thenReset {
		b.treasuresByOrder = nil
		b.treasuresByKeys = make(map[string]treasure.Treasure)
	}

	return treasuresClone
}

// GetManyFromOrderPosition returns the elements with the given offset and limit
func (b *beacon) GetManyFromOrderPosition(from int, limit int) ([]treasure.Treasure, error) {

	atomic.StoreInt32(&b.initialized, 1)

	b.mu.RLock()
	defer b.mu.RUnlock()

	if !b.isOrdered {
		return nil, errors.New("beacon is not ordered")
	}
	if from > len(b.treasuresByOrder) {
		return nil, errors.New("from is greater than the number of elements in the beacon")
	}
	if from+limit > len(b.treasuresByOrder) {
		return b.treasuresByOrder[from:], nil
	}
	return b.treasuresByOrder[from : from+limit], nil

}

// GetManyFromKey returns the elements with the given offset and limit
func (b *beacon) GetManyFromKey(fromKey *string, limit *int32) ([]treasure.Treasure, error) {

	b.mu.RLock()
	defer b.mu.RUnlock()

	if !b.isOrdered {
		return nil, errors.New("beacon is not ordered")
	}

	counterLimit := int32(100)
	if limit != nil {
		counterLimit = *limit
	}

	// get the treasures from the orderedTreasures
	var selectedTreasures []treasure.Treasure
	counter := int32(0)
	foundKey := false

	for _, t := range b.treasuresByOrder {
		// if the fromKey is not nil, skip the treasure until the fromKey is found
		if !foundKey && (fromKey != nil && *fromKey != t.GetKey()) {
			continue
		}
		foundKey = true
		counter++
		selectedTreasures = append(selectedTreasures, t)
		if counter == counterLimit {
			break
		}
	}

	return selectedTreasures, nil

}

// FilterOrderedTreasures function for filtering the ordered treasures
func (b *beacon) FilterOrderedTreasures(filterFunc func(treasureObj treasure.Treasure) bool, howMany int, remove bool) ([]treasure.Treasure, error) {

	b.mu.Lock()
	defer b.mu.Unlock()

	if !b.isOrdered {
		return nil, errors.New("beacon is not ordered")
	}

	var filteredTreasures []treasure.Treasure
	counter := 0

	for index, treasureObj := range b.treasuresByOrder {
		if counter == howMany {
			break
		}
		if filterFunc(treasureObj) {
			filteredTreasures = append(filteredTreasures, treasureObj)
			// remove the item from the original slice
			// and from the map too
			if remove {
				delete(b.treasuresByKeys, treasureObj.GetKey())
				b.treasuresByOrder = append(b.treasuresByOrder[:index], b.treasuresByOrder[index+1:]...)
			}
			counter++
		}
	}
	return filteredTreasures, nil
}

// SortByCreationTimeAsc sorts the orderedTreasures by the creation time ascending
func (b *beacon) SortByCreationTimeAsc() error {

	b.mu.Lock()
	defer b.mu.Unlock()

	if !b.isOrdered {
		return errors.New("the beacon is not ordered")
	}

	sort.Slice(b.treasuresByOrder, func(k, l int) bool {
		return b.treasuresByOrder[k].GetCreatedAt() < b.treasuresByOrder[l].GetCreatedAt()
	})

	return nil

}

// SortByCreationTimeDesc sorts the orderedTreasures by the creation time descending
func (b *beacon) SortByCreationTimeDesc() error {

	b.mu.Lock()
	defer b.mu.Unlock()

	if !b.isOrdered {
		return errors.New("the beacon is not ordered")
	}
	sort.Slice(b.treasuresByOrder, func(k, l int) bool {
		return b.treasuresByOrder[k].GetCreatedAt() > b.treasuresByOrder[l].GetCreatedAt()
	})
	return nil
}

// SortByKeyAsc sorts the orderedTreasures by the key ascending
func (b *beacon) SortByKeyAsc() error {
	b.mu.Lock()
	defer b.mu.Unlock()

	if !b.isOrdered {
		return errors.New("the beacon is not ordered")
	}
	sort.Slice(b.treasuresByOrder, func(k, l int) bool {
		return b.treasuresByOrder[k].GetKey() < b.treasuresByOrder[l].GetKey()
	})
	return nil
}

// SortByKeyDesc sorts the orderedTreasures by the key descending
func (b *beacon) SortByKeyDesc() error {
	b.mu.Lock()
	defer b.mu.Unlock()

	if !b.isOrdered {
		return errors.New("the beacon is not ordered")
	}
	sort.Slice(b.treasuresByOrder, func(k, l int) bool {
		return b.treasuresByOrder[k].GetKey() > b.treasuresByOrder[l].GetKey()
	})
	return nil
}

func (b *beacon) SortByExpirationTimeAsc() error {
	b.mu.Lock()
	defer b.mu.Unlock()
	if !b.isOrdered {
		return errors.New("the beacon is not ordered")
	}
	sort.Slice(b.treasuresByOrder, func(k, l int) bool {
		return b.treasuresByOrder[k].GetExpirationTime() < b.treasuresByOrder[l].GetExpirationTime()
	})
	return nil
}

func (b *beacon) SortByExpirationTimeDesc() error {
	b.mu.Lock()
	defer b.mu.Unlock()
	if !b.isOrdered {
		return errors.New("the beacon is not ordered")
	}
	sort.Slice(b.treasuresByOrder, func(k, l int) bool {
		return b.treasuresByOrder[k].GetExpirationTime() > b.treasuresByOrder[l].GetExpirationTime()
	})
	return nil
}
func (b *beacon) SortByUpdateTimeAsc() error {
	b.mu.Lock()
	defer b.mu.Unlock()
	if !b.isOrdered {
		return errors.New("the beacon is not ordered")
	}
	sort.Slice(b.treasuresByOrder, func(k, l int) bool {
		return b.treasuresByOrder[k].GetModifiedAt() < b.treasuresByOrder[l].GetModifiedAt()
	})
	return nil
}
func (b *beacon) SortByUpdateTimeDesc() error {
	b.mu.Lock()
	defer b.mu.Unlock()
	if !b.isOrdered {
		return errors.New("the beacon is not ordered")
	}
	sort.Slice(b.treasuresByOrder, func(k, l int) bool {
		return b.treasuresByOrder[k].GetModifiedAt() > b.treasuresByOrder[l].GetModifiedAt()
	})
	return nil
}

func (b *beacon) SortByValueFloat32ASC() error {
	b.mu.Lock()
	defer b.mu.Unlock()
	if !b.isOrdered {
		return errors.New("the beacon is not ordered")
	}
	sort.Slice(b.treasuresByOrder, func(k, l int) bool {
		kVal, err := b.treasuresByOrder[k].GetContentFloat32()
		if err != nil {
			return false
		}
		lVal, err := b.treasuresByOrder[l].GetContentFloat32()
		if err != nil {
			return false
		}
		return kVal < lVal
	})
	return nil
}
func (b *beacon) SortByValueFloat32DESC() error {
	b.mu.Lock()
	defer b.mu.Unlock()
	if !b.isOrdered {
		return errors.New("the beacon is not ordered")
	}
	sort.Slice(b.treasuresByOrder, func(k, l int) bool {
		kVal, err := b.treasuresByOrder[k].GetContentFloat32()
		if err != nil {
			return false
		}
		lVal, err := b.treasuresByOrder[l].GetContentFloat32()
		if err != nil {
			return false
		}
		return kVal > lVal
	})
	return nil
}
func (b *beacon) SortByValueFloat64ASC() error {
	b.mu.Lock()
	defer b.mu.Unlock()
	if !b.isOrdered {
		return errors.New("the beacon is not ordered")
	}
	sort.Slice(b.treasuresByOrder, func(k, l int) bool {
		kVal, err := b.treasuresByOrder[k].GetContentFloat64()
		if err != nil {
			return false
		}
		lVal, err := b.treasuresByOrder[l].GetContentFloat64()
		if err != nil {
			return false
		}
		return kVal < lVal
	})
	return nil
}
func (b *beacon) SortByValueFloat64DESC() error {
	b.mu.Lock()
	defer b.mu.Unlock()
	if !b.isOrdered {
		return errors.New("the beacon is not ordered")
	}
	sort.Slice(b.treasuresByOrder, func(k, l int) bool {
		kVal, err := b.treasuresByOrder[k].GetContentFloat64()
		if err != nil {
			return false
		}
		lVal, err := b.treasuresByOrder[l].GetContentFloat64()
		if err != nil {
			return false
		}
		return kVal > lVal
	})
	return nil
}

func (b *beacon) SortByValueUint8ASC() error {
	b.mu.Lock()
	defer b.mu.Unlock()
	if !b.isOrdered {
		return errors.New("the beacon is not ordered")
	}
	sort.Slice(b.treasuresByOrder, func(k, l int) bool {
		kVal, err := b.treasuresByOrder[k].GetContentUint8()
		if err != nil {
			return false
		}
		lVal, err := b.treasuresByOrder[l].GetContentUint8()
		if err != nil {
			return false
		}
		return kVal < lVal
	})
	return nil
}
func (b *beacon) SortByValueUint8DESC() error {
	b.mu.Lock()
	defer b.mu.Unlock()
	if !b.isOrdered {
		return errors.New("the beacon is not ordered")
	}
	sort.Slice(b.treasuresByOrder, func(k, l int) bool {
		kVal, err := b.treasuresByOrder[k].GetContentUint8()
		if err != nil {
			return false
		}
		lVal, err := b.treasuresByOrder[l].GetContentUint8()
		if err != nil {
			return false
		}
		return kVal > lVal
	})
	return nil
}

func (b *beacon) SortByValueUint16ASC() error {
	b.mu.Lock()
	defer b.mu.Unlock()
	if !b.isOrdered {
		return errors.New("the beacon is not ordered")
	}
	sort.Slice(b.treasuresByOrder, func(k, l int) bool {
		kVal, err := b.treasuresByOrder[k].GetContentUint16()
		if err != nil {
			return false
		}
		lVal, err := b.treasuresByOrder[l].GetContentUint16()
		if err != nil {
			return false
		}
		return kVal < lVal
	})
	return nil
}
func (b *beacon) SortByValueUint16DESC() error {
	b.mu.Lock()
	defer b.mu.Unlock()
	if !b.isOrdered {
		return errors.New("the beacon is not ordered")
	}
	sort.Slice(b.treasuresByOrder, func(k, l int) bool {
		kVal, err := b.treasuresByOrder[k].GetContentUint16()
		if err != nil {
			return false
		}
		lVal, err := b.treasuresByOrder[l].GetContentUint16()
		if err != nil {
			return false
		}
		return kVal > lVal
	})
	return nil
}

func (b *beacon) SortByValueUint32ASC() error {
	b.mu.Lock()
	defer b.mu.Unlock()
	if !b.isOrdered {
		return errors.New("the beacon is not ordered")
	}
	sort.Slice(b.treasuresByOrder, func(k, l int) bool {
		kVal, err := b.treasuresByOrder[k].GetContentUint32()
		if err != nil {
			return false
		}
		lVal, err := b.treasuresByOrder[l].GetContentUint32()
		if err != nil {
			return false
		}
		return kVal < lVal
	})
	return nil
}
func (b *beacon) SortByValueUint32DESC() error {
	b.mu.Lock()
	defer b.mu.Unlock()
	if !b.isOrdered {
		return errors.New("the beacon is not ordered")
	}
	sort.Slice(b.treasuresByOrder, func(k, l int) bool {
		kVal, err := b.treasuresByOrder[k].GetContentUint32()
		if err != nil {
			return false
		}
		lVal, err := b.treasuresByOrder[l].GetContentUint32()
		if err != nil {
			return false
		}
		return kVal > lVal
	})
	return nil
}

func (b *beacon) SortByValueUint64ASC() error {
	b.mu.Lock()
	defer b.mu.Unlock()
	if !b.isOrdered {
		return errors.New("the beacon is not ordered")
	}
	sort.Slice(b.treasuresByOrder, func(k, l int) bool {
		kVal, err := b.treasuresByOrder[k].GetContentUint64()
		if err != nil {
			return false
		}
		lVal, err := b.treasuresByOrder[l].GetContentUint64()
		if err != nil {
			return false
		}
		return kVal < lVal
	})
	return nil
}
func (b *beacon) SortByValueUint64DESC() error {
	b.mu.Lock()
	defer b.mu.Unlock()
	if !b.isOrdered {
		return errors.New("the beacon is not ordered")
	}
	sort.Slice(b.treasuresByOrder, func(k, l int) bool {
		kVal, err := b.treasuresByOrder[k].GetContentUint64()
		if err != nil {
			return false
		}
		lVal, err := b.treasuresByOrder[l].GetContentUint64()
		if err != nil {
			return false
		}
		return kVal > lVal
	})
	return nil
}

func (b *beacon) SortByValueInt8ASC() error {
	b.mu.Lock()
	defer b.mu.Unlock()
	if !b.isOrdered {
		return errors.New("the beacon is not ordered")
	}
	sort.Slice(b.treasuresByOrder, func(k, l int) bool {
		kVal, err := b.treasuresByOrder[k].GetContentInt8()
		if err != nil {
			return false
		}
		lVal, err := b.treasuresByOrder[l].GetContentInt8()
		if err != nil {
			return false
		}
		return kVal < lVal
	})
	return nil
}
func (b *beacon) SortByValueInt8DESC() error {
	b.mu.Lock()
	defer b.mu.Unlock()
	if !b.isOrdered {
		return errors.New("the beacon is not ordered")
	}
	sort.Slice(b.treasuresByOrder, func(k, l int) bool {
		kVal, err := b.treasuresByOrder[k].GetContentInt8()
		if err != nil {
			return false
		}
		lVal, err := b.treasuresByOrder[l].GetContentInt8()
		if err != nil {
			return false
		}
		return kVal > lVal
	})
	return nil
}
func (b *beacon) SortByValueInt16ASC() error {
	b.mu.Lock()
	defer b.mu.Unlock()
	if !b.isOrdered {
		return errors.New("the beacon is not ordered")
	}
	sort.Slice(b.treasuresByOrder, func(k, l int) bool {
		kVal, err := b.treasuresByOrder[k].GetContentInt16()
		if err != nil {
			return false
		}
		lVal, err := b.treasuresByOrder[l].GetContentInt16()
		if err != nil {
			return false
		}
		return kVal < lVal
	})
	return nil
}
func (b *beacon) SortByValueInt16DESC() error {
	b.mu.Lock()
	defer b.mu.Unlock()
	if !b.isOrdered {
		return errors.New("the beacon is not ordered")
	}
	sort.Slice(b.treasuresByOrder, func(k, l int) bool {
		kVal, err := b.treasuresByOrder[k].GetContentInt16()
		if err != nil {
			return false
		}
		lVal, err := b.treasuresByOrder[l].GetContentInt16()
		if err != nil {
			return false
		}
		return kVal > lVal
	})
	return nil
}
func (b *beacon) SortByValueInt32ASC() error {
	b.mu.Lock()
	defer b.mu.Unlock()
	if !b.isOrdered {
		return errors.New("the beacon is not ordered")
	}
	sort.Slice(b.treasuresByOrder, func(k, l int) bool {
		kVal, err := b.treasuresByOrder[k].GetContentInt32()
		if err != nil {
			return false
		}
		lVal, err := b.treasuresByOrder[l].GetContentInt32()
		if err != nil {
			return false
		}
		return kVal < lVal
	})
	return nil
}
func (b *beacon) SortByValueInt32DESC() error {
	b.mu.Lock()
	defer b.mu.Unlock()
	if !b.isOrdered {
		return errors.New("the beacon is not ordered")
	}
	sort.Slice(b.treasuresByOrder, func(k, l int) bool {
		kVal, err := b.treasuresByOrder[k].GetContentInt32()
		if err != nil {
			return false
		}
		lVal, err := b.treasuresByOrder[l].GetContentInt32()
		if err != nil {
			return false
		}
		return kVal > lVal
	})
	return nil
}

func (b *beacon) SortByValueInt64ASC() error {
	b.mu.Lock()
	defer b.mu.Unlock()

	if !b.isOrdered {
		return errors.New("the beacon is not ordered")
	}

	// Extract values in advance, and throw an error if any of them are invalid.
	type item struct {
		value int64
		t     treasure.Treasure
	}

	items := make([]item, 0, len(b.treasuresByOrder))
	for i, t := range b.treasuresByOrder {
		v, err := t.GetContentInt64()
		if err != nil {
			return fmt.Errorf("cannot sort ascending: index %d, key %q is not an int64: %w", i, t.GetKey(), err)
		}
		items = append(items, item{value: v, t: t})
	}

	// ordering the items by value
	sort.SliceStable(items, func(i, j int) bool {
		return items[i].value < items[j].value
	})

	// load back all ordered items
	for i, it := range items {
		b.treasuresByOrder[i] = it.t
	}

	return nil
}

func (b *beacon) SortByValueInt64DESC() error {
	b.mu.Lock()
	defer b.mu.Unlock()

	if !b.isOrdered {
		return errors.New("the beacon is not ordered")
	}

	type item struct {
		value int64
		t     treasure.Treasure
	}

	items := make([]item, 0, len(b.treasuresByOrder))
	for i, t := range b.treasuresByOrder {
		v, err := t.GetContentInt64()
		if err != nil {
			return fmt.Errorf("cannot sort descending: index %d, key %q is not an int64: %w", i, t.GetKey(), err)
		}
		items = append(items, item{value: v, t: t})
	}

	sort.SliceStable(items, func(i, j int) bool {
		return items[i].value > items[j].value
	})

	for i, it := range items {
		b.treasuresByOrder[i] = it.t
	}

	return nil
}

func (b *beacon) SortByValueStringASC() error {
	b.mu.Lock()
	defer b.mu.Unlock()
	if !b.isOrdered {
		return errors.New("the beacon is not ordered")
	}
	sort.Slice(b.treasuresByOrder, func(k, l int) bool {
		kVal, err := b.treasuresByOrder[k].GetContentString()
		if err != nil {
			return false
		}
		lVal, err := b.treasuresByOrder[l].GetContentString()
		if err != nil {
			return false
		}
		return kVal < lVal
	})
	return nil
}
func (b *beacon) SortByValueStringDESC() error {
	b.mu.Lock()
	defer b.mu.Unlock()
	if !b.isOrdered {
		return errors.New("the beacon is not ordered")
	}
	sort.Slice(b.treasuresByOrder, func(k, l int) bool {
		kVal, err := b.treasuresByOrder[k].GetContentString()
		if err != nil {
			return false
		}
		lVal, err := b.treasuresByOrder[l].GetContentString()
		if err != nil {
			return false
		}
		return kVal > lVal
	})
	return nil
}

--------------------------------------------------------------------------------

/==============================================================================\
| FILE: core\hydra\swamp\beacon\beacon_test.go
| PATH: C:\go\src\hydraide\app\core\hydra\swamp\beacon\beacon_test.go
| SIZE: 30.4 KB
\==============================================================================/

package beacon

import (
	"fmt"
	"github.com/hydraide/hydraide/app/core/hydra/swamp/treasure"
	"github.com/hydraide/hydraide/app/core/hydra/swamp/treasure/guard"
	"github.com/stretchr/testify/assert"
	"strconv"
	"strings"
	"testing"
	"time"
)

func MySaveFunction(_ treasure.Treasure, _ guard.ID) treasure.TreasureStatus {
	return treasure.StatusNew
}

func TestBeacon(t *testing.T) {

	t.Run("should base functions (Swamp, Delete, IsExists, Count, Get, SetInitialized, IsInitialized, Reset) works", func(t *testing.T) {

		testTreasureCounter := 100

		b := New()

		assert.Equal(t, false, b.IsInitialized(), "the beacon should not be initialized")

		b.SetInitialized(true)

		assert.Equal(t, true, b.IsInitialized(), "the beacon should be initialized")

		for i := 0; i < testTreasureCounter; i++ {
			treasureInterface := treasure.New(MySaveFunction)
			guardID := treasureInterface.StartTreasureGuard(true, guard.BodyAuthID)
			treasureInterface.BodySetKey(guardID, fmt.Sprintf("key-%d", i))
			treasureInterface.SetContentString(guardID, fmt.Sprintf("content-%d", i))
			b.Add(treasureInterface)
			treasureInterface.ReleaseTreasureGuard(guardID)
		}

		assert.Equal(t, testTreasureCounter, b.Count(), "all treasures count should be equal to testTreasureCounter")

		assert.True(t, b.IsExists("key-10"), "key-10 should exists")

		b.Delete("key-10")

		assert.Equal(t, testTreasureCounter-1, b.Count(), "all treasures count should be equal to testTreasureCounter - 1")

		assert.False(t, b.IsExists("key-10"), "key-10 should not exists")

		receivedTreasureInterface := b.Get("key-20")
		contentString, err := receivedTreasureInterface.GetContentString()

		assert.Nil(t, err, "should not return error")
		assert.Equal(t, "content-20", contentString, "content should be equal to content-20")

		b.Reset()

		assert.Equal(t, 0, b.Count(), "all treasures count should be equal to 0")
		assert.False(t, b.IsExists("key-20"), "key-20 should not exists")

		b.Reset()

		assert.False(t, b.IsInitialized(), "the beacon should not be initialized")

	})

	t.Run("should get expired treasures", func(t *testing.T) {

		b := New()
		b.SetInitialized(true)
		b.SetIsOrdered(true)

		// create 10 non-expired treasures and add them to the beacon
		for i := 0; i < 10; i++ {
			treasureInterface := treasure.New(MySaveFunction)
			guardID := treasureInterface.StartTreasureGuard(true, guard.BodyAuthID)
			treasureInterface.BodySetKey(guardID, fmt.Sprintf("key-%d", i))
			treasureInterface.SetContentString(guardID, fmt.Sprintf("content-%d", i))
			treasureInterface.SetExpirationTime(guardID, time.Now().Add(time.Hour))
			treasureInterface.ReleaseTreasureGuard(guardID)
			b.Add(treasureInterface)
		}

		err := b.SortByExpirationTimeAsc()
		assert.Nil(t, err, "should not return error")

		expiredTreasures := b.ShiftExpired(10)
		assert.Equal(t, 0, len(expiredTreasures), "expired treasures count should be equal to 0")

		for i := 10; i < 20; i++ {
			treasureInterface := treasure.New(MySaveFunction)
			guardID := treasureInterface.StartTreasureGuard(true, guard.BodyAuthID)
			treasureInterface.BodySetKey(guardID, fmt.Sprintf("key-%d", i))
			treasureInterface.SetContentString(guardID, fmt.Sprintf("content-%d", i))
			treasureInterface.SetExpirationTime(guardID, time.Now().Add(-time.Hour).Add(time.Second*time.Duration(i)))
			treasureInterface.ReleaseTreasureGuard(guardID)
			b.Add(treasureInterface)
		}

		err = b.SortByExpirationTimeDesc()
		assert.Nil(t, err, "should not return error")

		expiredTreasures = b.ShiftExpired(5)
		assert.Equal(t, 5, len(expiredTreasures), "expired treasures count should be equal to 10")
		assert.Equal(t, 15, b.Count(), "all treasures count should be equal to 15")

		lastID := 20
		for _, treasureObj := range expiredTreasures {
			// get the number from the key
			keyFragments := strings.Split(treasureObj.GetKey(), "-")
			keyInteger, err := strconv.Atoi(keyFragments[1])
			if err != nil {
				t.Fatal(err)
			}
			assert.Less(t, keyInteger, lastID, fmt.Sprintf("expired treasures key (%d) should be less than lastID (%d)", keyInteger, lastID))
			lastID--
		}

		err = b.SortByExpirationTimeAsc()

		expiredTreasures = b.ShiftExpired(5)
		assert.Equal(t, 5, len(expiredTreasures), "expired treasures count should be equal to 10")
		assert.Equal(t, 10, b.Count(), "all treasures count should be equal to 10")

		lastID = 9
		for _, treasureObj := range expiredTreasures {
			// get the number from the key
			keyFragments := strings.Split(treasureObj.GetKey(), "-")
			keyInteger, err := strconv.Atoi(keyFragments[1])
			if err != nil {
				t.Fatal(err)
			}
			assert.Greater(t, keyInteger, lastID, fmt.Sprintf("expired treasures key (%d) should be greater than lastID (%d)", keyInteger, lastID))
			lastID++
		}

		// there should be no more expired treasures
		expiredTreasures = b.ShiftExpired(5)
		assert.Equal(t, 0, len(expiredTreasures), "expired treasures count should be equal to 0")
		assert.Equal(t, 10, b.Count(), "all treasures count should be equal to 10")

	})

	// SortByCreationTimeAsc() error
	// SortByCreationTimeDesc() error
	t.Run("should get treasures by creation time", func(t *testing.T) {

		b := New()
		b.SetInitialized(true)
		b.SetIsOrdered(true)

		// create 10 non-expired treasures and add them to the beacon
		for i := 0; i < 10; i++ {
			treasureInterface := treasure.New(MySaveFunction)
			guardID := treasureInterface.StartTreasureGuard(true, guard.BodyAuthID)
			treasureInterface.BodySetKey(guardID, fmt.Sprintf("%d", i))
			treasureInterface.SetContentString(guardID, fmt.Sprintf("content-%d", i))
			treasureInterface.SetExpirationTime(guardID, time.Now().Add(time.Hour))
			treasureInterface.SetCreatedAt(guardID, time.Now())
			treasureInterface.ReleaseTreasureGuard(guardID)
			b.Add(treasureInterface)
			time.Sleep(time.Millisecond * 10)
		}

		err := b.SortByCreationTimeAsc()
		assert.Nil(t, err, "should not return error")

		treasures, err := b.GetManyFromOrderPosition(0, 10)
		assert.Nil(t, err, "should not return error")

		lastID := 0
		for _, treasureObject := range treasures {
			keyInt, err := strconv.Atoi(treasureObject.GetKey())
			assert.Nil(t, err, "should not return error")
			assert.Equal(t, lastID, keyInt, fmt.Sprintf("key should be equal to %d", lastID))
			lastID++
		}

		err = b.SortByCreationTimeDesc()
		assert.Nil(t, err, "should not return error")

		treasures, err = b.GetManyFromOrderPosition(0, 10)
		assert.Nil(t, err, "should not return error")

		lastID = 9
		for _, treasureObject := range treasures {
			keyInt, err := strconv.Atoi(treasureObject.GetKey())
			assert.Nil(t, err, "should not return error")
			assert.Equal(t, lastID, keyInt, fmt.Sprintf("key should be equal to %d", lastID))
			lastID--
		}

	})

	// SortByKeyAsc() error
	// SortByKeyDesc() error
	t.Run("should get treasures by key", func(t *testing.T) {

		b := New()
		b.SetInitialized(true)
		b.SetIsOrdered(true)

		// create 10 non-expired treasures and add them to the beacon
		for i := 0; i < 10; i++ {
			treasureInterface := treasure.New(MySaveFunction)
			guardID := treasureInterface.StartTreasureGuard(true, guard.BodyAuthID)
			treasureInterface.BodySetKey(guardID, fmt.Sprintf("%d", i))
			treasureInterface.SetContentString(guardID, fmt.Sprintf("content-%d", i))
			treasureInterface.SetExpirationTime(guardID, time.Now().Add(time.Hour))
			treasureInterface.ReleaseTreasureGuard(guardID)
			b.Add(treasureInterface)
			time.Sleep(time.Millisecond * 10)
		}

		err := b.SortByKeyAsc()
		assert.Nil(t, err, "should not return error")

		treasures, err := b.GetManyFromOrderPosition(0, 10)
		assert.Nil(t, err, "should not return error")

		lastID := 0
		for _, treasureObject := range treasures {
			keyInt, err := strconv.Atoi(treasureObject.GetKey())
			assert.Nil(t, err, "should not return error")
			assert.Equal(t, lastID, keyInt, fmt.Sprintf("key should be equal to %d", lastID))
			lastID++
		}

		err = b.SortByKeyDesc()
		assert.Nil(t, err, "should not return error")

		treasures, err = b.GetManyFromOrderPosition(0, 10)
		assert.Nil(t, err, "should not return error")

		lastID = 9
		for _, treasureObject := range treasures {
			keyInt, err := strconv.Atoi(treasureObject.GetKey())
			assert.Nil(t, err, "should not return error")
			assert.Equal(t, lastID, keyInt, fmt.Sprintf("key should be equal to %d", lastID))
			lastID--
		}

	})

	// SortByUpdateTimeAsc() error
	// SortByUpdateTimeDesc() error
	t.Run("should get treasures by update time", func(t *testing.T) {

		b := New()
		b.SetInitialized(true)
		b.SetIsOrdered(true)

		// create 10 non-expired treasures and add them to the beacon
		for i := 0; i < 10; i++ {
			treasureInterface := treasure.New(MySaveFunction)
			guardID := treasureInterface.StartTreasureGuard(true, guard.BodyAuthID)
			treasureInterface.BodySetKey(guardID, fmt.Sprintf("%d", i))
			treasureInterface.SetContentString(guardID, fmt.Sprintf("content-%d", i))
			treasureInterface.SetModifiedAt(guardID, time.Now())
			treasureInterface.ReleaseTreasureGuard(guardID)
			b.Add(treasureInterface)
			time.Sleep(time.Millisecond * 10)
		}

		err := b.SortByUpdateTimeAsc()
		assert.Nil(t, err, "should not return error")

		treasures, err := b.GetManyFromOrderPosition(0, 10)
		assert.Nil(t, err, "should not return error")

		lastID := 0
		for _, treasureObject := range treasures {
			keyInt, err := strconv.Atoi(treasureObject.GetKey())
			assert.Nil(t, err, "should not return error")
			assert.Equal(t, lastID, keyInt, fmt.Sprintf("key should be equal to %d", lastID))
			lastID++
		}

		err = b.SortByUpdateTimeDesc()
		assert.Nil(t, err, "should not return error")

		treasures, err = b.GetManyFromOrderPosition(0, 10)
		assert.Nil(t, err, "should not return error")

		lastID = 9
		for _, treasureObject := range treasures {
			keyInt, err := strconv.Atoi(treasureObject.GetKey())
			assert.Nil(t, err, "should not return error")
			assert.Equal(t, lastID, keyInt, fmt.Sprintf("key should be equal to %d", lastID))
			lastID--
		}

	})

	// SortByValueInt8ASC() error
	// SortByValueInt8DESC() error
	t.Run("should get treasures by value integer", func(t *testing.T) {

		b := New()
		b.SetInitialized(true)
		b.SetIsOrdered(true)

		// create 10 non-expired treasures and add them to the beacon
		for i := 0; i < 10; i++ {
			treasureInterface := treasure.New(MySaveFunction)
			guardID := treasureInterface.StartTreasureGuard(true, guard.BodyAuthID)
			treasureInterface.BodySetKey(guardID, fmt.Sprintf("%d", i))
			treasureInterface.SetContentInt8(guardID, int8(i))
			treasureInterface.ReleaseTreasureGuard(guardID)
			b.Add(treasureInterface)
		}

		err := b.SortByValueInt8ASC()
		assert.Nil(t, err, "should not return error")

		treasures, err := b.GetManyFromOrderPosition(0, 10)
		assert.Nil(t, err, "should not return error")

		lastID := 0
		for _, treasureObject := range treasures {
			keyInt, err := strconv.Atoi(treasureObject.GetKey())
			assert.Nil(t, err, "should not return error")
			assert.Equal(t, lastID, keyInt, fmt.Sprintf("key should be equal to %d", lastID))
			lastID++
		}

		err = b.SortByValueInt8DESC()
		assert.Nil(t, err, "should not return error")

		treasures, err = b.GetManyFromOrderPosition(0, 10)
		assert.Nil(t, err, "should not return error")

		lastID = 9
		for _, treasureObject := range treasures {
			keyInt, err := strconv.Atoi(treasureObject.GetKey())
			assert.Nil(t, err, "should not return error")
			assert.Equal(t, lastID, keyInt, fmt.Sprintf("key should be equal to %d", lastID))
			lastID--
		}

	})

	// SortByValueInt16ASC() error
	// SortByValueInt16DESC() error
	t.Run("should get treasures by value integer", func(t *testing.T) {

		b := New()
		b.SetInitialized(true)
		b.SetIsOrdered(true)

		// create 10 non-expired treasures and add them to the beacon
		for i := 0; i < 10; i++ {
			treasureInterface := treasure.New(MySaveFunction)
			guardID := treasureInterface.StartTreasureGuard(true, guard.BodyAuthID)
			treasureInterface.BodySetKey(guardID, fmt.Sprintf("%d", i))
			treasureInterface.SetContentInt16(guardID, int16(i))
			treasureInterface.ReleaseTreasureGuard(guardID)
			b.Add(treasureInterface)
		}

		err := b.SortByValueInt16ASC()
		assert.Nil(t, err, "should not return error")

		treasures, err := b.GetManyFromOrderPosition(0, 10)
		assert.Nil(t, err, "should not return error")

		lastID := 0
		for _, treasureObject := range treasures {
			keyInt, err := strconv.Atoi(treasureObject.GetKey())
			assert.Nil(t, err, "should not return error")
			assert.Equal(t, lastID, keyInt, fmt.Sprintf("key should be equal to %d", lastID))
			lastID++
		}

		err = b.SortByValueInt16DESC()
		assert.Nil(t, err, "should not return error")

		treasures, err = b.GetManyFromOrderPosition(0, 10)
		assert.Nil(t, err, "should not return error")

		lastID = 9
		for _, treasureObject := range treasures {
			keyInt, err := strconv.Atoi(treasureObject.GetKey())
			assert.Nil(t, err, "should not return error")
			assert.Equal(t, lastID, keyInt, fmt.Sprintf("key should be equal to %d", lastID))
			lastID--
		}

	})

	// SortByValueInt32ASC() error
	// SortByValueInt32DESC() error
	t.Run("should get treasures by value integer", func(t *testing.T) {

		b := New()
		b.SetInitialized(true)
		b.SetIsOrdered(true)

		// create 10 non-expired treasures and add them to the beacon
		for i := 0; i < 10; i++ {
			treasureInterface := treasure.New(MySaveFunction)
			guardID := treasureInterface.StartTreasureGuard(true, guard.BodyAuthID)
			treasureInterface.BodySetKey(guardID, fmt.Sprintf("%d", i))
			treasureInterface.SetContentInt32(guardID, int32(i))
			treasureInterface.ReleaseTreasureGuard(guardID)
			b.Add(treasureInterface)
		}

		err := b.SortByValueInt32ASC()
		assert.Nil(t, err, "should not return error")

		treasures, err := b.GetManyFromOrderPosition(0, 10)
		assert.Nil(t, err, "should not return error")

		lastID := 0
		for _, treasureObject := range treasures {
			keyInt, err := strconv.Atoi(treasureObject.GetKey())
			assert.Nil(t, err, "should not return error")
			assert.Equal(t, lastID, keyInt, fmt.Sprintf("key should be equal to %d", lastID))
			lastID++
		}

		err = b.SortByValueInt32DESC()
		assert.Nil(t, err, "should not return error")

		treasures, err = b.GetManyFromOrderPosition(0, 10)
		assert.Nil(t, err, "should not return error")

		lastID = 9
		for _, treasureObject := range treasures {
			keyInt, err := strconv.Atoi(treasureObject.GetKey())
			assert.Nil(t, err, "should not return error")
			assert.Equal(t, lastID, keyInt, fmt.Sprintf("key should be equal to %d", lastID))
			lastID--
		}

	})

	// SortByValueInt64ASC() error
	// SortByValueInt64DESC() error
	t.Run("should get treasures by value integer", func(t *testing.T) {

		b := New()
		b.SetInitialized(true)
		b.SetIsOrdered(true)

		// create 10 non-expired treasures and add them to the beacon
		for i := 0; i < 10; i++ {
			treasureInterface := treasure.New(MySaveFunction)
			guardID := treasureInterface.StartTreasureGuard(true, guard.BodyAuthID)
			treasureInterface.BodySetKey(guardID, fmt.Sprintf("%d", i))
			treasureInterface.SetContentInt64(guardID, int64(i))
			treasureInterface.ReleaseTreasureGuard(guardID)
			b.Add(treasureInterface)
		}

		err := b.SortByValueInt64ASC()
		assert.Nil(t, err, "should not return error")

		treasures, err := b.GetManyFromOrderPosition(0, 10)
		assert.Nil(t, err, "should not return error")

		lastID := 0
		for _, treasureObject := range treasures {
			keyInt, err := strconv.Atoi(treasureObject.GetKey())
			assert.Nil(t, err, "should not return error")
			assert.Equal(t, lastID, keyInt, fmt.Sprintf("key should be equal to %d", lastID))
			lastID++
		}

		err = b.SortByValueInt64DESC()
		assert.Nil(t, err, "should not return error")

		treasures, err = b.GetManyFromOrderPosition(0, 10)
		assert.Nil(t, err, "should not return error")

		lastID = 9
		for _, treasureObject := range treasures {
			keyInt, err := strconv.Atoi(treasureObject.GetKey())
			assert.Nil(t, err, "should not return error")
			assert.Equal(t, lastID, keyInt, fmt.Sprintf("key should be equal to %d", lastID))
			lastID--
		}

	})

	// SortByValueUint8ASC() error
	// SortByValueUint8DESC() error
	t.Run("should get treasures by value integer", func(t *testing.T) {

		b := New()
		b.SetInitialized(true)
		b.SetIsOrdered(true)

		// create 10 non-expired treasures and add them to the beacon
		for i := 0; i < 10; i++ {
			treasureInterface := treasure.New(MySaveFunction)
			guardID := treasureInterface.StartTreasureGuard(true, guard.BodyAuthID)
			treasureInterface.BodySetKey(guardID, fmt.Sprintf("%d", i))
			treasureInterface.SetContentUint8(guardID, uint8(i))
			treasureInterface.ReleaseTreasureGuard(guardID)
			b.Add(treasureInterface)
		}

		err := b.SortByValueUint8ASC()
		assert.Nil(t, err, "should not return error")

		treasures, err := b.GetManyFromOrderPosition(0, 10)
		assert.Nil(t, err, "should not return error")

		lastID := 0
		for _, treasureObject := range treasures {
			keyInt, err := strconv.Atoi(treasureObject.GetKey())
			assert.Nil(t, err, "should not return error")
			assert.Equal(t, lastID, keyInt, fmt.Sprintf("key should be equal to %d", lastID))
			lastID++
		}

		err = b.SortByValueUint8DESC()
		assert.Nil(t, err, "should not return error")

		treasures, err = b.GetManyFromOrderPosition(0, 10)
		assert.Nil(t, err, "should not return error")

		lastID = 9
		for _, treasureObject := range treasures {
			keyInt, err := strconv.Atoi(treasureObject.GetKey())
			assert.Nil(t, err, "should not return error")
			assert.Equal(t, lastID, keyInt, fmt.Sprintf("key should be equal to %d", lastID))
			lastID--
		}

	})

	// SortByValueUint16ASC() error
	// SortByValueUint16DESC() error
	t.Run("should get treasures by value integer", func(t *testing.T) {

		b := New()
		b.SetInitialized(true)
		b.SetIsOrdered(true)

		// create 10 non-expired treasures and add them to the beacon
		for i := 0; i < 10; i++ {
			treasureInterface := treasure.New(MySaveFunction)
			guardID := treasureInterface.StartTreasureGuard(true, guard.BodyAuthID)
			treasureInterface.BodySetKey(guardID, fmt.Sprintf("%d", i))
			treasureInterface.SetContentUint16(guardID, uint16(i))
			treasureInterface.ReleaseTreasureGuard(guardID)
			b.Add(treasureInterface)
		}

		err := b.SortByValueUint16ASC()
		assert.Nil(t, err, "should not return error")

		treasures, err := b.GetManyFromOrderPosition(0, 10)
		assert.Nil(t, err, "should not return error")

		lastID := 0
		for _, treasureObject := range treasures {
			keyInt, err := strconv.Atoi(treasureObject.GetKey())
			assert.Nil(t, err, "should not return error")
			assert.Equal(t, lastID, keyInt, fmt.Sprintf("key should be equal to %d", lastID))
			lastID++
		}

		err = b.SortByValueUint16DESC()
		assert.Nil(t, err, "should not return error")

		treasures, err = b.GetManyFromOrderPosition(0, 10)
		assert.Nil(t, err, "should not return error")

		lastID = 9
		for _, treasureObject := range treasures {
			keyInt, err := strconv.Atoi(treasureObject.GetKey())
			assert.Nil(t, err, "should not return error")
			assert.Equal(t, lastID, keyInt, fmt.Sprintf("key should be equal to %d", lastID))
			lastID--
		}

	})

	// SortByValueUint32ASC() error
	// SortByValueUint32DESC() error
	t.Run("should get treasures by value integer", func(t *testing.T) {

		b := New()
		b.SetInitialized(true)
		b.SetIsOrdered(true)

		// create 10 non-expired treasures and add them to the beacon
		for i := 0; i < 10; i++ {
			treasureInterface := treasure.New(MySaveFunction)
			guardID := treasureInterface.StartTreasureGuard(true, guard.BodyAuthID)
			treasureInterface.BodySetKey(guardID, fmt.Sprintf("%d", i))
			treasureInterface.SetContentUint32(guardID, uint32(i))
			treasureInterface.ReleaseTreasureGuard(guardID)
			b.Add(treasureInterface)
		}

		err := b.SortByValueUint32ASC()
		assert.Nil(t, err, "should not return error")

		treasures, err := b.GetManyFromOrderPosition(0, 10)
		assert.Nil(t, err, "should not return error")

		lastID := 0
		for _, treasureObject := range treasures {
			keyInt, err := strconv.Atoi(treasureObject.GetKey())
			assert.Nil(t, err, "should not return error")
			assert.Equal(t, lastID, keyInt, fmt.Sprintf("key should be equal to %d", lastID))
			lastID++
		}

		err = b.SortByValueUint32DESC()
		assert.Nil(t, err, "should not return error")

		treasures, err = b.GetManyFromOrderPosition(0, 10)
		assert.Nil(t, err, "should not return error")

		lastID = 9
		for _, treasureObject := range treasures {
			keyInt, err := strconv.Atoi(treasureObject.GetKey())
			assert.Nil(t, err, "should not return error")
			assert.Equal(t, lastID, keyInt, fmt.Sprintf("key should be equal to %d", lastID))
			lastID--
		}

	})

	// SortByValueUint64ASC() error
	// SortByValueUint64DESC() error
	t.Run("should get treasures by value integer", func(t *testing.T) {

		b := New()
		b.SetInitialized(true)
		b.SetIsOrdered(true)

		// create 10 non-expired treasures and add them to the beacon
		for i := 0; i < 10; i++ {
			treasureInterface := treasure.New(MySaveFunction)
			guardID := treasureInterface.StartTreasureGuard(true, guard.BodyAuthID)
			treasureInterface.BodySetKey(guardID, fmt.Sprintf("%d", i))
			treasureInterface.SetContentUint64(guardID, uint64(i))
			treasureInterface.ReleaseTreasureGuard(guardID)
			b.Add(treasureInterface)
		}

		err := b.SortByValueUint64ASC()
		assert.Nil(t, err, "should not return error")

		treasures, err := b.GetManyFromOrderPosition(0, 10)
		assert.Nil(t, err, "should not return error")

		lastID := 0
		for _, treasureObject := range treasures {
			keyInt, err := strconv.Atoi(treasureObject.GetKey())
			assert.Nil(t, err, "should not return error")
			assert.Equal(t, lastID, keyInt, fmt.Sprintf("key should be equal to %d", lastID))
			lastID++
		}

		err = b.SortByValueUint64DESC()
		assert.Nil(t, err, "should not return error")

		treasures, err = b.GetManyFromOrderPosition(0, 10)
		assert.Nil(t, err, "should not return error")

		lastID = 9
		for _, treasureObject := range treasures {
			keyInt, err := strconv.Atoi(treasureObject.GetKey())
			assert.Nil(t, err, "should not return error")
			assert.Equal(t, lastID, keyInt, fmt.Sprintf("key should be equal to %d", lastID))
			lastID--
		}

	})

	// SortByValueFloat64ASC() error
	// SortByValueFloat64DESC() error
	t.Run("should get treasures by value float", func(t *testing.T) {

		b := New()
		b.SetInitialized(true)
		b.SetIsOrdered(true)

		// create 10 non-expired treasures and add them to the beacon
		for i := 0; i < 10; i++ {
			treasureInterface := treasure.New(MySaveFunction)
			guardID := treasureInterface.StartTreasureGuard(true, guard.BodyAuthID)
			treasureInterface.BodySetKey(guardID, fmt.Sprintf("%d", i))
			treasureInterface.SetContentFloat64(guardID, 1.12+float64(i))
			treasureInterface.ReleaseTreasureGuard(guardID)
			b.Add(treasureInterface)
		}

		err := b.SortByValueFloat64ASC()
		assert.Nil(t, err, "should not return error")

		treasures, err := b.GetManyFromOrderPosition(0, 10)
		assert.Nil(t, err, "should not return error")

		lastID := 0
		for _, treasureObject := range treasures {
			keyInt, err := strconv.Atoi(treasureObject.GetKey())
			assert.Nil(t, err, "should not return error")
			assert.Equal(t, lastID, keyInt, fmt.Sprintf("key should be equal to %d", lastID))
			lastID++
		}

		err = b.SortByValueFloat64DESC()
		assert.Nil(t, err, "should not return error")

		treasures, err = b.GetManyFromOrderPosition(0, 10)
		assert.Nil(t, err, "should not return error")

		lastID = 9
		for _, treasureObject := range treasures {
			keyInt, err := strconv.Atoi(treasureObject.GetKey())
			assert.Nil(t, err, "should not return error")
			assert.Equal(t, lastID, keyInt, fmt.Sprintf("key should be equal to %d", lastID))
			lastID--
		}

	})

	// SortByValueFloat32ASC() error
	// SortByValueFloat32DESC() error
	t.Run("should get treasures by value float", func(t *testing.T) {

		b := New()
		b.SetInitialized(true)
		b.SetIsOrdered(true)

		// create 10 non-expired treasures and add them to the beacon
		for i := 0; i < 10; i++ {
			treasureInterface := treasure.New(MySaveFunction)
			guardID := treasureInterface.StartTreasureGuard(true, guard.BodyAuthID)
			treasureInterface.BodySetKey(guardID, fmt.Sprintf("%d", i))
			treasureInterface.SetContentFloat32(guardID, 1.12+float32(i))
			treasureInterface.ReleaseTreasureGuard(guardID)
			b.Add(treasureInterface)
		}

		err := b.SortByValueFloat32ASC()
		assert.Nil(t, err, "should not return error")

		treasures, err := b.GetManyFromOrderPosition(0, 10)
		assert.Nil(t, err, "should not return error")

		lastID := 0
		for _, treasureObject := range treasures {
			keyInt, err := strconv.Atoi(treasureObject.GetKey())
			assert.Nil(t, err, "should not return error")
			assert.Equal(t, lastID, keyInt, fmt.Sprintf("key should be equal to %d", lastID))
			lastID++
		}

		err = b.SortByValueFloat32DESC()
		assert.Nil(t, err, "should not return error")

		treasures, err = b.GetManyFromOrderPosition(0, 10)
		assert.Nil(t, err, "should not return error")

		lastID = 9
		for _, treasureObject := range treasures {
			keyInt, err := strconv.Atoi(treasureObject.GetKey())
			assert.Nil(t, err, "should not return error")
			assert.Equal(t, lastID, keyInt, fmt.Sprintf("key should be equal to %d", lastID))
			lastID--
		}

	})

	// SortByValueStringASC() error
	// SortByValueStringDESC() error
	t.Run("should get treasures by value string", func(t *testing.T) {

		b := New()
		b.SetInitialized(true)
		b.SetIsOrdered(true)

		// create 10 non-expired treasures and add them to the beacon
		for i := 0; i < 10; i++ {
			treasureInterface := treasure.New(MySaveFunction)
			guardID := treasureInterface.StartTreasureGuard(true, guard.BodyAuthID)
			treasureInterface.BodySetKey(guardID, fmt.Sprintf("%d", i))
			treasureInterface.SetContentString(guardID, fmt.Sprintf("content-%d", i))
			treasureInterface.ReleaseTreasureGuard(guardID)
			b.Add(treasureInterface)
		}

		err := b.SortByValueStringASC()
		assert.Nil(t, err, "should not return error")

		treasures, err := b.GetManyFromOrderPosition(0, 10)
		assert.Nil(t, err, "should not return error")

		lastID := 0
		for _, treasureObject := range treasures {
			keyInt, err := strconv.Atoi(treasureObject.GetKey())
			assert.Nil(t, err, "should not return error")
			assert.Equal(t, lastID, keyInt, fmt.Sprintf("key should be equal to %d", lastID))
			lastID++
		}

		err = b.SortByValueStringDESC()
		assert.Nil(t, err, "should not return error")

		treasures, err = b.GetManyFromOrderPosition(0, 10)
		assert.Nil(t, err, "should not return error")

		lastID = 9
		for _, treasureObject := range treasures {
			keyInt, err := strconv.Atoi(treasureObject.GetKey())
			assert.Nil(t, err, "should not return error")
			assert.Equal(t, lastID, keyInt, fmt.Sprintf("key should be equal to %d", lastID))
			lastID--
		}

	})

	// PushManyFromMap
	// GetManyFromOrderPosition
	t.Run("should push many treasures to the beacon from map", func(t *testing.T) {

		b := New()
		b.SetInitialized(true)
		b.SetIsOrdered(true)

		treasures := make(map[string]treasure.Treasure)
		// create 10 non-expired treasures and add them to the map
		for i := 0; i < 10; i++ {
			treasureInterface := treasure.New(MySaveFunction)
			guardID := treasureInterface.StartTreasureGuard(true, guard.BodyAuthID)
			treasureInterface.BodySetKey(guardID, fmt.Sprintf("%d", i))
			treasureInterface.SetContentString(guardID, fmt.Sprintf("content-%d", i))
			treasureInterface.ReleaseTreasureGuard(guardID)
			// add the treasure to the map
			treasures[treasureInterface.GetKey()] = treasureInterface
		}

		b.PushManyFromMap(treasures)

		assert.Equal(t, 10, b.Count(), "all treasures count should be equal to 10")

		receivedTreasures, err := b.GetManyFromOrderPosition(0, 5)
		assert.Nil(t, err, "should not return error")

		assert.Equal(t, 5, len(receivedTreasures), "received treasures count should be equal to 10")

	})

	// CloneUnorderedTreasures
	t.Run("should clone unordered treasures", func(t *testing.T) {

		b := New()
		b.SetInitialized(true)

		// create 10 non-expired treasures and add them to the beacon
		for i := 0; i < 10; i++ {
			treasureInterface := treasure.New(MySaveFunction)
			guardID := treasureInterface.StartTreasureGuard(true, guard.BodyAuthID)
			treasureInterface.BodySetKey(guardID, fmt.Sprintf("%d", i))
			treasureInterface.SetContentString(guardID, fmt.Sprintf("content-%d", i))
			treasureInterface.ReleaseTreasureGuard(guardID)
			b.Add(treasureInterface)
		}

		// clone unordered treasures, then DO NOT reset the beacon
		clonedTreasures := b.CloneUnorderedTreasures(false)

		assert.Equal(t, 10, len(clonedTreasures), "cloned treasures count should be equal to 10")

		// clone unordered treasures, then reset the beacon
		clonedTreasures = b.CloneUnorderedTreasures(true)

		assert.Equal(t, 10, len(clonedTreasures), "cloned treasures count should be equal to 10")
		assert.Equal(t, 0, b.Count(), "all treasures count should be equal to 0")

		clonedTreasures = b.CloneUnorderedTreasures(true)

		assert.Equal(t, 0, len(clonedTreasures), "cloned treasures count should be equal to 0")

	})

	t.Run("should shift treasures from the unordered treasures", func(t *testing.T) {

		b := New()
		b.SetInitialized(true)
		b.SetIsOrdered(true)

		// create 10 non-expired treasures and add them to the beacon
		for i := 0; i < 10; i++ {
			treasureInterface := treasure.New(MySaveFunction)
			guardID := treasureInterface.StartTreasureGuard(true, guard.BodyAuthID)
			treasureInterface.BodySetKey(guardID, fmt.Sprintf("key-%d", i))
			treasureInterface.SetContentString(guardID, fmt.Sprintf("content-%d", i))
			treasureInterface.ReleaseTreasureGuard(guardID)
			b.Add(treasureInterface)
		}

		shiftedTreasureObject := b.ShiftOne("key-5")

		assert.Equal(t, "key-5", shiftedTreasureObject.GetKey(), "key should be equal to key-5")

		shiftedTreasureObject = b.ShiftOne("key-5")

		assert.Nil(t, shiftedTreasureObject, "shifted treasure object should be nil")

		shiftedTreasures := b.ShiftMany(10)

		assert.Equal(t, 9, len(shiftedTreasures), "shifted treasures count should be equal to 9")
		assert.Equal(t, 0, b.Count(), "all treasures count should be equal to 0")

	})

}

--------------------------------------------------------------------------------

/==============================================================================\
| FILE: core\hydra\swamp\chronicler\chronicler.go
| PATH: C:\go\src\hydraide\app\core\hydra\swamp\chronicler\chronicler.go
| SIZE: 15.4 KB
\==============================================================================/

// Package chronicler A chronicler is responsible for the retrieval and reading of level files, as swamp as managing
// the file system, located in the swamp. The chronicler is able to write new data, modify existing ones, and
// permanently delete data marked for deletion from the file system. Additionally, it can create non-existent directory
// structures and completely delete a swamp object from the file system. It has direct access to the compressor,
// allowing it to compress data and decode compressed data as swamp.
package chronicler

import (
	"github.com/google/uuid"
	"github.com/hydraide/hydraide/app/core/compressor"
	"github.com/hydraide/hydraide/app/core/filesystem"
	"github.com/hydraide/hydraide/app/core/hydra/swamp/beacon"
	"github.com/hydraide/hydraide/app/core/hydra/swamp/metadata"
	"github.com/hydraide/hydraide/app/core/hydra/swamp/treasure"
	"github.com/hydraide/hydraide/app/core/hydra/swamp/treasure/guard"
	"github.com/hydraide/hydraide/app/name"
	"log/slog"
	"math"
	"os"
	"path/filepath"
	"sync"
)

type Chronicler interface {
	Write(treasures []treasure.Treasure)
	Load(indexObj beacon.Beacon)
	CreateDirectoryIfNotExists()
	Destroy()
	GetSwampAbsPath() string
	IsFilesystemInitiated() bool
	RegisterSaveFunction(swampSaveFunction func(t treasure.Treasure, guardID guard.ID) treasure.TreasureStatus)
	DontSendFilePointer() // if we don't want to send the file pointer to the swamp, because it will be closed soon
	// RegisterFilePointerFunction egy filepointer callback funkciót regisztrálhat a swamp
	RegisterFilePointerFunction(filePointerFunction func(event []*FileNameEvent) error)
}

type FileNameEvent struct {
	TreasureKey string
	FileName    string
}

const (
	SnappyCompressionPercent = 0.36 // the compression rate of the snappy compression method
	ActualFileKeyInMeta      = "actual"
)

type chronicler struct {
	mu                          sync.RWMutex
	swampName                   name.Name
	swampDataFolderPath         string // absolute path, where the .actual file is located
	maxFileSize                 int
	modifiedTreasuresForWrite   map[string]map[string]treasure.Treasure
	newTreasuresForWrite        []treasure.Treasure
	compressionMethod           compressor.Type
	sanctuaryAbsPath            string // the path of the hydra, where the swamp is located
	filesystemInitiated         bool   // true if the directory is initiated
	swampSaveFunction           func(t treasure.Treasure, guardID guard.ID) treasure.TreasureStatus
	dontSendFilePointer         bool // true if we don't want to send the file pointer to the swamp, because it will be closed soon
	compressedFolderExists      bool // true if the compressed folder exists
	filePointerCallbackFunction func(event []*FileNameEvent) error
	filesystemInterface         filesystem.Filesystem
	compressorInterface         compressor.Compressor
	metadataInterface           metadata.Metadata
	maxDepth                    int
}

// New creates new filesystem for a swamp
func New(swampDataFolderPath string, maxFileSize int64, maxDepth int, filesystemInterface filesystem.Filesystem, metaInterface metadata.Metadata) Chronicler {

	fsObj := &chronicler{
		swampDataFolderPath:       swampDataFolderPath,
		maxFileSize:               calculateOverloadSize(maxFileSize),
		modifiedTreasuresForWrite: make(map[string]map[string]treasure.Treasure),
		compressionMethod:         compressor.Snappy, // we used the Snappy compression method by default
		filesystemInterface:       filesystemInterface,
		metadataInterface:         metaInterface,
		maxDepth:                  maxDepth,
	}

	fsObj.compressorInterface = compressor.New(fsObj.compressionMethod)

	return fsObj

}

func (c *chronicler) DontSendFilePointer() {
	c.mu.Lock()
	defer c.mu.Unlock()
	// close the file pointer channel
	c.dontSendFilePointer = true
}

func (c *chronicler) RegisterFilePointerFunction(filePointerFunction func(event []*FileNameEvent) error) {
	c.mu.Lock()
	defer c.mu.Unlock()
	c.filePointerCallbackFunction = filePointerFunction
}

func (c *chronicler) RegisterSaveFunction(swampSaveFunction func(t treasure.Treasure, guardID guard.ID) treasure.TreasureStatus) {
	c.mu.Lock()
	defer c.mu.Unlock()
	c.swampSaveFunction = swampSaveFunction
}

// GetSwampAbsPath returns the absolute path of the swamp's directory
func (c *chronicler) GetSwampAbsPath() string {
	c.mu.RLock()
	defer c.mu.RUnlock()
	return c.swampDataFolderPath
}

// CreateDirectoryIfNotExists creates the directory for the swamp if it is not exists
// the create method separated, because the Hydra can call Destroy method separately, so the New method can not create
// the swamp directory itself
func (c *chronicler) CreateDirectoryIfNotExists() {

	c.mu.Lock()
	defer c.mu.Unlock()

	if err := c.filesystemInterface.CreateFolder(c.swampDataFolderPath); err != nil {
		slog.Error("can not create the directory for the swamp", "error", err)
	}

	c.filesystemInitiated = true

}

// Destroy deletes the swamp directory with all contained files
// this is a dangerous and a possibly long-running operation
// The function will send panic if we can not delete the folder
func (c *chronicler) Destroy() {

	c.mu.Lock()
	defer c.mu.Unlock()

	if err := c.filesystemInterface.DeleteAllFiles(c.swampDataFolderPath); err != nil {
		slog.Error("can not delete the swamp directory", "error", err)
		return
	}

	// delete all unnecessary folders from the filesystem
	if err := c.filesystemInterface.DeleteFolder(c.swampDataFolderPath, c.maxDepth); err != nil {
		slog.Error("can not delete the swamp directory with all empty folders", "error", err)
	}

}

func (c *chronicler) IsFilesystemInitiated() bool {
	c.mu.RLock()
	defer c.mu.RUnlock()
	return c.filesystemInitiated
}

// Load the whole swamp from the filesystem with all contents and return with it
func (c *chronicler) Load(indexObj beacon.Beacon) {

	c.mu.Lock()
	defer c.mu.Unlock()

	contents, err := c.filesystemInterface.GetAllFileContents(c.swampDataFolderPath, metadata.MetaFile)
	if err != nil {
		slog.Error("can not read the actual file", "error", err)
		return
	}

	// iterating over the contents
	treasures := make(map[string]treasure.Treasure)

	for fileName, byteTreasures := range contents {
		for _, byteTreasure := range byteTreasures {

			treasureInterface := treasure.New(c.swampSaveFunction)
			guardID := treasureInterface.StartTreasureGuard(true, guard.BodyAuthID)
			errFromByte := treasureInterface.LoadFromByte(guardID, byteTreasure, fileName)
			if errFromByte != nil {
				return
			}
			treasureInterface.ReleaseTreasureGuard(guardID)
			treasures[treasureInterface.GetKey()] = treasureInterface

		}
	}

	// add all treasures to the index object
	indexObj.PushManyFromMap(treasures)

}

// Write all Treasures to the filesystem
func (c *chronicler) Write(treasures []treasure.Treasure) {

	c.mu.Lock()
	defer c.mu.Unlock()

	defer func() {
		c.modifiedTreasuresForWrite = make(map[string]map[string]treasure.Treasure) // clear the map
		c.newTreasuresForWrite = nil                                                // clear the slice
	}()

	var modifiedTreasuresWaitingForWriter bool
	var newTreasuresWaitingForWriter bool

	for _, selectedTreasure := range treasures {

		fileName := selectedTreasure.GetFileName()

		if fileName != nil {
			// add the treasure to the modified treasures map if it is not exists
			if c.modifiedTreasuresForWrite[*fileName] == nil {
				c.modifiedTreasuresForWrite[*fileName] = make(map[string]treasure.Treasure)
			}
			// add the modified treasure to the map
			c.modifiedTreasuresForWrite[*fileName][selectedTreasure.GetKey()] = selectedTreasure
			modifiedTreasuresWaitingForWriter = true
		} else {
			// add new treasures to the slice
			c.newTreasuresForWrite = append(c.newTreasuresForWrite, selectedTreasure)
			newTreasuresWaitingForWriter = true
		}
	}

	// process the modified treasures in the filesystem FIRST
	// this is important, because there may be some modified treasures in the actual folder, and we need to modify them first,
	// before the new treasure writer starts the working...
	if modifiedTreasuresWaitingForWriter {
		c.modifyTreasuresInFilesystem()
	}

	// if there is at least 1 new treasure that waits for the writer
	if newTreasuresWaitingForWriter {
		// write new treasures to the filesystem
		c.writeNewTreasures(c.newTreasuresForWrite)
	}

}

// modifyTreasuresInFilesystem modifies the treasures in the filesystem
func (c *chronicler) modifyTreasuresInFilesystem() {
	// write existing treasures
	for fileName, treasures := range c.modifiedTreasuresForWrite {
		// replace all treasures in the folder
		c.writeModifiedTreasures(fileName, treasures)
	}
}

// writeNewTreasures recursively writes the new treasures to the filesystem
func (c *chronicler) writeNewTreasures(newTreasures []treasure.Treasure) {

	workingFile := c.getActualFile()

	fileSize, _ := c.filesystemInterface.GetFileSize(workingFile)
	byteContent := make([][]byte, 0)

	// get the actual size of the file
	actualSizeInBytes := int(fileSize)
	// count how many newTreasures can be written to the file
	countTreasures := len(newTreasures)

	filePointerEvents := make([]*FileNameEvent, 0, countTreasures)

	// iterating over the newTreasures
	for k, t := range newTreasures {

		// convert the treasure to the binary data
		guardID := t.StartTreasureGuard(true, guard.BodyAuthID)
		b, convertErr := t.ConvertToByte(guardID)
		if convertErr != nil {
			t.ReleaseTreasureGuard(guardID)
			continue
		}
		t.ReleaseTreasureGuard(guardID)

		byteContent = append(byteContent, b)

		actualSizeInBytes += int(float64(len(b)) * SnappyCompressionPercent)

		// if the size of the folder is bigger than the max folder size we need to create a new folder and write the rest of the newTreasures
		if actualSizeInBytes > c.maxFileSize {
			// if there are more than one treasure that wait for the next folder
			if k+1 < countTreasures {
				// create new actual file
				c.createActualFile()
				// send the rest of the newTreasures to the next folder
				c.writeNewTreasures(newTreasures[k+1:])
				break
			}
		}

		// collect file pointer events
		filePointerEvents = append(filePointerEvents, &FileNameEvent{
			TreasureKey: t.GetKey(),
			FileName:    filepath.Base(workingFile),
		})

	}

	// write the data to filesystem
	if err := c.filesystemInterface.SaveFile(workingFile, byteContent, true); err != nil {
		slog.Error("can not write the new treasures to the filesystem", "error", err)
		return
	}

	// send file pointer events
	c.sendFilePointerEvents(filePointerEvents)

}

func (c *chronicler) sendFilePointerEvents(filePointerEvents []*FileNameEvent) {

	if c.dontSendFilePointer || len(filePointerEvents) == 0 {
		return
	}

	// send events if there is callback function registered
	if c.filePointerCallbackFunction != nil {
		if err := c.filePointerCallbackFunction(filePointerEvents); err != nil {
			// if the swamp is closed, but this is not an error
		}
	}

}

// replaceLineInFile replaces the selected lines in the folder
func (c *chronicler) writeModifiedTreasures(fileName string, treasures map[string]treasure.Treasure) {

	// the file path
	fp := filepath.Join(c.swampDataFolderPath, fileName)

	byteTreasures, err := c.filesystemInterface.GetFile(fp)
	if err != nil {
		slog.Error("can not read the file", "file absolute path", fp, "error", err)
		return
	}

	modifiedTreasures := make([][]byte, 0)

	for _, treasureData := range byteTreasures {

		treasureObject := treasure.New(c.swampSaveFunction)
		lockerID := treasureObject.StartTreasureGuard(true, guard.BodyAuthID)
		loadErr := treasureObject.LoadFromByte(lockerID, treasureData, fileName)
		treasureObject.ReleaseTreasureGuard(lockerID)
		if loadErr != nil {
			slog.Error("can not load the treasure from the binary data", "error", loadErr)
			continue
		}

		// 3. check the treasure key
		treasureKey := treasureObject.GetKey()
		if modifiedTreasure, exist := treasures[treasureKey]; exist {

			// treasure exists in the modified treasures, so we need to modify it
			treasureGuardID := modifiedTreasure.StartTreasureGuard(true, guard.BodyAuthID)
			modifiedBytes, convertErr := modifiedTreasure.ConvertToByte(treasureGuardID)
			modifiedTreasure.ReleaseTreasureGuard(treasureGuardID)
			if convertErr != nil {
				slog.Error("can not convert the modified treasure to byte", "error", convertErr)
				continue
			}

			// The treasure was permanently deleted, not just shadowDeleted,
			// so we also need to remove it from the filesystem.
			// Therefore, we do NOT write this treasure back to the file.
			if modifiedTreasure.GetDeletedAt() != 0 && modifiedTreasure.GetDeletedBy() != "" && !modifiedTreasure.GetShadowDelete() {
				continue
			}

			// Write back the modified treasure.
			modifiedTreasures = append(modifiedTreasures, modifiedBytes)

		} else {

			// The original treasure was not modified, so we write back the original data.
			modifiedTreasures = append(modifiedTreasures, treasureData)

		}

	}

	// All data has been deleted from the file, so we remove the file itself.
	if len(modifiedTreasures) == 0 {
		c.deleteFile(fp)
		return
	}

	// Write the modified treasures back to the file.
	if err := c.filesystemInterface.SaveFile(fp, modifiedTreasures, false); err != nil {
		slog.Error("can not write the modified treasures to the filesystem", "error", err, "file absolute path", fp)
		return
	}

}

func (c *chronicler) deleteFile(filePath string) {

	if err := c.filesystemInterface.DeleteFile(filePath); err != nil {
		slog.Error("can not delete the file", "error", err, "file absolute path", filePath)
	}

}

func (c *chronicler) decompressFile(fp string) []byte {

	compressedByteContent, err := os.ReadFile(fp)
	if err != nil {
		slog.Error("can not read the compressed file", "error", err, "file absolute path", fp)
		return nil
	}

	if len(compressedByteContent) == 0 {
		return nil // empty file
	}

	// decompress file
	compressorInterface := compressor.New(c.compressionMethod)
	byteContent, err := compressorInterface.Decompress(compressedByteContent)

	if err != nil {
		slog.Error("can not decompress the compressed file", "error", err, "file absolute path", fp)
		return nil
	}

	return byteContent

}

func (c *chronicler) getActualFile() (actualFilePath string) {
	actualFilePath = c.metadataInterface.GetKey(ActualFileKeyInMeta)
	if actualFilePath != "" {
		return filepath.Join(c.swampDataFolderPath, actualFilePath)
	}
	return c.createActualFile()
}

// createActualFile creates the actual folder in the filesystem
func (c *chronicler) createActualFile() (filePath string) {

	// create an empty file with new uuid
	actualFileUUID := uuid.NewString()
	filePath = filepath.Join(c.swampDataFolderPath, actualFileUUID)

	if err := c.filesystemInterface.SaveFile(filePath, nil, false); err != nil {
		slog.Error("can not create the actual file", "error", err, "file absolute path", filePath)
		return ""
	}

	// create the actual key in the metadata
	c.metadataInterface.SetKey(ActualFileKeyInMeta, actualFileUUID)

	return filePath

}

// calculateOverloadSize calculates the size of the overloaded folder because the folder will be compressed
// and this is the
func calculateOverloadSize(maxFileSizeBytes int64) int {
	overloadedSize := float64(maxFileSizeBytes) / SnappyCompressionPercent
	return int(math.Floor(overloadedSize*1) / 1)
}

--------------------------------------------------------------------------------

/==============================================================================\
| FILE: core\hydra\swamp\metadata\metadata.go
| PATH: C:\go\src\hydraide\app\core\hydra\swamp\metadata\metadata.go
| SIZE: 6.7 KB
\==============================================================================/

// Package metadata provides persistent metadata storage for swamps.
// It tracks when each swamp was created, when its data was last updated,
// and what path or identifier is used to access it.
//
// It also allows storing custom key-value metadata alongside each swamp,
// which can be used by the client based on their business logic.
//
// For example, a client may store access control rules, such as
// what roles can access the swamp, or which users have permission —
// and build custom logic on top of that if needed.
package metadata

import (
	"encoding/gob"
	"github.com/hydraide/hydraide/app/name"
	"log/slog"
	"os"
	"path/filepath"
	"sync"
	"time"
)

const MetaFile = "meta"

type Meta struct {
	// The full name of the swamp, used for reverse lookup even if accessed through a hashed folder path. Variable length.
	SwampName string
	// CreatedAt is the timestamp when the swamp was initially created.
	CreatedAt time.Time
	// UpdatedAt is the timestamp of the last data modification in the swamp.
	UpdatedAt time.Time
	// BackupAt is the timestamp of the last backup operation.
	// TODO: Make this persistable for our upcoming backup system.
	BackupAt time.Time
	// KeyValuePairs are custom metadata entries that can only be set internally by the system.
	KeyValuePairs map[string]string
}

type Metadata interface {
	// LoadFromFile loads the metadata from a file into memory.
	LoadFromFile()

	// SaveToFile persists the metadata to disk — but only if it has changed — and then frees memory.
	SaveToFile()

	// SetSwampName sets the swamp name inside the metadata.
	// This is needed for cases where swamps are loaded by iterating over hashed folder names:
	// we load the metadata first, extract the swamp name, and then load the swamp using its proper name.
	// Therefore, the swamp name must always be saved inside the metadata.
	SetSwampName(swampName name.Name)

	// GetSwampName returns the swamp's name, used to access the swamp directly.
	GetSwampName() name.Name

	// GetCreatedAt returns the timestamp of metadata creation.
	GetCreatedAt() time.Time

	// GetUpdatedAt returns the timestamp of the last metadata update.
	GetUpdatedAt() time.Time

	// GetKey returns the value of a custom metadata key.
	GetKey(key string) string

	// SetKey stores a value under the given metadata key.
	SetKey(key, value string)

	// DeleteKey removes a key-value pair from the metadata.
	DeleteKey(key string) error

	// SetUpdatedAt updates the last modification timestamp to now.
	SetUpdatedAt()

	// Destroy deletes the metadata file and clears the in-memory metadata object.
	// Useful when the object it was attached to has been deleted and will never be used again.
	// Note: currently the file system deletes the metadata file via DeleteAllFiles within the swamp folder,
	// either when Destroy is called on the swamp, or when the swamp has no remaining data.
	Destroy()
}

type metadata struct {
	mu         sync.RWMutex
	meta       *Meta
	path       string
	isModified bool
}

func New(path string) Metadata {
	m := &metadata{
		path: path,
		meta: &Meta{
			KeyValuePairs: make(map[string]string),
		},
	}
	return m
}

func (m *metadata) LoadFromFile() {
	m.load()
	// After loading, we check whether the metadata has a valid creation timestamp.
	// If not, we immediately set it after the first load — this value will then be considered the creation time.
	if m.meta.CreatedAt == (time.Time{}) {
		m.meta.CreatedAt = time.Now().UTC()
	}
}

func (m *metadata) SaveToFile() {
	m.mu.RLock()
	defer m.mu.RUnlock()
	if !m.isModified {
		return
	}
	if err := m.save(); err != nil {
		slog.Error("failed to save metadata to file", "error", err)
	}
}

func (m *metadata) SetSwampName(swampName name.Name) {
	m.mu.Lock()
	defer m.mu.Unlock()
	sn := swampName.Get()
	if m.meta.SwampName == "" {
		m.meta.SwampName = sn
		m.isModified = true
		return
	}
	if m.meta.SwampName != sn {
		m.meta.SwampName = sn
		m.isModified = true
	}
}

func (m *metadata) GetSwampName() name.Name {
	m.mu.RLock()
	defer m.mu.RUnlock()
	return name.Load(m.meta.SwampName)
}

func (m *metadata) GetCreatedAt() time.Time {
	m.mu.RLock()
	defer m.mu.RUnlock()
	return m.meta.CreatedAt
}

func (m *metadata) GetUpdatedAt() time.Time {
	m.mu.RLock()
	defer m.mu.RUnlock()
	return m.meta.UpdatedAt
}

func (m *metadata) Destroy() {
	m.mu.Lock()
	defer m.mu.Unlock()
	m.meta = &Meta{KeyValuePairs: make(map[string]string)} // default
	m.delete()
}

func (m *metadata) GetKey(key string) string {
	m.mu.RLock()
	defer m.mu.RUnlock()
	if value, ok := m.meta.KeyValuePairs[key]; ok {
		return value
	}
	return ""
}

func (m *metadata) SetKey(key, value string) {
	m.mu.Lock()
	defer m.mu.Unlock()
	existing, ok := m.meta.KeyValuePairs[key]
	if ok && existing == value {
		return
	}
	m.meta.KeyValuePairs[key] = value
	m.isModified = true
}

func (m *metadata) DeleteKey(key string) error {
	m.mu.Lock()
	defer m.mu.Unlock()
	if _, ok := m.meta.KeyValuePairs[key]; !ok {
		return nil
	}
	delete(m.meta.KeyValuePairs, key)
	m.isModified = true
	return nil
}

func (m *metadata) SetUpdatedAt() {
	m.mu.Lock()
	defer m.mu.Unlock()
	m.meta.UpdatedAt = time.Now().UTC()
	m.isModified = true
}

// load metadata
func (m *metadata) load() {

	file, err := os.Open(filepath.Join(m.path, MetaFile))
	if err != nil {
		// this is not an error, because the metadata file does not exist yet
		return
	}

	defer func() {
		if err := file.Close(); err != nil {
			slog.Error("failed to close metadata file", "error", err)
		}
	}()

	// Unmarshal the GOB encoded file into m.meta
	decoder := gob.NewDecoder(file)
	if err := decoder.Decode(&m.meta); err != nil {
		slog.Error("failed to decode metadata from GOB", "error", err)
		m.meta = &Meta{KeyValuePairs: make(map[string]string)} // default
	}
}

// save the metadata to the filesystem
func (m *metadata) save() error {

	mFile := filepath.Join(m.path, MetaFile)

	// IMPORTANT!! We do NOT create the folder structure here — it's the swamp's responsibility to create it.
	file, err := os.Create(mFile)
	if err != nil {
		slog.Error("failed to create metadata file", "error", err, "metadata_file", mFile)
		return err
	}

	defer func() {
		if err := file.Close(); err != nil {
			slog.Error("failed to close metadata file", "error", err)
		}
	}()

	// gob encoder
	encoder := gob.NewEncoder(file)
	if err := encoder.Encode(m.meta); err != nil {
		slog.Error("failed to encode metadata to GOB", "error", err)
		return err
	}

	return nil

}

func (m *metadata) delete() {
	// delete metadata from the filesystem
	_ = os.Remove(filepath.Join(m.path, MetaFile))
}

--------------------------------------------------------------------------------

/==============================================================================\
| FILE: core\hydra\swamp\metadata\metadata_test.go
| PATH: C:\go\src\hydraide\app\core\hydra\swamp\metadata\metadata_test.go
| SIZE: 2.9 KB
\==============================================================================/

package metadata

import (
	"github.com/hydraide/hydraide/app/name"
	"github.com/stretchr/testify/assert"
	"github.com/stretchr/testify/require"
	"os"
	"path/filepath"
	"testing"
	"time"
)

func TestMetadataLifecycle(t *testing.T) {
	tmpDir := t.TempDir()
	metaPath := filepath.Join(tmpDir, "testswamp")

	// simulate the swamp folder
	require.NoError(t, os.Mkdir(metaPath, 0755))

	m := New(metaPath)
	m.LoadFromFile()

	// Test initial creation
	assert.NotZero(t, m.GetCreatedAt(), "CreatedAt should be set after first load")

	// Set and get key
	m.SetKey("foo", "bar")
	assert.Equal(t, "bar", m.GetKey("foo"))

	// Update and save
	m.SetUpdatedAt()
	m.SaveToFile()

	// Check if meta file was created
	metaFile := filepath.Join(metaPath, "meta")
	_, err := os.Stat(metaFile)
	assert.NoError(t, err, "meta file should be saved")

	// Reload and verify
	m2 := New(metaPath)
	m2.LoadFromFile()
	assert.Equal(t, "bar", m2.GetKey("foo"))
	assert.Equal(t, m.GetCreatedAt(), m2.GetCreatedAt())
	assert.WithinDuration(t, m.GetUpdatedAt(), m2.GetUpdatedAt(), time.Second)
}

func TestMetadataSwampName(t *testing.T) {
	tmpDir := t.TempDir()

	m := New(tmpDir)
	m.LoadFromFile()

	nameObj := name.New().Sanctuary("ceg123").Realm("kereses456").Swamp("valami")
	m.SetSwampName(nameObj)
	m.SaveToFile()
	assert.Equal(t, nameObj.GetSwampName(), m.GetSwampName().GetSwampName())

	m2 := New(tmpDir)
	m2.LoadFromFile()

	if m2.GetSwampName() == nil {
		t.Fatalf("SwampName should not be nil")
	}

	assert.Equal(t, nameObj.GetSwampName(), m2.GetSwampName().GetSwampName())
}

func TestKeyDelete(t *testing.T) {
	tmpDir := t.TempDir()
	m := New(tmpDir)
	m.SetKey("temp", "deleteMe")
	err := m.DeleteKey("temp")
	assert.NoError(t, err)
	assert.Equal(t, "", m.GetKey("temp"))
}

func TestKey(t *testing.T) {
	tmpDir := t.TempDir()
	m := New(tmpDir)
	m.LoadFromFile()
	m.SetKey("temp", "value")
	m.SaveToFile()

	m2 := New(tmpDir)
	m2.LoadFromFile()

	assert.Equal(t, "value", m2.GetKey("temp"))
}

func TestDestroy(t *testing.T) {

	tmpDir := t.TempDir()

	m := New(tmpDir)
	m.SetKey("destroy", "yes")
	m.SaveToFile()

	metaFile := filepath.Join(tmpDir, "meta")
	assert.FileExists(t, metaFile)

	m.Destroy()

	_, err := os.Stat(metaFile)
	assert.Error(t, err)
	assert.True(t, os.IsNotExist(err), "meta file should be deleted")

}

func TestCreatedAt(t *testing.T) {
	tmpDir := t.TempDir()

	m := New(tmpDir)
	m.LoadFromFile()
	m.SaveToFile()

	m2 := New(tmpDir)
	m2.LoadFromFile()

	assert.NotEqual(t, time.Time{}, m2.GetCreatedAt())
	assert.Less(t, m2.GetCreatedAt(), time.Now())

}

func TestUpdatedAt(t *testing.T) {

	tmpDir := t.TempDir()

	m := New(tmpDir)
	m.LoadFromFile()
	m.SetUpdatedAt()
	m.SaveToFile()

	m2 := New(tmpDir)
	m2.LoadFromFile()

	assert.NotEqual(t, time.Time{}, m2.GetUpdatedAt())
	assert.Less(t, m2.GetUpdatedAt(), time.Now())

}

--------------------------------------------------------------------------------

/==============================================================================\
| FILE: core\hydra\swamp\swamp.go
| PATH: C:\go\src\hydraide\app\core\hydra\swamp\swamp.go
| SIZE: 106.1 KB
\==============================================================================/

package swamp

import (
	"context"
	"errors"
	"github.com/hydraide/hydraide/app/core/hydra/swamp/beacon"
	"github.com/hydraide/hydraide/app/core/hydra/swamp/chronicler"
	"github.com/hydraide/hydraide/app/core/hydra/swamp/metadata"
	"github.com/hydraide/hydraide/app/core/hydra/swamp/treasure"
	"github.com/hydraide/hydraide/app/core/hydra/swamp/treasure/guard"
	"github.com/hydraide/hydraide/app/core/hydra/swamp/vigil"
	"github.com/hydraide/hydraide/app/name"
	"log/slog"
	"sync"
	"sync/atomic"
	"time"
)

const (
	ErrorValueIsNotInt   = "the value is not an integer"
	ErrorValueIsNotFloat = "the value is not a float"
)

type Swamp interface {

	// Vigil handler for the swamp
	vigil.Vigil

	// GetMetadata visszaadja a Metaadat objektumát a swampnak
	GetMetadata() metadata.Metadata

	// WaitForGracefulClose Wait for the swamp to close gracefully and writes the treasures to the filesystem
	// this is a blocker function and any threads can be subscribed to this function
	WaitForGracefulClose(ctx context.Context) error

	// CountTreasuresWaitingForWriter returns the number of treasures waiting for the writer to write them to the filesystem.
	CountTreasuresWaitingForWriter() int

	// CreateTreasure creates a single "Treasure" object that can be populated with data.
	//
	// This function takes a key string as a parameter to uniquely identify the treasure once it's stored in the Swamp.
	// You can create a new Treasure object using this function, populate it with data using the methods provided by the
	// `treasure.Treasure` interface, and then save it in the Swamp using the `SaveTreasure` function.
	//
	// The function creates a Treasure object and sets only its key. If necessary, all other parameter settings depend
	// on the developer and business logic.
	//
	// The function does not save the Treasure to any swamp, it simply creates it as a standalone object that exists
	// only in memory. Saving to a swamp is left to the developer and the business logic to decide.
	//
	// Example:
	//     // Start a Vigil to prevent the Swamp from shutting down
	//     swamp.BeginVigil()
	//
	//     // Create a Treasure object with a unique key
	//     myTreasure := swamp.CreateTreasure("someKey")
	//	   // Populate the treasure with data
	//		...
	//
	//     // Check the status of the treasure if you want
	//
	//     // Release the Vigil. This is important to unlock the Swamp and allow it to shut down.
	//     swamp.CeaseVigil()
	//
	// Returns:
	// - A `treasure.Treasure` interface representing a treasure that can be populated with data and stored in the Swamp.
	//
	// Use-cases:
	// 1. Creating a new Treasure object with a unique key.
	// 2. Populating the treasure with data before storing it in the Swamp.
	CreateTreasure(key string) treasure.Treasure

	// GetTreasure retrieves a single "Treasure" from a "Swamp" by its unique key.
	//
	// This function takes a key string as a parameter, which uniquely identifies the desired treasure within the Swamp.
	// It returns a `treasure.Treasure` object representing the retrieved treasure and an error if the retrieval fails,
	// or the treasure doesn't exist.
	//
	// Real-world use-case:
	//    Fetching specific user details for profile display.
	//
	// Example:
	//     key := "user123"
	//
	// 	   swamp.BeginVigil()
	//     retrievedTreasure, err := swamp.GetTreasure(key)
	//	   swamp.CeaseVigil()
	//
	//     if err != nil {
	//         log.Println("Failed to retrieve the treasure:", err)
	//     } else {
	//         log.Printf("treasure: %+v\n", retrievedTreasure)
	//     }
	//
	// Returns:
	// - A `treasure.Treasure` object representing the retrieved treasure.
	// - An error if the retrieval fails, because the treasure does not exist, which can be checked with `err != nil`.
	//
	// Use-cases:
	// 1. Fetching specific data or resources from the Swamp using a unique key.
	// 2. Real-world scenarios such as retrieving user details for profile display.
	GetTreasure(key string) (treasure treasure.Treasure, err error)

	// GetAll retrieves all "Treasures" from a "Swamp."
	//
	// This function fetches all treasures from the Swamp and returns them as a map of key-value pairs, where the key is the
	// unique key of the treasure and the value is the treasure itself.
	//
	// Real-world use-case:
	// Fetching all products for a product listing page.
	//
	// Example:
	//     swamp.BeginVigil()
	//     retrievedTreasures := swamp.GetAll()
	//     swamp.CeaseVigil()
	//
	//     if err != nil {
	//         log.Println("Failed to retrieve treasures:", err)
	//     } else {
	//         for _, treasure := range retrievedTreasures {
	//             ... // Do something with the treasure
	//         }
	//     }
	//
	// Returns:
	// - A map of key-value pairs representing the retrieved treasures.
	GetAll() map[string]treasure.Treasure

	// GetTreasuresByBeacon retrieves one or more "Treasures" from a "Swamp" based on a selected Beacon (index).
	//
	// This function allows you to query treasures from a Swamp using a Beacon, which is an index that helps in efficient retrieval.
	// If the specified Beacon doesn't exist, the method will dynamically create it during the first call. Beacons are designed
	// to be memory-efficient and exist in memory only when they are actively used, providing immediate access after the initial
	// "cold-start."
	//
	// Important Note: When working with a large dataset and using Beacons, it's advisable to keep the Swamp open for as long as
	// possible. Closing the Swamp will remove the Beacon from memory, necessitating a new "cold-start" during the next query.
	//
	// Parameters:
	// - beaconType (BeaconType): The type of Beacon to use for sorting treasures. It can be CreationTime, ExpirationTime, UpdateTime,
	//   ValueInt, or ValueFloat, depending on your requirements.
	// - beaconOrderType (BeaconOrder): The sorting order for the Beacon, which can be ascending (IndexOrderAsc) or descending (IndexOrderDesc).
	// - from (int): The starting position to begin retrieving treasures based on the Beacon.
	// - limit (int32): The maximum number of treasures to retrieve.
	// - delete (bool): If true, the retrieved treasures will be deleted from the Swamp after retrieval. If false,
	//   the treasures will remain in the Swamp.
	//
	// Real-world Examples:
	// - Example 1: In a stock trading application, you could use the `ValueFloat` Beacon to quickly retrieve stocks that have
	//   reached a certain price for immediate buying or selling actions.
	//
	//     swampName := name.Name("stock_swamp")
	//     beaconType := BeaconTypeValueFloat64
	//     beaconOrderType := IndexOrderDesc
	//     startingPosition := 0
	//     maxTreasuresToRetrieve := 10
	//     deleteRetrievedTreasures := false
	//
	//	   swampName.BeginVigil()
	//     retrievedStocks, err := swampName.GetTreasuresByBeacon(beaconType, beaconOrderType, startingPosition, maxTreasuresToRetrieve, deleteRetrievedTreasures)
	//     swampName.CeaseVigil()
	//
	//     if err != nil {
	//         log.Println("Error retrieving stocks:", err)
	//     }
	//
	//     // Process the retrieved stocks as needed.
	//     // ...
	//
	// - Example 2: In a content management system, you could use the `CreationTime` Beacon to fetch articles that were created
	//   within a certain time frame for auditing or analytics.
	//
	//     swampName := name.Name("content_swamp")
	//     beaconType := BeaconTypeCreationTime
	//     beaconOrderType := IndexOrderAsc
	//     startingPosition := 0
	//     maxTreasuresToRetrieve := 20
	//     deleteRetrievedTreasures := false
	//	   swampName.BeginVigil()
	//     retrievedArticles, err := swampName.GetTreasuresByBeacon(beaconType, beaconOrderType, startingPosition, maxTreasuresToRetrieve, deleteRetrievedTreasures)
	//     swampName.CeaseVigil()
	//     if err != nil {
	//         log.Println("Error retrieving articles:", err)
	//     }
	//
	//     // Process the retrieved articles as needed.
	//     // ...
	//
	// Returns:
	// ([]treasure.Treasure): A slice of retrieved treasures based on the specified Beacon and parameters.
	// (error): An error if any issues occur during the retrieval process.
	//
	// Use-cases:
	// 1. Efficient retrieval of treasures based on specific criteria using Beacons.
	// 2. Real-time data querying and processing for applications with dynamic data.
	GetTreasuresByBeacon(beaconType BeaconType, beaconOrderType BeaconOrder, from int32, limit int32) ([]treasure.Treasure, error)

	// CloneAndDeleteExpiredTreasures retrieves one or more expired Treasures from the Swamp based on their expiration
	// time and removes them. , Use this function carefully as it deletes the Treasures from the Swamp.
	//
	// Parameters:
	// - howMany (int32): The maximum number of expired Treasures to retrieve and remove from the Swamp.
	//
	// Real-world Examples:
	// - Example 1: Handling Time-Sensitive Tasks
	//   -----------------------------------------
	//   This function is particularly useful for handling tasks that can only be executed after a certain amount of time has passed.
	//   For instance, you could use this function to manage a queue of tasks that are time-sensitive.
	//   Once the time condition is met, the task can be safely and efficiently retrieved from the Swamp for execution.
	//
	//     howMany := int32(5) // Retrieve and remove up to 5 expired Treasures.
	//     yourSwamp.BeginVigil()
	//     expiredTasks, err := yourSwamp.CloneAndDeleteExpiredTreasures(howMany)
	//     yourSwamp.CeaseVigil()
	//     if err != nil {
	//         log.Println("Error retrieving and removing expired tasks:", err)
	//     }
	//
	//   // Process the retrieved and removed expired tasks.
	//   // ...
	//
	// - Example 2: Scheduled Email Sending in an Email Marketing Platform
	//   ---------------------------------------------------------------
	//   Imagine you are developing an email marketing platform where users can schedule emails to be sent at a specific time.
	//   You could use GetAndDeleteExpiredTreasures to store these scheduled emails in the Swamp with an ExpirationTime set to the time they should be sent.
	//   Once the ExpirationTime is reached, the email can be retrieved and sent automatically.
	//   This ensures that emails are sent exactly when they are supposed to, keeping your database organized and your operations efficient.
	//
	//     howMany := int32(10) // Retrieve and remove up to 10 expired emails.
	//     emailSwamp.BeginVigil()
	//     expiredEmails, err := emailSwamp.CloneAndDeleteExpiredTreasures(howMany)
	//     emailSwamp.CeaseVigil()
	//     if err != nil {
	//         log.Println("Error retrieving and removing expired emails:", err)
	//     }
	//
	//   // Send the retrieved and removed expired emails.
	//   // ...
	//
	// Returns:
	// ([]treasure.Treasure): A slice of retrieved and removed expired Treasures from the Swamp.
	// (error): An error if any issues occur during the retrieval and removal process. The error will be nil, if no
	//  expired Treasures are found.
	//
	// Use-cases:
	// 1. Handling time-sensitive tasks and actions that become valid or relevant after a certain amount of time has passed.
	// 2. Automating scheduled operations, such as sending emails or notifications, based on expiration times.
	CloneAndDeleteExpiredTreasures(howMany int32) ([]treasure.Treasure, error)

	// DeleteTreasure deletes a single "Treasure" from a "Swamp" by its unique key.
	//
	// Parameters:
	// - key (string): The unique key of the Treasure to be deleted from the Swamp.
	// - shadowDelete (bool): If true, the Treasure will be shadow-deleted, meaning it will be marked as deleted but not physically removed.
	//                        If false, the Treasure will be permanently deleted from the Swamp.
	//
	// Real-world use-case:
	// - Deleting a user account upon request. In scenarios where users request to delete their accounts, this function can be used
	//   to permanently remove the user's data (Treasure) from the Swamp.
	//
	// Example Usage:
	// ----------------
	// Suppose you have a Swamp named "user_data" where each Treasure represents user data.
	// When a user requests to delete their account, you can use DeleteTreasure to delete their data from the Swamp.
	//
	//     userKeyToDelete := "user123" // The unique key of the user to be deleted.
	//     userDataSwamp.BeginVigil()
	//     err := userDataSwamp.DeleteTreasure(userKeyToDelete, true) // the user account is shadow-deleted so that it can be recovered if needed.
	//     userDataSwamp.CeaseVigil()
	//     if err != nil {
	//         log.Println("Error deleting user data:", err)
	//     }
	//
	// Returns:
	// (error): An error if any issues occur during the deletion process.
	//
	// Use-cases:
	// 1. Securely deleting specific data entries, such as user accounts or records, from the Swamp.
	DeleteTreasure(key string, shadowDelete bool) error

	// CloneTreasures returns a clone of the main beaconKey map.
	//
	// Real-world use-case:
	// - This function is used when we want to copy the treasures from one swamp to another.
	//   It can be particularly useful for data synchronization or migration scenarios, where you need to duplicate
	//   the treasures stored in one Swamp and transfer them to another.
	//
	// Important! When you make any modifications to the cloned Treasures, they will not be reflected in the source
	// Treasure. Cloning creates completely new Treasure objects that have separate lives from the original Treasures.
	//
	// Example Usage:
	// ----------------
	// Suppose you have two Swamps, "sourceSwamp" and "destinationSwamp," and you want to copy treasures from the source Swamp to the destination Swamp.
	// You can use CloneTreasures to clone the treasures from the source Swamp and then add them to the destination Swamp.
	//
	//	   // Start a Vigil to prevent the Swamps from shutting down
	//     sourceSwamp.BeginVigil()
	//     destinationSwamp.BeginVigil()
	//
	//     sourceTreasures := sourceSwamp.CloneTreasures()
	//     for key, treasure := range sourceTreasures {
	//         destinationSwamp.SaveTreasure(treasure)
	//     }
	//
	// 	   // Release the Vigil. This is important to unlock the Swamps and allow them to shut down.
	//	   sourceSwamp.CeaseVigil()
	//     destinationSwamp.CeaseVigil()
	//
	//   // The treasures from the source Swamp are now duplicated in the destination Swamp.
	//
	// Returns:
	// (map[string]treasure.Treasure): A cloned map containing the treasures from the main beaconKey map.
	CloneTreasures() map[string]treasure.Treasure

	// GetName returns the name of the swamp.
	//
	// Real-world use-case:
	// - This function helps in identifying the swamp, especially useful when multiple swamps exist within the system.
	//
	// Example Usage:
	// ----------------
	// When you have multiple swamps in your system with different purposes or data, you can use GetName to retrieve
	// the name of a specific swamp for identification.
	//
	//     mySwamp.BeginVigil()
	//     swampName := mySwamp.GetName()
	//	   log.Println("Swamp name:", swampName)
	//	   mySwamp.CeaseVigil()
	//
	//   // Prints the name of the swamp to the console for identification.
	//
	// Returns:
	// (name.Name): The name of the swamp.
	GetName() name.Name

	// TreasureExists checks if the given key exists in the swamp.
	//
	// Parameters:
	// - key (string): The unique key to check for existence in the swamp.
	//
	// Real-world use-case:
	// - This function can be useful before attempting to bury a new treasure or unearth an existing one. You can use it to ensure
	//   that a key is available in the swamp before performing any operations on it.
	//
	// Example Usage:
	// ----------------
	// Before adding a new treasure with a specific key, you can use TreasureExists to check if that key already exists in the swamp.
	//
	//     keyToCheck := "unique_key"
	// 	   mySwamp.BeginVigil()
	//     exists := mySwamp.TreasureExists(keyToCheck)
	//     if exists {
	//         log.Println("Treasure with key", keyToCheck, "already exists in the swamp.")
	//     } else {
	//         // Proceed to bury the new treasure with the keyToCheck.
	//         // ...
	//     }
	//     mySwamp.CeaseVigil()
	//
	// Returns:
	// (bool): True if the key exists in the swamp, false otherwise.
	TreasureExists(key string) bool

	// CountTreasures returns the number of treasures in the swamp.
	//
	// Real-world use-case:
	// - This function can be useful for capacity planning or when you want to get information about the state of the swamp.
	//   It provides the total count of treasures currently stored in the swamp.
	//
	// Example Usage:
	// ----------------
	// If you want to monitor the size of your swamp or plan for potential scaling, you can use CountTreasures to retrieve
	// the current count of treasures.
	//
	//	   mySwamp.BeginVigil()
	//     numberOfTreasures := mySwamp.CountTreasures()
	//     log.Println("Total treasures in the swamp:", numberOfTreasures)
	//     mySwamp.CeaseVigil()
	//
	// Returns:
	// (int): The number of treasures in the swamp.
	CountTreasures() int

	// IsClosing returns true if the swamp is currently in the process of closing.
	//
	// Real-world use-case:
	// - This function can be useful for preventing new operations on a swamp that is in the process of closing.
	//   By checking the return value of IsClosing, you can avoid potential data loss or inconsistencies by
	//   ensuring that no new operations are initiated during the closing phase.
	//
	// Example Usage:
	// ----------------
	// You can use IsClosing to check whether the swamp is closing before performing certain operations.
	//
	//     if mySwamp.IsClosing() {
	//         // Handle the case when the swamp is in the process of closing.
	//     } else {
	//         // Perform normal operations on the swamp.
	//     }
	IsClosing() bool

	// Destroy locks the swamp for closing, sends the closing event, and destroys the swamp in the memory and the filesystem too.
	// It also stops the goroutines running inside the swamp.
	//
	// Real-world use-case:
	// - This function is useful if you want to permanently delete a swamp and all its data from the system.
	//
	// Important Note:
	// - It's important to note that you should call CeaseVigil() before invoking this function. Destroy relies on s.Vigil.WaitForActiveVigilsClosed()
	//   to wait for the Vigils to finish before proceeding with the closing process.
	// - In this special case, the Hydra Body will not send individual deletion events to the subscribers since the
	//   entire swamp is being destroyed. However, it will send the swamp info to the subscribers with a count of 0.
	//
	// Example Usage:
	// ----------------
	// When you need to close and destroy a swamp safely, you can call Destroy to ensure that all resources are properly released,
	// events are sent, and goroutines are terminated.
	//
	//     mySwamp.Destroy()
	Destroy()

	// All functions below can only be accessed by Hydra, not by Head --------------------------------------------------

	// WriteTreasuresToFilesystem prepares the swamp for removal from the Hydra's memory by writing its treasures to the filesystem.
	//
	// Real-world use-case:
	// - This function is crucial for data persistence and is typically invoked before shutting down a swamp or the Hydra itself.
	//   It ensures that the treasures stored in the swamp are safely written to the filesystem, allowing for data recovery
	//   and restoration in case of system restarts or crashes.
	//
	// Important:
	// - This function should not be used by the Hydra Head!!!
	//
	// Example Usage:
	// ----------------
	// Before shutting down the Hydra or a swamp, it's essential to call WriteTreasuresToFilesystem to save all treasures
	// to the filesystem for data persistence.
	//
	//     mySwamp.BeginVigil()
	//     mySwamp.WriteTreasuresToFilesystem()
	//     mySwamp.CeaseVigil()
	//
	//   // Treasures are now safely written to the filesystem.
	//
	// Notes:
	// - This function should be called to ensure that valuable data is not lost when the system is halted or restarted.
	WriteTreasuresToFilesystem()

	// GetChronicler returns the Chronicler interface associated with the swamp.
	//
	// Real-world use-case:
	// - The Chronicler is responsible for logging and tracking changes in the swamp, making this function essential for auditing and debugging.
	//   It also manages data persistence by writing swamp data to the filesystem and, if necessary, compressing it.
	//   Additionally, the Chronicler can retrieve data from the filesystem into memory, enabling efficient data loading.
	//
	// Example Usage:
	// ----------------
	// When you need to audit or debug the activities and changes in the swamp, you can use GetChronicler to obtain the
	// associated Chronicler interface.
	//
	//     swampChronicler := mySwamp.GetChronicler()
	//     // Now, you can use swampChronicler to write data to the filesystem, retrieve data from the filesystem, or write changes...
	//
	// Returns:
	// (chronicler.Chronicler): The Chronicler interface associated with the swamp.
	GetChronicler() chronicler.Chronicler

	// Close allows the Hydra to close the swamp safely.
	//
	// Real-world use-case:
	// - This function is crucial for the proper shutdown of a swamp. It ensures that all data is persisted to the filesystem,
	//   and resources are freed, allowing the swamp to gracefully exit.
	//   Additionally, SaveToFile waits for all Vigils to finish, indicating that any ongoing tasks or operations have completed.
	//   After closing, a closed event is sent to the Hydra Body to inform it about the swamp's closure.
	//   While the swamp's memory is released, it continues to exist in the filesystem, making it available for future use.
	//
	// Important Note:
	// - Close is a critical function for optimizing memory usage in the system, allowing it to retain only the necessary data.
	// - This function should NEVER be directly called by the Hydra Head, as the closure of a swamp depends on various factors
	//   monitored by the Hydra Body. The Hydra Body is responsible for coordinating and managing swamp closures, ensuring the
	//   proper execution of the process.
	// - IMPORTANT! Never run the mySwamp.BeginVigil() function before the Close function, as the closure won't complete.
	//   This is because the SaveToFile function relies on the WaitForActiveVigilsClosed() function.
	//
	// Example Usage:
	// ----------------
	// When you need to shut down a swamp safely, you can call Close to ensure that all data is saved, resources are freed,
	// and ongoing tasks are completed.
	//
	//     mySwamp.SaveToFile()
	//
	// Notes:
	// - Close is a critical function for optimizing memory usage in the system, allowing it to retain only the necessary data.
	Close()

	// StartSendingInformation enables the swamp to send information and events to the Hydra if there are any clients interested in receiving them.
	// This function is typically used to initiate real-time data streaming to clients who have subscribed to updates from this swamp.
	//
	// Real-world use-case:
	// - This function allows the swamp to begin sending information and events to the Hydra when there are clients interested in receiving them.
	// - It's a mechanism to conserve resources by only sending information when there are subscribers, avoiding unnecessary channel usage when there are none.
	//
	// Important Note:
	// - This function should NEVER be directly called by the Hydra Head!
	//
	// Example Usage:
	// ----------------
	// You can use StartSendingInformation when you want the swamp to start sending real-time updates to subscribed clients.
	//
	//     mySwamp.StartSendingInformation()
	StartSendingInformation()

	// StopSendingInformation disables the swamp from sending information to the Hydra.
	// This function is used to halt real-time data streaming to clients, usually when there are no more subscribers or when the swamp is about to be closed.
	//
	// Real-world use-case:
	// - Use this function to stop sending real-time updates and information to clients.
	// - It is typically invoked when there are no more subscribers or when the swamp is being closed to conserve resources.
	//
	// Important Note:
	// - This function should NEVER be directly called by the Hydra Head!
	//
	// Example Usage:
	// ----------------
	// You can use StopSendingInformation when you want to cease real-time updates being sent from the swamp to clients.
	//
	//     mySwamp.StopSendingInformation()
	StopSendingInformation()

	// StartSendingEvents enables the swamp to send events to the Hydra if there are any clients interested in receiving them.
	// This function is used to initiate event-based notifications to clients, providing real-time updates on changes within the swamp.
	//
	// Real-world use-case:
	// - Use this function to start sending real-time event notifications to clients who have subscribed to events from this swamp.
	//
	// Important Note:
	// - This function should NEVER be directly called by the Hydra Head!
	//
	// Example Usage:
	// ----------------
	// You can use StartSendingEvents when you want to initiate event-based notifications to clients about changes within the swamp.
	//
	//     mySwamp.StartSendingEvents()
	StartSendingEvents()

	// StopSendingEvents disables the swamp from sending events to the Hydra.
	// This function is used to stop event-based notifications to clients, usually when there are no more subscribers or when the swamp is about to be closed.
	//
	// Real-world use-case:
	// - Use this function to halt event-based notifications to clients when they are no longer interested or when the swamp is about to be closed.
	//
	// Important Note:
	// - This function should NEVER be directly called by the Hydra Head!
	//
	// Example Usage:
	// ----------------
	// You can use StopSendingEvents when you want to stop sending event notifications to clients, ensuring that no more event updates are sent.
	//
	//     mySwamp.StopSendingEvents()
	StopSendingEvents()

	// GetBeacon one beacon from the swamp by the beacon type and order.
	// This function useful if we want to iterate over the beacon and get the treasures from it
	GetBeacon(beaconType BeaconType, order BeaconOrder) beacon.Beacon

	IncrementUint8(key string, i uint8, condition *IncrementUInt8Condition) (newValue uint8, incremented bool, err error)
	IncrementUint16(key string, i uint16, condition *IncrementUInt16Condition) (newValue uint16, incremented bool, err error)
	IncrementUint32(key string, i uint32, condition *IncrementUInt32Condition) (newValue uint32, incremented bool, err error)
	IncrementUint64(key string, i uint64, condition *IncrementUInt64Condition) (newValue uint64, incremented bool, err error)

	IncrementInt8(key string, i int8, condition *IncrementInt8Condition) (newValue int8, incremented bool, err error)
	IncrementInt16(key string, i int16, condition *IncrementInt16Condition) (newValue int16, incremented bool, err error)
	IncrementInt32(key string, i int32, condition *IncrementInt32Condition) (newValue int32, incremented bool, err error)

	// IncrementInt64 increases or decreases the value associated with a given key based on a condition.
	//
	// Parameters:
	// - key: The key associated with the value to be modified.
	// - i: The value by which the current value should be incremented or decremented.
	// - condition: An optional condition that determines whether the operation can be performed.
	//              If the condition is not met, the function returns an error.
	//
	// Returns:
	// - newValue: The new value after incrementing or decrementing.
	// - incremented: A boolean indicating whether the value was incremented or not.
	// - err: An error if the condition is not met or if the existing value is not an integer.
	//
	// Operation:
	// 1. Retrieves the treasure object associated with the given key.
	// 2. Ensures that only one goroutine can access the treasure object at a time using a guard.
	// 3. Retrieves the existing value as an integer, returning an error if this fails.
	// 4. Checks the optionally provided condition:
	//    - If the condition is not met, returns an error and sets incremented to false.
	// 5. Increments or decrements the existing value by the provided amount.
	// 6. Sets the new value in the treasure object.
	// 7. Saves the treasure object.
	// 8. Returns the new value and a boolean indicating whether the value was incremented.
	//
	// Example:
	//
	// condition := &IncrementInt64Condition{
	//     RelationalOperator: RelationalOperatorEqual,
	//     Value:              100,
	// }
	// newValue, incremented, err := s.IncrementInt64("myKey", 10, condition)
	// if err != nil {
	//     log.Fatal(err)
	// }
	// fmt.Println("New Value:", newValue, "Incremented:", incremented)
	IncrementInt64(key string, i int64, condition *IncrementInt64Condition) (newValue int64, incremented bool, err error)

	IncrementFloat32(key string, f float32, condition *IncrementFloat32Condition) (newValue float32, incremented bool, err error)

	// IncrementFloat64 64 increases or decreases the value associated with a given key based on a condition.
	//
	// Parameters:
	// - key: The key associated with the value to be modified.
	// - f: The value by which the current value should be incremented or decremented.
	// - condition: An optional condition that determines whether the operation can be performed.
	//              If the condition is not met, the function returns an error.
	//
	// Returns:
	// - newValue: The new value after incrementing or decrementing.
	// - incremented: A boolean indicating whether the value was incremented or not.
	// - err: An error if the condition is not met or if the existing value is not a float.
	//
	// Operation:
	// 1. Retrieves the treasure object associated with the given key.
	// 2. Ensures that only one goroutine can access the treasure object at a time using a guard.
	// 3. Retrieves the existing value as a float, returning an error if this fails.
	// 4. Checks the optionally provided condition:
	//    - If the condition is not met, returns an error and sets incremented to false.
	// 5. Increments or decrements the existing value by the provided amount.
	// 6. Sets the new value in the treasure object.
	// 7. Saves the treasure object.
	// 8. Returns the new value and a boolean indicating whether the value was incremented.
	//
	// Example:
	//
	// condition := &IncrementFloat64Condition{
	//     RelationalOperator: RelationalOperatorEqual,
	//     Value:              100.0,
	// }
	// newValue, incremented, err := s.IncrementFloat64("myKey", 10.5, condition)
	// if err != nil {
	//     log.Fatal(err)
	// }
	// fmt.Println("New Value:", newValue, "Incremented:", incremented)
	IncrementFloat64(key string, f float64, condition *IncrementFloat64Condition) (newValue float64, incremented bool, err error)
}

const (
	ErrorTreasureDoesNotExists = "treasure does not exists"
)

// BeaconType is used to define the type of the Beacon.
type BeaconType int8

const (
	// BeaconTypeKey is used to sort Treasures in the Swamp based on their keys.
	// This type is suitable for Swamps where Treasures have unique keys.
	BeaconTypeKey BeaconType = iota
	// BeaconTypeCreationTime is used to sort Treasures in the Swamp based on CreationTime.
	// CreationTime is an int64 type timestamp. It's important to note that CreationTime is not unique;
	// multiple Treasures may have the same CreationTime. This type is only suitable for Swamps where Treasures have a CreationTime field.
	BeaconTypeCreationTime
	// BeaconTypeExpirationTime is used to sort Treasures in the Swamp based on ExpirationTime.
	// ExpirationTime is an int64 type timestamp. It's important to note that ExpirationTime is not unique;
	// multiple Treasures may have the same ExpirationTime. This type is only suitable for Swamps where Treasures have an ExpirationTime field.
	BeaconTypeExpirationTime
	// BeaconTypeUpdateTime is used to sort Treasures in the Swamp based on UpdateTime.
	// UpdateTime is an int64 type timestamp. It's important to note that UpdateTime is not unique;
	// multiple Treasures may have the same UpdateTime. This type is only suitable for Swamps where Treasures have an UpdateTime field.
	BeaconTypeUpdateTime
	BeaconTypeValueUint8
	BeaconTypeValueUint16
	BeaconTypeValueUint32
	BeaconTypeValueUint64
	BeaconTypeValueInt8
	BeaconTypeValueInt16
	BeaconTypeValueInt32
	// BeaconTypeValueInt64 represents sorting Treasures in the Swamp based on the content of ValueInt, not the key.
	// ValueInt is an int64 type value. It's important to note that ValueInt is not necessarily unique;
	// multiple Treasures may have the same ValueInt. This type is only suitable for Swamps where Treasures have a ValueInt field.
	BeaconTypeValueInt64

	BeaconTypeValueFloat32
	// BeaconTypeValueFloat64 represents sorting Treasures in the Swamp based on the content of ValueFloat, not the key.
	// ValueFloat is a float64 type value. It's important to note that ValueFloat is not necessarily unique;
	// multiple Treasures may have the same ValueFloat. This type is only suitable for Swamps where Treasures have a ValueFloat field.
	BeaconTypeValueFloat64
	// BeaconTypeValueString represents sorting Treasures in the Swamp based on the content of ValueString, not the key.
	// ValueString is a string type value. It's important to note that ValueString is not necessarily unique;
	// multiple Treasures may have the same ValueString. This type is only suitable for Swamps where Treasures have a ValueString field.
	BeaconTypeValueString
)

// BeaconOrder is used to define the sorting order for Beacons.
type BeaconOrder int

const (
	// IndexOrderAsc specifies ascending order for sorting Beacons.
	// It means sorting from the smallest value to the largest.
	IndexOrderAsc BeaconOrder = 1
	// IndexOrderDesc specifies descending order for sorting Beacons.
	// It means sorting from the largest value to the smallest.
	IndexOrderDesc BeaconOrder = 2
)

// Event represents an event that occurs in the Swamp, capturing changes to treasures and other relevant information.
//
// This structure is used to record and communicate events happening in the Swamp, such as the addition of a new treasure,
// modification of an existing treasure, or its deletion. It provides details about the event, including the swamp's name,
// the involved treasures (both new and modified/deleted), the event's timestamp, and the type of event that occurred.
//
// IMPORTANT: Events are automatically sent within the system, so the Head doesn't need to worry about sending the event. However,
// the Head can also subscribe to any event of any swamp, and upon subscription, it will receive this Event object.
//
// Fields:
//   - SwampName (name.Name): The name of the Swamp where the event occurred.
//   - Treasure (treasure.Treasure): The new treasure that was added to the Swamp. This field is relevant when the event
//     is related to adding a treasure.
//   - OldTreasure (treasure.Treasure): The treasure itself that was modified or deleted. This field is relevant when
//     the event is related to modifying or deleting a treasure.
//   - EventTime (int64): The time of the event in Unix time (milliseconds).
//   - StatusType (TreasureStatus): The type of the event that occurred, which can indicate whether it was a creation,
//     modification, deletion, or no change to a treasure.
//
// Use-cases:
// 1. Create a realtime chat application where users can see when other users join or leave the chat room or send messages.
// 1. Logging and tracking events in the Swamp.
// 2. Providing detailed information about changes to treasures and their timestamps.
type Event struct {
	SwampName       name.Name               // name of the swamp
	Treasure        treasure.Treasure       // the new treasure that is added to the swamp
	OldTreasure     treasure.Treasure       // the treasure itself that is modified or deleted
	DeletedTreasure treasure.Treasure       // the treasure that is deleted
	EventTime       int64                   // the time of the event in unix time (millisecond)
	StatusType      treasure.TreasureStatus // type of the event that is happened
}

// Info is a structure used to retrieve real-time information about a Swamp, specifically the count of treasures it contains.
//
// This structure allows subscribers to obtain the number of treasures within a given Swamp. Real-time counts of treasures
// can be useful in various scenarios, such as when building a dashboard to display the number of treasures in a Swamp.
//
// Fields:
// - SwampName (name.Name): The name of the Swamp for which the treasure count is being provided.
// - AllElements (uint64): The total number of treasures present in the Swamp represented by SwampName.
//
// Use-cases:
// 1. Real-time monitoring of the number of treasures within a Swamp.
// 2. Displaying treasure counts on dashboards or user interfaces.
type Info struct {
	SwampName   name.Name
	AllElements uint64
}

type swamp struct {
	mu              sync.RWMutex
	writerLock      sync.Mutex // mutex for the writer
	closeWriteMutex sync.Mutex // mutex for the closeWrite function
	closeMutex      sync.Mutex // mutex for the close function

	vigil.Vigil

	goRoutineContext           context.Context // context for the goroutines
	goRoutineCancelFunction    context.CancelFunc
	isInformationSendingActive int32 // if the swamp is sending information to the client
	isEventSendingActive       int32 // if the swamp is sending events to the client

	// -------------------  the following fields are used for setting up the swamp -------------------
	name name.Name // unique name of the swamp
	// -------------------  the following fields are used for the ordered lists -------------------
	// beaconKey is the main index of the swamp.
	// this is an ordered index by the creation time of the Treasures
	beaconKey beacon.Beacon // this is the main index of the swamp.

	closeAfterIdle      time.Duration // the minimum time that the swamp is in the memory
	lastInteractionTime int64         // the last time that the swamp is interacted with the client
	writeInterval       time.Duration // the interval that the swamp writes the Treasures to the chroniclerInterface

	// all beaconKey are sorted by the following fields
	keyBeaconASC             beacon.Beacon // ordered list of the Treasures by the ascendant BeaconKey field
	keyBeaconDESC            beacon.Beacon // ordered list of the Treasures by the descendant BeaconKey field
	expirationTimeBeaconASC  beacon.Beacon // ordered list of the Treasures by the ascendant ExpirationTime field
	expirationTimeBeaconDESC beacon.Beacon // ordered list of the Treasures by the descendant ExpirationTime field
	creationTimeBeaconASC    beacon.Beacon // ordered list of the Treasures by the ascendant CreatedAt field
	creationTimeBeaconDESC   beacon.Beacon // ordered list of the Treasures by the descendant CreatedAt field
	updateTimeBeaconASC      beacon.Beacon // ordered list of the Treasures by the ascendant UpdatedAt field
	updateTimeBeaconDESC     beacon.Beacon // ordered list of the Treasures by the descendant UpdatedAt field

	valueBeaconASC  beacon.Beacon // ordered list of the Treasures by the ascendant Value field
	valueBeaconDESC beacon.Beacon // ordered list of the Treasures by the descendant Value field

	// -------------------  the following fields are used for the unordered list -------------------
	// treasuresWaitingForWriter just the key of the treasures that are waiting for the writer to write them to the chroniclerInterface
	// because we need to check the existence of the treasure in the treasuresForWriter list
	treasuresWaitingForWriter beacon.Beacon

	chroniclerInterface chronicler.Chronicler // the chroniclerInterface that the swamp is using

	// -------------------  the following fields are used for the closing -------------------
	closing int32 // will be 1 if the swamp is closing

	isFilesystemWritingActive int32 // if the swamp is writing to the filesystem

	swampEventCallback func(event *Event) // the callback function that is called when an event is happened in the swamp
	swampInfoCallback  func(info *Info)   // the callback function that is called when the swamp info is requested
	swampCloseCallback func(n name.Name)  // the callback function that is called when the swamp is closed

	inMemorySwamp int32 // if the swamp is an in-memory swamp we don't write it to the filesystem

	metadataInterface metadata.Metadata // the metadata interface that the swamp is using
}

type FilesystemSettings struct {
	ChroniclerInterface chronicler.Chronicler
	WriteInterval       time.Duration
}

// New creates a new swamp object
func New(name name.Name, closeAfterIdle time.Duration, filesystemSettings *FilesystemSettings,
	swampEventCallback func(event *Event), swampInfoCallback func(info *Info), swampCloseCallback func(n name.Name),
	metadataInterface metadata.Metadata) Swamp {

	s := &swamp{
		name:                name,
		lastInteractionTime: time.Now().UnixNano(),
		Vigil:               vigil.New(),
		swampEventCallback:  swampEventCallback,
		swampInfoCallback:   swampInfoCallback,
		swampCloseCallback:  swampCloseCallback,
		closeAfterIdle:      closeAfterIdle,
		metadataInterface:   metadataInterface,
	}

	/// IMPORTANT the w.expirationTimeBeaconASC will be nil if orderType is unordered!!!!
	s.beaconKey = beacon.New()

	if filesystemSettings == nil {
		// the swamp is an IN-Memory swamp
		atomic.StoreInt32(&s.inMemorySwamp, 1)
	} else {
		// the swamp is permanent swamp. The data will be written to the filesystem and loaded from the filesystem
		s.writeInterval = filesystemSettings.WriteInterval
		atomic.StoreInt32(&s.inMemorySwamp, 0)
		s.chroniclerInterface = filesystemSettings.ChroniclerInterface
		// regisztráljuk a chroniclerInterface-be azt a funkciót, amit a chronicler akkor hív meg, amikor
		// filepointer eseemény történik, azaz a chronicler vissza akarja küldeni, hogy melyik Treasure-nak mi lett
		// a filepointer-e
		s.chroniclerInterface.RegisterFilePointerFunction(s.FilePointerCallbackFunction)
		// load the swamp from the chroniclerInterface while the swamp is created
		s.chroniclerInterface.RegisterSaveFunction(s.SaveFunction)
		// The swamp is Permanent-Type so we need to load the data from the filesystem
		s.chroniclerInterface.Load(s.beaconKey)
	}

	s.goRoutineContext, s.goRoutineCancelFunction = context.WithCancel(context.Background())

	s.keyBeaconASC = beacon.New()
	s.keyBeaconASC.SetIsOrdered(true)
	s.keyBeaconDESC = beacon.New()
	s.keyBeaconDESC.SetIsOrdered(true)

	s.expirationTimeBeaconASC = beacon.New()
	s.expirationTimeBeaconASC.SetIsOrdered(true)
	s.expirationTimeBeaconDESC = beacon.New()
	s.expirationTimeBeaconDESC.SetIsOrdered(true)

	s.creationTimeBeaconASC = beacon.New()
	s.creationTimeBeaconASC.SetIsOrdered(true)
	s.creationTimeBeaconDESC = beacon.New()
	s.creationTimeBeaconDESC.SetIsOrdered(true)

	s.updateTimeBeaconASC = beacon.New()
	s.updateTimeBeaconASC.SetIsOrdered(true)
	s.updateTimeBeaconDESC = beacon.New()
	s.updateTimeBeaconDESC.SetIsOrdered(true)

	s.valueBeaconASC = beacon.New()
	s.valueBeaconASC.SetIsOrdered(true)
	s.valueBeaconDESC = beacon.New()
	s.valueBeaconDESC.SetIsOrdered(true)

	// create beacon for the treasuresWaitingForWriter
	s.treasuresWaitingForWriter = beacon.New()
	// the treasuresWaitingForWriter is not ordered, because the ordering is not important here
	s.treasuresWaitingForWriter.SetIsOrdered(false)

	// Initiates monitoring of swamp write, close, and new filename events.
	// Do not start the autow-riter if the writeInterval is 0 because it means the swamp is a simple in-memory swamp or
	// we want to flush the data to the filesystem immediately.
	if atomic.LoadInt32(&s.inMemorySwamp) == 0 && s.writeInterval > 0 {
		go s.startWriteListener()
	}

	go s.startCloseListener()

	return s

}

func (s *swamp) GetMetadata() metadata.Metadata {
	return s.metadataInterface
}

type IncrementUInt8Condition struct {
	RelationalOperator RelationalOperator
	Value              uint8
}
type IncrementUInt16Condition struct {
	RelationalOperator RelationalOperator
	Value              uint16
}
type IncrementUInt32Condition struct {
	RelationalOperator RelationalOperator
	Value              uint32
}
type IncrementUInt64Condition struct {
	RelationalOperator RelationalOperator
	Value              uint64
}
type IncrementInt8Condition struct {
	RelationalOperator RelationalOperator
	Value              int8
}
type IncrementInt16Condition struct {
	RelationalOperator RelationalOperator
	Value              int16
}
type IncrementInt32Condition struct {
	RelationalOperator RelationalOperator
	Value              int32
}

type IncrementInt64Condition struct {
	RelationalOperator RelationalOperator
	Value              int64
}

type RelationalOperator int

const (
	RelationalOperatorEqual              RelationalOperator = 1
	RelationalOperatorNotEqual           RelationalOperator = 2
	RelationalOperatorGreaterThan        RelationalOperator = 3
	RelationalOperatorGreaterThanOrEqual RelationalOperator = 4
	RelationalOperatorLessThan           RelationalOperator = 5
	RelationalOperatorLessThanOrEqual    RelationalOperator = 6
)

func (s *swamp) IncrementUint8(key string, i uint8, condition *IncrementUInt8Condition) (newValue uint8, incremented bool, err error) {
	// get the key treasure by its key
	treasureObj := s.beaconKey.Get(key)
	// ha a treasure nem létezik még, akkor létrehozzuk azt
	if treasureObj == nil {
		// a treasure még nem létezett, így létrehozzuk azt
		func() {
			treasureObj = s.CreateTreasure(key)
			guardID := treasureObj.StartTreasureGuard(true)
			defer treasureObj.ReleaseTreasureGuard(guardID)
			treasureObj.SetContentUint8(guardID, 0)
		}()

	} else {
		// ha a treasure létezett, már, akkor ellenőrizzük a tartalom típusát
		contentType := treasureObj.GetContentType()
		// ha nem integer volt benne eddig, akkor hibát dobunk
		if contentType != treasure.ContentTypeUint8 {
			return 0, false, errors.New(ErrorValueIsNotInt)
		}
	}

	// biztosítjuk, hogy a treasure-hoz egyszerre csak egy goroutine férjen hozzá
	guardID := treasureObj.StartTreasureGuard(true, guard.BodyAuthID)
	defer treasureObj.ReleaseTreasureGuard(guardID)

	// lekérdezzük a jelenlegi integer értékét a treasure-nek
	contentInt, err := treasureObj.GetContentUint8()
	if err != nil {
		return 0, false, errors.New(ErrorValueIsNotInt)
	}

	// ellenőrizzük a feltételt, ha van megadva
	if condition != nil {
		switch condition.RelationalOperator {
		case RelationalOperatorEqual:
			if contentInt != condition.Value {
				return contentInt, false, nil
			}
		case RelationalOperatorNotEqual:
			if contentInt == condition.Value {
				return contentInt, false, nil
			}
		case RelationalOperatorGreaterThan:
			if contentInt <= condition.Value {
				return contentInt, false, nil
			}
		case RelationalOperatorGreaterThanOrEqual:
			if contentInt < condition.Value {
				return contentInt, false, nil
			}
		case RelationalOperatorLessThan:
			if contentInt >= condition.Value {
				return contentInt, false, nil
			}
		case RelationalOperatorLessThanOrEqual:
			if contentInt > condition.Value {
				return contentInt, false, nil
			}
		}
	}

	// increment or decrement the value
	contentInt += i
	// beállítjuk az új értéket
	treasureObj.SetContentUint8(guardID, contentInt)
	// elmentjük a treasure-t
	treasureObj.Save(guardID)

	// visszaadjuk az új értéket és hogy incrementálva lett-e
	return contentInt, true, nil
}
func (s *swamp) IncrementUint16(key string, i uint16, condition *IncrementUInt16Condition) (newValue uint16, incremented bool, err error) {
	// get the key treasure by its key
	treasureObj := s.beaconKey.Get(key)
	// ha a treasure nem létezik még, akkor létrehozzuk azt
	if treasureObj == nil {
		// a treasure még nem létezett, így létrehozzuk azt
		func() {
			treasureObj = s.CreateTreasure(key)
			guardID := treasureObj.StartTreasureGuard(true)
			defer treasureObj.ReleaseTreasureGuard(guardID)
			treasureObj.SetContentUint16(guardID, 0)
		}()

	} else {
		// ha a treasure létezett, már, akkor ellenőrizzük a tartalom típusát
		contentType := treasureObj.GetContentType()
		// ha nem integer volt benne eddig, akkor hibát dobunk
		if contentType != treasure.ContentTypeUint16 {
			return 0, false, errors.New(ErrorValueIsNotInt)
		}
	}

	// biztosítjuk, hogy a treasure-hoz egyszerre csak egy goroutine férjen hozzá
	guardID := treasureObj.StartTreasureGuard(true, guard.BodyAuthID)
	defer treasureObj.ReleaseTreasureGuard(guardID)

	// lekérdezzük a jelenlegi integer értékét a treasure-nek
	contentInt, err := treasureObj.GetContentUint16()
	if err != nil {
		return 0, false, errors.New(ErrorValueIsNotInt)
	}

	// ellenőrizzük a feltételt, ha van megadva
	if condition != nil {
		switch condition.RelationalOperator {
		case RelationalOperatorEqual:
			if contentInt != condition.Value {
				return contentInt, false, nil
			}
		case RelationalOperatorNotEqual:
			if contentInt == condition.Value {
				return contentInt, false, nil
			}
		case RelationalOperatorGreaterThan:
			if contentInt <= condition.Value {
				return contentInt, false, nil
			}
		case RelationalOperatorGreaterThanOrEqual:
			if contentInt < condition.Value {
				return contentInt, false, nil
			}
		case RelationalOperatorLessThan:
			if contentInt >= condition.Value {
				return contentInt, false, nil
			}
		case RelationalOperatorLessThanOrEqual:
			if contentInt > condition.Value {
				return contentInt, false, nil
			}
		}
	}

	// increment or decrement the value
	contentInt += i
	// beállítjuk az új értéket
	treasureObj.SetContentUint16(guardID, contentInt)
	// elmentjük a treasure-t
	treasureObj.Save(guardID)

	// visszaadjuk az új értéket és hogy incrementálva lett-e
	return contentInt, true, nil
}
func (s *swamp) IncrementUint32(key string, i uint32, condition *IncrementUInt32Condition) (newValue uint32, incremented bool, err error) {
	// get the key treasure by its key
	treasureObj := s.beaconKey.Get(key)
	// ha a treasure nem létezik még, akkor létrehozzuk azt
	if treasureObj == nil {
		// a treasure még nem létezett, így létrehozzuk azt
		func() {
			treasureObj = s.CreateTreasure(key)
			guardID := treasureObj.StartTreasureGuard(true)
			defer treasureObj.ReleaseTreasureGuard(guardID)
			treasureObj.SetContentUint32(guardID, 0)
		}()

	} else {
		// ha a treasure létezett, már, akkor ellenőrizzük a tartalom típusát
		contentType := treasureObj.GetContentType()
		// ha nem integer volt benne eddig, akkor hibát dobunk
		if contentType != treasure.ContentTypeUint32 {
			return 0, false, errors.New(ErrorValueIsNotInt)
		}
	}

	// biztosítjuk, hogy a treasure-hoz egyszerre csak egy goroutine férjen hozzá
	guardID := treasureObj.StartTreasureGuard(true, guard.BodyAuthID)
	defer treasureObj.ReleaseTreasureGuard(guardID)

	// lekérdezzük a jelenlegi integer értékét a treasure-nek
	contentInt, err := treasureObj.GetContentUint32()
	if err != nil {
		return 0, false, errors.New(ErrorValueIsNotInt)
	}

	// ellenőrizzük a feltételt, ha van megadva
	if condition != nil {
		switch condition.RelationalOperator {
		case RelationalOperatorEqual:
			if contentInt != condition.Value {
				return contentInt, false, nil
			}
		case RelationalOperatorNotEqual:
			if contentInt == condition.Value {
				return contentInt, false, nil
			}
		case RelationalOperatorGreaterThan:
			if contentInt <= condition.Value {
				return contentInt, false, nil
			}
		case RelationalOperatorGreaterThanOrEqual:
			if contentInt < condition.Value {
				return contentInt, false, nil
			}
		case RelationalOperatorLessThan:
			if contentInt >= condition.Value {
				return contentInt, false, nil
			}
		case RelationalOperatorLessThanOrEqual:
			if contentInt > condition.Value {
				return contentInt, false, nil
			}
		}
	}

	// increment or decrement the value
	contentInt += i
	// beállítjuk az új értéket
	treasureObj.SetContentUint32(guardID, contentInt)
	// elmentjük a treasure-t
	treasureObj.Save(guardID)

	// visszaadjuk az új értéket és hogy incrementálva lett-e
	return contentInt, true, nil
}
func (s *swamp) IncrementUint64(key string, i uint64, condition *IncrementUInt64Condition) (newValue uint64, incremented bool, err error) {
	// get the key treasure by its key
	treasureObj := s.beaconKey.Get(key)
	// ha a treasure nem létezik még, akkor létrehozzuk azt
	if treasureObj == nil {
		// a treasure még nem létezett, így létrehozzuk azt
		func() {
			treasureObj = s.CreateTreasure(key)
			guardID := treasureObj.StartTreasureGuard(true)
			defer treasureObj.ReleaseTreasureGuard(guardID)
			treasureObj.SetContentUint64(guardID, 0)
		}()

	} else {
		// ha a treasure létezett, már, akkor ellenőrizzük a tartalom típusát
		contentType := treasureObj.GetContentType()
		// ha nem integer volt benne eddig, akkor hibát dobunk
		if contentType != treasure.ContentTypeUint64 {
			return 0, false, errors.New(ErrorValueIsNotInt)
		}
	}

	// biztosítjuk, hogy a treasure-hoz egyszerre csak egy goroutine férjen hozzá
	guardID := treasureObj.StartTreasureGuard(true, guard.BodyAuthID)
	defer treasureObj.ReleaseTreasureGuard(guardID)

	// lekérdezzük a jelenlegi integer értékét a treasure-nek
	contentInt, err := treasureObj.GetContentUint64()
	if err != nil {
		return 0, false, errors.New(ErrorValueIsNotInt)
	}

	// ellenőrizzük a feltételt, ha van megadva
	if condition != nil {
		switch condition.RelationalOperator {
		case RelationalOperatorEqual:
			if contentInt != condition.Value {
				return contentInt, false, nil
			}
		case RelationalOperatorNotEqual:
			if contentInt == condition.Value {
				return contentInt, false, nil
			}
		case RelationalOperatorGreaterThan:
			if contentInt <= condition.Value {
				return contentInt, false, nil
			}
		case RelationalOperatorGreaterThanOrEqual:
			if contentInt < condition.Value {
				return contentInt, false, nil
			}
		case RelationalOperatorLessThan:
			if contentInt >= condition.Value {
				return contentInt, false, nil
			}
		case RelationalOperatorLessThanOrEqual:
			if contentInt > condition.Value {
				return contentInt, false, nil
			}
		}
	}

	// increment or decrement the value
	contentInt += i
	// beállítjuk az új értéket
	treasureObj.SetContentUint64(guardID, contentInt)
	// elmentjük a treasure-t
	treasureObj.Save(guardID)

	// visszaadjuk az új értéket és hogy incrementálva lett-e
	return contentInt, true, nil
}
func (s *swamp) IncrementInt8(key string, i int8, condition *IncrementInt8Condition) (newValue int8, incremented bool, err error) {
	// get the key treasure by its key
	treasureObj := s.beaconKey.Get(key)
	// ha a treasure nem létezik még, akkor létrehozzuk azt
	if treasureObj == nil {
		// a treasure még nem létezett, így létrehozzuk azt
		func() {
			treasureObj = s.CreateTreasure(key)
			guardID := treasureObj.StartTreasureGuard(true)
			defer treasureObj.ReleaseTreasureGuard(guardID)
			treasureObj.SetContentInt8(guardID, 0)
		}()

	} else {
		// ha a treasure létezett, már, akkor ellenőrizzük a tartalom típusát
		contentType := treasureObj.GetContentType()
		// ha nem integer volt benne eddig, akkor hibát dobunk
		if contentType != treasure.ContentTypeInt8 {
			return 0, false, errors.New(ErrorValueIsNotInt)
		}
	}

	// biztosítjuk, hogy a treasure-hoz egyszerre csak egy goroutine férjen hozzá
	guardID := treasureObj.StartTreasureGuard(true, guard.BodyAuthID)
	defer treasureObj.ReleaseTreasureGuard(guardID)

	// lekérdezzük a jelenlegi integer értékét a treasure-nek
	contentInt, err := treasureObj.GetContentInt8()
	if err != nil {
		return 0, false, errors.New(ErrorValueIsNotInt)
	}

	// ellenőrizzük a feltételt, ha van megadva
	if condition != nil {
		switch condition.RelationalOperator {
		case RelationalOperatorEqual:
			if contentInt != condition.Value {
				return contentInt, false, nil
			}
		case RelationalOperatorNotEqual:
			if contentInt == condition.Value {
				return contentInt, false, nil
			}
		case RelationalOperatorGreaterThan:
			if contentInt <= condition.Value {
				return contentInt, false, nil
			}
		case RelationalOperatorGreaterThanOrEqual:
			if contentInt < condition.Value {
				return contentInt, false, nil
			}
		case RelationalOperatorLessThan:
			if contentInt >= condition.Value {
				return contentInt, false, nil
			}
		case RelationalOperatorLessThanOrEqual:
			if contentInt > condition.Value {
				return contentInt, false, nil
			}
		}
	}

	// increment or decrement the value
	contentInt += i
	// beállítjuk az új értéket
	treasureObj.SetContentInt8(guardID, contentInt)
	// elmentjük a treasure-t
	treasureObj.Save(guardID)

	// visszaadjuk az új értéket és hogy incrementálva lett-e
	return contentInt, true, nil
}
func (s *swamp) IncrementInt16(key string, i int16, condition *IncrementInt16Condition) (newValue int16, incremented bool, err error) {
	// get the key treasure by its key
	treasureObj := s.beaconKey.Get(key)
	// ha a treasure nem létezik még, akkor létrehozzuk azt
	if treasureObj == nil {
		// a treasure még nem létezett, így létrehozzuk azt
		func() {
			treasureObj = s.CreateTreasure(key)
			guardID := treasureObj.StartTreasureGuard(true)
			defer treasureObj.ReleaseTreasureGuard(guardID)
			treasureObj.SetContentInt16(guardID, 0)
		}()

	} else {
		// ha a treasure létezett, már, akkor ellenőrizzük a tartalom típusát
		contentType := treasureObj.GetContentType()
		// ha nem integer volt benne eddig, akkor hibát dobunk
		if contentType != treasure.ContentTypeInt16 {
			return 0, false, errors.New(ErrorValueIsNotInt)
		}
	}

	// biztosítjuk, hogy a treasure-hoz egyszerre csak egy goroutine férjen hozzá
	guardID := treasureObj.StartTreasureGuard(true, guard.BodyAuthID)
	defer treasureObj.ReleaseTreasureGuard(guardID)

	// lekérdezzük a jelenlegi integer értékét a treasure-nek
	contentInt, err := treasureObj.GetContentInt16()
	if err != nil {
		return 0, false, errors.New(ErrorValueIsNotInt)
	}

	// ellenőrizzük a feltételt, ha van megadva
	if condition != nil {
		switch condition.RelationalOperator {
		case RelationalOperatorEqual:
			if contentInt != condition.Value {
				return contentInt, false, nil
			}
		case RelationalOperatorNotEqual:
			if contentInt == condition.Value {
				return contentInt, false, nil
			}
		case RelationalOperatorGreaterThan:
			if contentInt <= condition.Value {
				return contentInt, false, nil
			}
		case RelationalOperatorGreaterThanOrEqual:
			if contentInt < condition.Value {
				return contentInt, false, nil
			}
		case RelationalOperatorLessThan:
			if contentInt >= condition.Value {
				return contentInt, false, nil
			}
		case RelationalOperatorLessThanOrEqual:
			if contentInt > condition.Value {
				return contentInt, false, nil
			}
		}
	}

	// increment or decrement the value
	contentInt += i
	// beállítjuk az új értéket
	treasureObj.SetContentInt16(guardID, contentInt)
	// elmentjük a treasure-t
	treasureObj.Save(guardID)

	// visszaadjuk az új értéket és hogy incrementálva lett-e
	return contentInt, true, nil
}
func (s *swamp) IncrementInt32(key string, i int32, condition *IncrementInt32Condition) (newValue int32, incremented bool, err error) {
	// get the key treasure by its key
	treasureObj := s.beaconKey.Get(key)
	// ha a treasure nem létezik még, akkor létrehozzuk azt
	if treasureObj == nil {
		// a treasure még nem létezett, így létrehozzuk azt
		func() {
			treasureObj = s.CreateTreasure(key)
			guardID := treasureObj.StartTreasureGuard(true)
			defer treasureObj.ReleaseTreasureGuard(guardID)
			treasureObj.SetContentInt32(guardID, 0)
		}()

	} else {
		// ha a treasure létezett, már, akkor ellenőrizzük a tartalom típusát
		contentType := treasureObj.GetContentType()
		// ha nem integer volt benne eddig, akkor hibát dobunk
		if contentType != treasure.ContentTypeInt32 {
			return 0, false, errors.New(ErrorValueIsNotInt)
		}
	}

	// biztosítjuk, hogy a treasure-hoz egyszerre csak egy goroutine férjen hozzá
	guardID := treasureObj.StartTreasureGuard(true, guard.BodyAuthID)
	defer treasureObj.ReleaseTreasureGuard(guardID)

	// lekérdezzük a jelenlegi integer értékét a treasure-nek
	contentInt, err := treasureObj.GetContentInt32()
	if err != nil {
		return 0, false, errors.New(ErrorValueIsNotInt)
	}

	// ellenőrizzük a feltételt, ha van megadva
	if condition != nil {
		switch condition.RelationalOperator {
		case RelationalOperatorEqual:
			if contentInt != condition.Value {
				return contentInt, false, nil
			}
		case RelationalOperatorNotEqual:
			if contentInt == condition.Value {
				return contentInt, false, nil
			}
		case RelationalOperatorGreaterThan:
			if contentInt <= condition.Value {
				return contentInt, false, nil
			}
		case RelationalOperatorGreaterThanOrEqual:
			if contentInt < condition.Value {
				return contentInt, false, nil
			}
		case RelationalOperatorLessThan:
			if contentInt >= condition.Value {
				return contentInt, false, nil
			}
		case RelationalOperatorLessThanOrEqual:
			if contentInt > condition.Value {
				return contentInt, false, nil
			}
		}
	}

	// increment or decrement the value
	contentInt += i
	// beállítjuk az új értéket
	treasureObj.SetContentInt32(guardID, contentInt)
	// elmentjük a treasure-t
	treasureObj.Save(guardID)

	// visszaadjuk az új értéket és hogy incrementálva lett-e
	return contentInt, true, nil
}

func (s *swamp) IncrementInt64(key string, i int64, condition *IncrementInt64Condition) (newValue int64, incremented bool, err error) {

	// get the key treasure by its key
	treasureObj := s.beaconKey.Get(key)
	// ha a treasure nem létezik még, akkor létrehozzuk azt
	if treasureObj == nil {
		// a treasure még nem létezett, így létrehozzuk azt
		func() {
			treasureObj = s.CreateTreasure(key)
			guardID := treasureObj.StartTreasureGuard(true)
			defer treasureObj.ReleaseTreasureGuard(guardID)
			treasureObj.SetContentInt64(guardID, 0)
		}()

	} else {
		// ha a treasure létezett, már, akkor ellenőrizzük a tartalom típusát
		contentType := treasureObj.GetContentType()
		// ha nem integer volt benne eddig, akkor hibát dobunk
		if contentType != treasure.ContentTypeInt64 {
			return 0, false, errors.New(ErrorValueIsNotInt)
		}
	}

	// biztosítjuk, hogy a treasure-hoz egyszerre csak egy goroutine férjen hozzá
	guardID := treasureObj.StartTreasureGuard(true, guard.BodyAuthID)
	defer treasureObj.ReleaseTreasureGuard(guardID)

	// lekérdezzük a jelenlegi integer értékét a treasure-nek
	contentInt, err := treasureObj.GetContentInt64()
	if err != nil {
		return 0, false, errors.New(ErrorValueIsNotInt)
	}

	// ellenőrizzük a feltételt, ha van megadva
	if condition != nil {
		switch condition.RelationalOperator {
		case RelationalOperatorEqual:
			if contentInt != condition.Value {
				return contentInt, false, nil
			}
		case RelationalOperatorNotEqual:
			if contentInt == condition.Value {
				return contentInt, false, nil
			}
		case RelationalOperatorGreaterThan:
			if contentInt <= condition.Value {
				return contentInt, false, nil
			}
		case RelationalOperatorGreaterThanOrEqual:
			if contentInt < condition.Value {
				return contentInt, false, nil
			}
		case RelationalOperatorLessThan:
			if contentInt >= condition.Value {
				return contentInt, false, nil
			}
		case RelationalOperatorLessThanOrEqual:
			if contentInt > condition.Value {
				return contentInt, false, nil
			}
		}
	}

	// increment or decrement the value
	contentInt += i
	// beállítjuk az új értéket
	treasureObj.SetContentInt64(guardID, contentInt)
	// elmentjük a treasure-t
	treasureObj.Save(guardID)

	// visszaadjuk az új értéket és hogy incrementálva lett-e
	return contentInt, true, nil

}

type IncrementFloat32Condition struct {
	RelationalOperator RelationalOperator
	Value              float32
}

type IncrementFloat64Condition struct {
	RelationalOperator RelationalOperator
	Value              float64
}

func (s *swamp) IncrementFloat32(key string, f float32, condition *IncrementFloat32Condition) (newValue float32, incremented bool, err error) {

	// get the key treasure by its key
	treasureObj := s.beaconKey.Get(key)
	// ha a treasure nem létezik még, akkor létrehozzuk azt
	if treasureObj == nil {
		// a treasure még nem létezett, így létrehozzuk azt
		func() {
			treasureObj = s.CreateTreasure(key)
			guardID := treasureObj.StartTreasureGuard(true)
			defer treasureObj.ReleaseTreasureGuard(guardID)
			treasureObj.SetContentFloat32(guardID, 0)
		}()

	} else {
		// ha a treasure létezett, már, akkor ellenőrizzük a tartalom típusát
		contentType := treasureObj.GetContentType()
		// ha nem float volt benne eddig, akkor hibát dobunk
		if contentType != treasure.ContentTypeFloat32 {
			return 0, false, errors.New(ErrorValueIsNotFloat)
		}
	}

	// ensure that only one goroutine can access the treasure object at a time
	guardID := treasureObj.StartTreasureGuard(true, guard.BodyAuthID)
	defer treasureObj.ReleaseTreasureGuard(guardID)

	// get the float value and return an error if it fails
	contentFloat, err := treasureObj.GetContentFloat32()
	if err != nil {
		return 0, false, errors.New(ErrorValueIsNotFloat)
	}

	// check the condition if provided
	if condition != nil {
		switch condition.RelationalOperator {
		case RelationalOperatorEqual:
			if contentFloat != condition.Value {
				return contentFloat, false, nil
			}
		case RelationalOperatorNotEqual:
			if contentFloat == condition.Value {
				return contentFloat, false, nil
			}
		case RelationalOperatorGreaterThan:
			if contentFloat <= condition.Value {
				return contentFloat, false, nil
			}
		case RelationalOperatorGreaterThanOrEqual:
			if contentFloat < condition.Value {
				return contentFloat, false, nil
			}
		case RelationalOperatorLessThan:
			if contentFloat >= condition.Value {
				return contentFloat, false, nil
			}
		case RelationalOperatorLessThanOrEqual:
			if contentFloat > condition.Value {
				return contentFloat, false, nil
			}
		}
	}

	// increment or decrement the value
	contentFloat += f

	// set the new value
	treasureObj.SetContentFloat32(guardID, contentFloat)
	// save the treasure object
	treasureObj.Save(guardID)

	// return the new value and whether it was incremented
	return contentFloat, true, nil
}

func (s *swamp) IncrementFloat64(key string, f float64, condition *IncrementFloat64Condition) (newValue float64, incremented bool, err error) {

	// get the key treasure by its key
	treasureObj := s.beaconKey.Get(key)
	// ha a treasure nem létezik még, akkor létrehozzuk azt
	if treasureObj == nil {
		// a treasure még nem létezett, így létrehozzuk azt
		func() {
			treasureObj = s.CreateTreasure(key)
			guardID := treasureObj.StartTreasureGuard(true)
			defer treasureObj.ReleaseTreasureGuard(guardID)
			treasureObj.SetContentFloat64(guardID, 0)
		}()

	} else {
		// ha a treasure létezett, már, akkor ellenőrizzük a tartalom típusát
		contentType := treasureObj.GetContentType()
		// ha nem float volt benne eddig, akkor hibát dobunk
		if contentType != treasure.ContentTypeFloat64 {
			return 0, false, errors.New(ErrorValueIsNotFloat)
		}
	}

	// ensure that only one goroutine can access the treasure object at a time
	guardID := treasureObj.StartTreasureGuard(true, guard.BodyAuthID)
	defer treasureObj.ReleaseTreasureGuard(guardID)

	// get the float value and return an error if it fails
	contentFloat, err := treasureObj.GetContentFloat64()
	if err != nil {
		return 0, false, errors.New(ErrorValueIsNotFloat)
	}

	// check the condition if provided
	if condition != nil {
		switch condition.RelationalOperator {
		case RelationalOperatorEqual:
			if contentFloat != condition.Value {
				return contentFloat, false, nil
			}
		case RelationalOperatorNotEqual:
			if contentFloat == condition.Value {
				return contentFloat, false, nil
			}
		case RelationalOperatorGreaterThan:
			if contentFloat <= condition.Value {
				return contentFloat, false, nil
			}
		case RelationalOperatorGreaterThanOrEqual:
			if contentFloat < condition.Value {
				return contentFloat, false, nil
			}
		case RelationalOperatorLessThan:
			if contentFloat >= condition.Value {
				return contentFloat, false, nil
			}
		case RelationalOperatorLessThanOrEqual:
			if contentFloat > condition.Value {
				return contentFloat, false, nil
			}
		}
	}

	// increment or decrement the value
	contentFloat += f

	// set the new value
	treasureObj.SetContentFloat64(guardID, contentFloat)
	// save the treasure object
	treasureObj.Save(guardID)

	// return the new value and whether it was incremented
	return contentFloat, true, nil
}

func (s *swamp) GetBeacon(beaconType BeaconType, order BeaconOrder) beacon.Beacon {

	switch beaconType {
	case BeaconTypeCreationTime:
		s.buildBeacon(s.creationTimeBeaconASC, s.creationTimeBeaconDESC, BeaconTypeCreationTime)
		if order == IndexOrderAsc {
			return s.creationTimeBeaconASC
		}
		return s.creationTimeBeaconDESC
	case BeaconTypeExpirationTime:
		s.buildBeacon(s.expirationTimeBeaconASC, s.expirationTimeBeaconDESC, BeaconTypeExpirationTime)
		if order == IndexOrderAsc {
			return s.expirationTimeBeaconASC
		}
		return s.expirationTimeBeaconDESC
	case BeaconTypeUpdateTime:
		s.buildBeacon(s.updateTimeBeaconASC, s.updateTimeBeaconDESC, BeaconTypeUpdateTime)
		if order == IndexOrderAsc {
			return s.updateTimeBeaconASC
		}
		return s.updateTimeBeaconDESC
	case BeaconTypeValueInt64, BeaconTypeValueFloat64, BeaconTypeValueString:
		s.buildBeacon(s.valueBeaconASC, s.valueBeaconDESC, BeaconTypeValueInt64)
		if order == IndexOrderAsc {
			return s.valueBeaconASC
		}
		return s.valueBeaconDESC
	case BeaconTypeKey:
		s.buildBeacon(s.keyBeaconASC, s.keyBeaconDESC, BeaconTypeKey)
		if order == IndexOrderAsc {
			return s.keyBeaconASC
		}
		return s.keyBeaconDESC
	default:
		return nil
	}

}

// WaitForGracefulClose this is a blocker function. Any thread can call this function to wait for the treasure to
// be successfully closed. This function will return nil if the treasure is successfully closed. Otherwise, it will
// return an error.
func (s *swamp) WaitForGracefulClose(ctx context.Context) error {

	// if the swamp is not closing yet, we can not wait for the swamp to be closed
	if atomic.LoadInt32(&s.closing) == 0 {
		return errors.New("swamp is not closing yet")
	}

	for {
		select {
		case <-ctx.Done():
			// tha main context is done, we can not wait for the swamp to be closed
			return errors.New("context is done")
		case <-s.goRoutineContext.Done():
			// the swamp is closed successfully
			return nil
		}
	}

}

// CountTreasuresWaitingForWriter returns the number of treasures that are waiting for the writer to write them to the chroniclerInterface
func (s *swamp) CountTreasuresWaitingForWriter() int {
	return s.treasuresWaitingForWriter.Count()
}

// CreateTreasure creates a new Treasure object if it is not existing in the swamp or returns with the existing one.
func (s *swamp) CreateTreasure(key string) treasure.Treasure {

	// return with the original treasure if it is existing
	// this working like the Load function
	if treasureObj := s.beaconKey.Get(key); treasureObj != nil {
		// return with the original treasure
		return treasureObj
	}

	t := treasure.New(s.SaveFunction)
	guardID := t.StartTreasureGuard(true, guard.BodyAuthID)
	t.BodySetKey(guardID, key)
	t.ReleaseTreasureGuard(guardID)

	return t
}

func (s *swamp) SaveFunction(t treasure.Treasure, guardID guard.ID) treasure.TreasureStatus {

	// set the last interaction time to the current time
	atomic.StoreInt64(&s.lastInteractionTime, time.Now().UnixNano())

	existedTreasureObj := s.beaconKey.Get(t.GetKey())
	// we must add the treasure to the treasuresWaitingForWriter index if it is not exists in the swamp
	// because this is means that the treasure is not written to the chroniclerInterface yet
	// and the treasure is totally new
	if existedTreasureObj == nil {

		// add the treasure to the treasuresWaitingForWriter index
		s.treasuresWaitingForWriter.Add(t)

		// add treasure to the beaconKey index
		s.beaconKey.Add(t)
		// add treasure to all other beacons if needed
		s.addTreasureToBeacons(t)
		s.sendEventToHydra(t, nil, treasure.StatusNew)
		s.sendSwampInfo()

		// immediately write the treasure to the chroniclerInterface if the write interval is 0
		s.mu.RLock()
		wi := s.writeInterval
		inMem := s.inMemorySwamp
		s.mu.RUnlock()
		if wi == 0 && inMem == 0 {
			// treasure lock feloldása hogy a kírás azonnal történjen
			t.ReleaseTreasureGuard(guardID)
			// write the treasure to the chroniclerInterface
			s.fileWriterHandler(false)
		}

		// beállítjuk az utolsó módosítás dátumát a metában
		s.metadataInterface.SetUpdatedAt()
		// return with statusNew
		return treasure.StatusNew

	}

	// if the treasure is existing in the swamp, we need to check if it is modified or not
	if t.IsContentChanged() || t.IsContentTypeChanged() || t.IsExpirationTimeChanged() ||
		t.IsCreatedAtChanged() || t.IsCreatedByChanged() || t.IsDeletedAtChanged() ||
		t.IsDeletedByChanged() || t.IsModifiedAtChanged() || t.IsModifiedByChanged() {

		// if the content type changed...
		if t.IsContentTypeChanged() {
			// delete the treasure from the beacons
			s.deleteTreasureFromBeacons(t.GetKey())
			// add the treasure back to the beacons if the content type is not void
			if t.GetContentType() != treasure.ContentTypeVoid {
				s.addTreasureToBeacons(t)
			}
		}

		// the treasure is modified, we need to add it to the swamp and write it to the chroniclerInterface
		s.treasuresWaitingForWriter.Add(t)

		// send the event to the hydra
		s.sendEventToHydra(t, existedTreasureObj, treasure.StatusModified)

		// immediately write the treasure to the chroniclerInterface if the write interval is 0
		s.mu.RLock()
		wi := s.writeInterval
		inMem := s.inMemorySwamp
		s.mu.RUnlock()
		if wi == 0 && inMem == 0 {
			// treasure lock feloldása hogy a kírás azonnal történjen
			t.ReleaseTreasureGuard(guardID)
			// write the treasure to the chroniclerInterface
			s.fileWriterHandler(false)
		}

		// beállítjuk az utolsó módosítás dátumát a metában
		s.metadataInterface.SetUpdatedAt()
		// return with statusModified
		return treasure.StatusModified

	}

	// nothing changed, we don't need to send events to the hydra
	return treasure.StatusSame

}

// Close closes the swamp (write all waiting treasures to the chroniclerInterface) and stops all goroutines inside the swamp
// Sends the stop event to the manager at the end of the function
// The manager uses this function to close the swamp only if there is a gracefulStop signal
// DO NOT ADD TRANSACTION IF YOU CALL THIS FUNCTION, because the swamp can not be closed until the last transaction is released
func (s *swamp) Close() {

	s.closeMutex.Lock()
	if atomic.LoadInt32(&s.closing) == 1 {
		// the swamp is already closing
		s.closeMutex.Unlock()
		return
	}
	// set closing to 1 immediately to prevent other transactions to be created on the swamp
	atomic.StoreInt32(&s.closing, 1)
	s.closeMutex.Unlock()

	// write all treasures to the chroniclerInterface that are waiting for the writer and don't send events to the hydra
	// because we are closing the swamp and ask the chroniclerInterface to not send file pointers for new files, because,
	// we are closing the swamp and we don't need to write the file pointers to the treasures
	if atomic.LoadInt32(&s.inMemorySwamp) == 0 {
		s.chroniclerInterface.DontSendFilePointer()
		// write files to the filesystem that are waiting for the writer
		s.fileWriterHandler(true)
		// save metadata to the filesystem if there is any changes
		s.metadataInterface.SaveToFile()
	}

	// megvárjuk a bezárás előtt, hogy a chronicler minden adatot kiírjon a filerendszerbe, különben lehet olyan, hogy
	// újra megnyitják a swampot és még nem tud mindent beolvasni, mert még nem írta ki a chroniclerInterface a filerendszerbe
	// az adatokat. Így fontos, hogy a chroniclerInterface minden adatot kiírjon a filerendszerbe, mielőtt a swamp bezáródik

	// close internal routines because we are closing the swamp and we don't need to listen for new events or write ticker
	s.goRoutineCancelFunction()

	// send the closed event to the hydra
	s.sendClosedEvent()

	return

}

// sendClosedEvent sends a signal to the Manager because the swamp is successfully closed itself
func (s *swamp) sendClosedEvent() {
	s.swampCloseCallback(s.name)
}

// Destroy destroys all treasures in the chroniclerInterface, and all its treasures and stops all goroutines inside the swamp
// DO NOT ADD TRANSACTION IF YOU CALL THIS FUNCTION, because the swamp can not be closed until the last transaction is released
// !!!!!!!! IMPORTANT: YOU NEED TO RELEASE THE TRANSACTION BEFORE CALLING THIS FUNCTION, BECAUSE THIS FUNCTION
// WAITS FOR ALL TRANSACTIONS TO BE RELEASED
func (s *swamp) Destroy() {

	atomic.StoreInt32(&s.closing, 1)

	s.mu.Lock()
	defer s.mu.Unlock()

	s.StopSendingInformation()
	s.StopSendingEvents()

	s.Vigil.WaitForActiveVigilsClosed()

	// stops all goroutines inside the swamp
	s.goRoutineCancelFunction()

	// destroy the chroniclerInterface
	if atomic.LoadInt32(&s.inMemorySwamp) == 0 {
		// ez a filesystem-en keresztül törli a swampot és a meta filet is egyben
		s.chroniclerInterface.Destroy()
	}

	// send the closed event to the ManagerInterface that will delete the swamp from the map
	s.sendClosedEvent()

	return

}

// IsClosing returns true if the swamp is closing
// using atomic function, because the atomic functions is much faster than the mutex
// Ez a funkció egyben meg is hosszabbítja a swamp lastInteractionTime mezőjét is, ami miatt a swamp nem fog bezáródni
// azonnal, így biztonsággal kiadható még a BeginVigil() utasítás is, valamint a swampot lekérdező funkciók is
// biztonsággal használhatóak
func (s *swamp) IsClosing() bool {
	// set the last interaction time to the current time
	atomic.StoreInt64(&s.lastInteractionTime, time.Now().UnixNano())
	return atomic.LoadInt32(&s.closing) == 1
}

// GetName get the name of the swamp
func (s *swamp) GetName() name.Name {
	// set the last interaction time to the current time
	atomic.StoreInt64(&s.lastInteractionTime, time.Now().UnixNano())
	s.mu.RLock()
	defer s.mu.RUnlock()
	return s.name
}

// GetChronicler returns the chroniclerInterface of the swamp
func (s *swamp) GetChronicler() chronicler.Chronicler {
	// set the last interaction time to the current time
	atomic.StoreInt64(&s.lastInteractionTime, time.Now().UnixNano())
	return s.chroniclerInterface
}

// StartSendingInformation is a function that starts sending information about the swamp to the client if the client is subscribed to it
func (s *swamp) StartSendingInformation() {
	// set the last interaction time to the current time
	atomic.StoreInt64(&s.lastInteractionTime, time.Now().UnixNano())
	atomic.StoreInt32(&s.isInformationSendingActive, 1)
}

// StopSendingInformation is a function that stops sending information about the swamp to the client if the client is unsubscribed from it
func (s *swamp) StopSendingInformation() {
	// set the last interaction time to the current time
	atomic.StoreInt64(&s.lastInteractionTime, time.Now().UnixNano())
	atomic.StoreInt32(&s.isInformationSendingActive, 0)
}

// StartSendingEvents is a function that starts sending events about the swamp to the client if the client is subscribed to it
func (s *swamp) StartSendingEvents() {
	// set the last interaction time to the current time
	atomic.StoreInt64(&s.lastInteractionTime, time.Now().UnixNano())
	atomic.StoreInt32(&s.isEventSendingActive, 1)
}

// StopSendingEvents is a function that stops sending events about the swamp to the client if the client is unsubscribed from it
func (s *swamp) StopSendingEvents() {
	// set the last interaction time to the current time
	atomic.StoreInt64(&s.lastInteractionTime, time.Now().UnixNano())
	atomic.StoreInt32(&s.isEventSendingActive, 0)
}

// GetTreasuresByBeacon can get and delete treasures from indexes
func (s *swamp) GetTreasuresByBeacon(beaconType BeaconType, beaconOrderType BeaconOrder, from int32, limit int32) ([]treasure.Treasure, error) {

	// set the last interaction time to the current time
	atomic.StoreInt64(&s.lastInteractionTime, time.Now().UnixNano())

	// if the limit 0 its means that we need to get all treasures from the beacon from, the "from" parameter
	if limit == 0 {
		// get the element count of the beacon
		limit = int32(s.beaconKey.Count())
	}

	var selectedTreasures []treasure.Treasure
	var err error
	switch beaconType {
	case BeaconTypeKey:
		selectedTreasures, err = s.findInKeyBeacon(beaconOrderType, from, limit)
	case BeaconTypeExpirationTime:
		selectedTreasures, err = s.findInExpirationTimeBeacon(beaconOrderType, from, limit)
	case BeaconTypeCreationTime:
		selectedTreasures, err = s.findInCreationTimeBeacon(beaconOrderType, from, limit)
	case BeaconTypeUpdateTime:
		selectedTreasures, err = s.findInUpdateTimeBeacon(beaconOrderType, from, limit)
	default:
		// find in value-based beacons
		selectedTreasures, err = s.findInValueBeacon(beaconOrderType, beaconType, from, limit)
	}

	if err != nil {
		return nil, err
	}

	var returningTreasures []treasure.Treasure
	for _, d := range selectedTreasures {
		returningTreasures = append(returningTreasures, d)
	}

	return returningTreasures, nil

}

// CloneTreasures returns a clone of the swamp object with all beacons and treasures
func (s *swamp) CloneTreasures() map[string]treasure.Treasure {
	// set the last interaction time to the current time
	atomic.StoreInt64(&s.lastInteractionTime, time.Now().UnixNano())
	return s.beaconKey.CloneUnorderedTreasures(false)
}

// GetTreasure Retrieves a single "Treasure" from a "Swamp" by its unique key.
// Real-world use-case: Fetching a specific user's details for profile display.
func (s *swamp) GetTreasure(key string) (treasure treasure.Treasure, err error) {
	// set the last interaction time to the current time
	atomic.StoreInt64(&s.lastInteractionTime, time.Now().UnixNano())
	if treasureObj := s.beaconKey.Get(key); treasureObj != nil {
		// return with the original treasure
		return treasureObj, nil
	}
	return nil, errors.New(ErrorTreasureDoesNotExists)
}

// GetAll Retrieves all "Treasures" from a "Swamp".
func (s *swamp) GetAll() map[string]treasure.Treasure {
	// set the last interaction time to the current time
	atomic.StoreInt64(&s.lastInteractionTime, time.Now().UnixNano())
	if s.beaconKey.Count() == 0 {
		return nil
	}
	return s.beaconKey.GetAll()
}

// CountTreasures Returns the number of treasures in the swamp.
// This function can be useful for capacity planning or when you want to get information about the state of the swamp.
func (s *swamp) CountTreasures() int {
	// set the last interaction time to the current time
	atomic.StoreInt64(&s.lastInteractionTime, time.Now().UnixNano())
	return s.beaconKey.Count()
}

// DeleteTreasure Deletes a single "Treasure" from a "Swamp" by its unique key.
// Real-world use-case: Deleting a user account upon request.
// shadowDelete is a flag that indicates whether the treasure should be deleted from the chroniclerInterface too
// if the shadowDelete is true, then the treasure will be flagged as deleted and it will not be deleted from the chroniclerInterface
// if the shadowDelete is false, then the treasure will be deleted from the chroniclerInterface too
func (s *swamp) DeleteTreasure(key string, shadowDelete bool) error {

	// set the last interaction time to the current time
	atomic.StoreInt64(&s.lastInteractionTime, time.Now().UnixNano())
	if !s.beaconKey.IsExists(key) {
		return errors.New(ErrorTreasureDoesNotExists)
	}

	// delete the treasure from the beaconKey
	// delete the treasure from the swamp and from the chroniclerInterface too
	s.deleteHandler(key, shadowDelete)

	// destroy the swamp if there is no treasure in it
	if s.beaconKey.Count() == 0 {
		// feloldjuk a vigiliát, mert nincs több treasure a swampban és a Destroy megkövetelei a Vigil feloldását
		s.CeaseVigil()
		s.Destroy()
		return nil
	}

	return nil

}

// CloneAndDeleteExpiredTreasures retrieves one or more expired Treasures from the Swamp based on their expiration time and removes them.
// Use this function carefully as it deletes the Treasures from the Swamp.
func (s *swamp) CloneAndDeleteExpiredTreasures(howMany int32) ([]treasure.Treasure, error) {

	// set the last interaction time to the current time
	atomic.StoreInt64(&s.lastInteractionTime, time.Now().UnixNano())

	// build the expirationTimeIndex if it is not built yet
	s.buildBeacon(s.expirationTimeBeaconASC, s.expirationTimeBeaconDESC, BeaconTypeExpirationTime)

	// shift the expired treasures from the swamp
	shiftedTreasures := s.expirationTimeBeaconASC.ShiftExpired(int(howMany))

	// delete the shifted treasures from the other indexes
	for _, d := range shiftedTreasures {
		// delete the treasure from the beaconKey
		// A lejárt treasureok esetében mindig valódi törlést végzünk és nem csak "törölt" flaggel jelöljük meg a treasuret
		s.deleteHandler(d.GetKey(), false)
	}

	// return with the shifted treasures
	return shiftedTreasures, nil
}

// TreasureExists Checks if the given key exists in the swamp.
// This function can be useful before attempting to bury a new treasure or unearth an existing one.
func (s *swamp) TreasureExists(key string) bool {
	// set the last interaction time to the current time
	atomic.StoreInt64(&s.lastInteractionTime, time.Now().UnixNano())
	return s.beaconKey.IsExists(key)
}

// WriteTreasuresToFilesystem writes all new, modified or deleted treasures to the filesystem by the chroniclerInterface
func (s *swamp) WriteTreasuresToFilesystem() {
	// set the last interaction time to the current time
	atomic.StoreInt64(&s.lastInteractionTime, time.Now().UnixNano())
	if atomic.LoadInt32(&s.inMemorySwamp) == 0 {
		s.fileWriterHandler(false)
	}
}

// fileWriterHandler writes all new, modified or deleted treasures to the chroniclerInterface
// and sets the writeActive to 0 when it is finished and empty the treasuresWaitingForWriter slice
// ONLY ONE fileWriterHandler can be active at the same time to prevent the concurrent loader writes to the chroniclerInterface
func (s *swamp) fileWriterHandler(isCloseWrite bool) {

	// ha nem zárási esemény miatt akarjuk a kiírást megvalósítani
	if !isCloseWrite {

		func() {
			s.writerLock.Lock()
			defer s.writerLock.Unlock()
			if atomic.LoadInt32(&s.isFilesystemWritingActive) == 1 {
				return
			}
			atomic.StoreInt32(&s.isFilesystemWritingActive, 1)
		}()

		// feloldjuk az írási lockot mert még nem kell zárjuk a swampot
		defer atomic.StoreInt32(&s.isFilesystemWritingActive, 0)

	} else {

		// ha zárási esemény miatt akarjuk a kiírást megvalósítani
		// akkor elég, ha csak beállítjuk az aktív írást, 1-re, mert később
		// már nem lesz szükség rá.
		atomic.StoreInt32(&s.isFilesystemWritingActive, 1)

	}

	// if there is no treasures waiting for write, then return
	if s.treasuresWaitingForWriter.Count() == 0 {
		return
	}

	var treasuresToWrite []treasure.Treasure
	s.treasuresWaitingForWriter.Iterate(func(t treasure.Treasure) bool {
		treasuresToWrite = append(treasuresToWrite, t)
		return true
	}, beacon.IterationTypeKey)

	// delete the treasures from the swamp and from the chroniclerInterface too
	for _, t := range treasuresToWrite {
		// delete the treasure from the treasuresWaitingForWriter index
		s.treasuresWaitingForWriter.Delete(t.GetKey())
	}

	// A Write funkció megvárja ameddig az előző write befejezi a munkáját, így nem kell
	// külön szinkronizálni a két írási folyamatot
	s.chroniclerInterface.Write(treasuresToWrite)

}

// Info returns detailed information about the swamp
func (s *swamp) sendSwampInfo() {
	if atomic.LoadInt32(&s.isInformationSendingActive) == 0 {
		return
	}

	message := &Info{
		SwampName:   s.GetName(),
		AllElements: uint64(s.beaconKey.Count()),
	}

	s.swampInfoCallback(message)

}

// deleteHandler deletes the treasure from the swamp
func (s *swamp) deleteHandler(key string, shadowDelete bool) (deletedTreasure treasure.Treasure) {

	// clone the treasure itself to the clonedTreasure
	treasureObj := s.beaconKey.Get(key)
	if treasureObj == nil {
		return nil
	}

	guardID := treasureObj.StartTreasureGuard(true, guard.BodyAuthID)
	defer treasureObj.ReleaseTreasureGuard(guardID)

	// Még változtatás előtt lemásoljuk a Treasure-t, hogy egy clone-t készíthessünk róla, hogy a törölt treasure-t minden
	// adatával együtt vissza tudjuk adni.
	clonedTreasure := treasureObj.Clone(guardID)

	// remove the treasure from the treasuresWaitingForWriter slice if the treasure does not have a loader pointer
	// because it is meaning the treasure is not saved yet to the chroniclerInterface, but it is deleted from the swamp
	if treasureObj.GetFileName() == nil {
		// delete the treasure from the treasuresWaitingForWriter index
		s.treasuresWaitingForWriter.Delete(key)
	} else {
		// set the treasure for deletion
		// todo: itt meg kell oldani, hogy a törlésnél legyen kérhető a shadow delete is.
		treasureObj.BodySetForDeletion(guardID, "", shadowDelete)
		s.treasuresWaitingForWriter.Add(treasureObj)
		// beállítjuk az utolsó módosítás dátumát a metában
		s.metadataInterface.SetUpdatedAt()
	}

	// delete the treasure from the beaconKey after cloned the treasure
	s.beaconKey.Delete(key)
	// delete the treasure from all active indexes
	s.deleteTreasureFromBeacons(key)

	// send the deleted event_channel_handler to the neen
	s.sendDeletedEventToClient(clonedTreasure)
	s.sendSwampInfo()

	return treasureObj

}

// sendDeletedEventToClient sends the deleted event_channel_handler to the Hydra
func (s *swamp) sendDeletedEventToClient(d treasure.Treasure) {

	if atomic.LoadInt32(&s.isEventSendingActive) == 0 {
		return
	}

	e := &Event{
		SwampName:       s.GetName(),
		Treasure:        nil,
		OldTreasure:     nil,
		DeletedTreasure: d,
		EventTime:       time.Now().UTC().UnixNano(),
		StatusType:      treasure.StatusDeleted,
	}

	s.swampEventCallback(e)

}

// addTreasureToBeacons - add treasures to all the indexes
func (s *swamp) addTreasureToBeacons(d treasure.Treasure) {

	// try to add the treasure to the keyBeacon
	s.addToKeyBeacon(d)
	if d.GetCreatedAt() != 0 {
		s.addToCreationTimeBeacon(d)
	}
	if d.GetModifiedAt() != 0 {
		s.addToUpdateTimeBeacon(d)
	}
	if d.GetExpirationTime() != 0 {
		s.addToExpirationTimeBeacon(d)
	}

	// value beacon
	s.addToValueBeacon(d)

}

// deleteTreasureFromBeacons - delete the treasure from all beacons if the treasure is exists in the beacon
func (s *swamp) deleteTreasureFromBeacons(key string) {
	// delete the key from the beacon only if the beacon is initialized
	s.deleteTreasureIfBeaconInitialized(s.keyBeaconASC, key)
	s.deleteTreasureIfBeaconInitialized(s.keyBeaconDESC, key)
	s.deleteTreasureIfBeaconInitialized(s.creationTimeBeaconASC, key)
	s.deleteTreasureIfBeaconInitialized(s.creationTimeBeaconDESC, key)
	s.deleteTreasureIfBeaconInitialized(s.updateTimeBeaconASC, key)
	s.deleteTreasureIfBeaconInitialized(s.updateTimeBeaconDESC, key)
	s.deleteTreasureIfBeaconInitialized(s.expirationTimeBeaconASC, key)
	s.deleteTreasureIfBeaconInitialized(s.expirationTimeBeaconDESC, key)
	s.deleteTreasureIfBeaconInitialized(s.valueBeaconASC, key)
	s.deleteTreasureIfBeaconInitialized(s.valueBeaconDESC, key)

}

// deleteTreasureIfBeaconInitialized - delete the key from the beacon only if the beacon is initialized
func (s *swamp) deleteTreasureIfBeaconInitialized(b beacon.Beacon, key string) {
	if b.IsInitialized() {
		b.Delete(key)
	}
}

// findInCreationTimeBeacon - find the treasures in the creationTimeBeaconASC or creationTimeBeaconDESC slice
// Build the two indexes if they are not exists or the indexes are empty
func (s *swamp) findInCreationTimeBeacon(order BeaconOrder, from int32, limit int32) ([]treasure.Treasure, error) {
	s.buildBeacon(s.creationTimeBeaconASC, s.creationTimeBeaconDESC, BeaconTypeCreationTime)
	switch order {
	case IndexOrderAsc:
		return s.creationTimeBeaconASC.GetManyFromOrderPosition(int(from), int(limit))
	case IndexOrderDesc:
		return s.creationTimeBeaconDESC.GetManyFromOrderPosition(int(from), int(limit))
	default:
		return nil, errors.New("invalid order")
	}
}

// findInUpdateTimeBeacon - find the treasures in the updateTimeBeaconASC or updateTimeBeaconDESC slice
// Build the two indexes if they are not exists or the indexes are empty
func (s *swamp) findInUpdateTimeBeacon(order BeaconOrder, from int32, limit int32) ([]treasure.Treasure, error) {
	s.buildBeacon(s.updateTimeBeaconASC, s.updateTimeBeaconDESC, BeaconTypeUpdateTime)
	switch order {
	case IndexOrderAsc:
		return s.updateTimeBeaconASC.GetManyFromOrderPosition(int(from), int(limit))
	case IndexOrderDesc:
		return s.updateTimeBeaconDESC.GetManyFromOrderPosition(int(from), int(limit))
	default:
		return nil, errors.New("invalid order")
	}
}

// findInKeyBeacon - find the treasures in the keyBeaconASC or keyBeaconDESC slice
// Build the two indexes if they are not exists or the indexes are empty
func (s *swamp) findInKeyBeacon(order BeaconOrder, from int32, limit int32) ([]treasure.Treasure, error) {
	s.buildBeacon(s.keyBeaconASC, s.keyBeaconDESC, BeaconTypeKey)
	switch order {
	case IndexOrderAsc:
		return s.keyBeaconASC.GetManyFromOrderPosition(int(from), int(limit))
	case IndexOrderDesc:
		return s.keyBeaconDESC.GetManyFromOrderPosition(int(from), int(limit))
	default:
		return nil, errors.New("invalid order")
	}
}

// findInExpirationTimeBeacon - find the treasures in the expirationTimeBeaconASC or expirationTimeBeaconDESC slice
// Build the two indexes if they are not exists or the indexes are empty
func (s *swamp) findInExpirationTimeBeacon(order BeaconOrder, from int32, limit int32) ([]treasure.Treasure, error) {
	s.buildBeacon(s.expirationTimeBeaconASC, s.expirationTimeBeaconDESC, BeaconTypeExpirationTime)
	switch order {
	case IndexOrderAsc:
		return s.expirationTimeBeaconASC.GetManyFromOrderPosition(int(from), int(limit))
	case IndexOrderDesc:
		return s.expirationTimeBeaconDESC.GetManyFromOrderPosition(int(from), int(limit))
	default:
		return nil, errors.New("invalid order")
	}
}

// findInValueBeacon - find the treasures in the valueIntBeaconASC or valueIntBeaconDESC slice
// Build the two indexes if they are not exists or the indexes are empty
func (s *swamp) findInValueBeacon(order BeaconOrder, bc BeaconType, from int32, limit int32) ([]treasure.Treasure, error) {
	s.buildBeacon(s.valueBeaconASC, s.valueBeaconDESC, bc)
	switch order {
	case IndexOrderAsc:
		return s.valueBeaconASC.GetManyFromOrderPosition(int(from), int(limit))
	case IndexOrderDesc:
		return s.valueBeaconDESC.GetManyFromOrderPosition(int(from), int(limit))
	default:
		return nil, errors.New("invalid order")
	}
}

// -- helper functions for beacons -----------------------------------------------------
// ------------------------------------------------------------------------------------
func (s *swamp) buildBeacon(beaconASC beacon.Beacon, beaconDESC beacon.Beacon, bc BeaconType) {

	// build the index only if it is not initialized
	if beaconASC.IsInitialized() && beaconASC.IsInitialized() {
		return
	}

	if !beaconASC.IsInitialized() {
		beaconASC.SetInitialized(true)
		beaconASC.PushManyFromMap(s.beaconKey.GetAll())
		var err error
		switch bc {
		case BeaconTypeCreationTime:
			err = beaconASC.SortByCreationTimeAsc()
		case BeaconTypeUpdateTime:
			err = beaconASC.SortByUpdateTimeAsc()
		case BeaconTypeExpirationTime:
			err = beaconASC.SortByExpirationTimeAsc()
		case BeaconTypeValueUint8:
			err = beaconASC.SortByValueUint8ASC()
		case BeaconTypeValueUint16:
			err = beaconASC.SortByValueUint16ASC()
		case BeaconTypeValueUint32:
			err = beaconASC.SortByValueUint32ASC()
		case BeaconTypeValueUint64:
			err = beaconASC.SortByValueUint64ASC()
		case BeaconTypeValueInt8:
			err = beaconASC.SortByValueInt8ASC()
		case BeaconTypeValueInt16:
			err = beaconASC.SortByValueInt16ASC()
		case BeaconTypeValueInt32:
			err = beaconASC.SortByValueInt32ASC()
		case BeaconTypeValueInt64:
			err = beaconASC.SortByValueInt64ASC()
		case BeaconTypeValueFloat32:
			err = beaconASC.SortByValueFloat32ASC()
		case BeaconTypeValueFloat64:
			err = beaconASC.SortByValueFloat64ASC()
		case BeaconTypeValueString:
			err = beaconASC.SortByValueStringASC()
		case BeaconTypeKey:
			err = beaconASC.SortByKeyAsc()
		default:
			err = beaconASC.SortByKeyAsc()
		}
		if err != nil {
			beaconASC.SetInitialized(false)
			slog.Error("failed to sort keyBeaconASC", "error", err)
		}
	}

	if !beaconDESC.IsInitialized() {
		beaconDESC.SetInitialized(true)
		beaconDESC.PushManyFromMap(s.beaconKey.GetAll())
		var err error
		switch bc {
		case BeaconTypeCreationTime:
			err = beaconDESC.SortByCreationTimeDesc()
		case BeaconTypeUpdateTime:
			err = beaconDESC.SortByUpdateTimeDesc()
		case BeaconTypeExpirationTime:
			err = beaconDESC.SortByExpirationTimeDesc()
		case BeaconTypeValueUint8:
			err = beaconDESC.SortByValueUint8DESC()
		case BeaconTypeValueUint16:
			err = beaconDESC.SortByValueUint16DESC()
		case BeaconTypeValueUint32:
			err = beaconDESC.SortByValueUint32DESC()
		case BeaconTypeValueUint64:
			err = beaconDESC.SortByValueUint64DESC()
		case BeaconTypeValueInt8:
			err = beaconDESC.SortByValueInt8DESC()
		case BeaconTypeValueInt16:
			err = beaconDESC.SortByValueInt16DESC()
		case BeaconTypeValueInt32:
			err = beaconDESC.SortByValueInt32DESC()
		case BeaconTypeValueInt64:
			err = beaconDESC.SortByValueInt64DESC()
		case BeaconTypeValueFloat32:
			err = beaconDESC.SortByValueFloat32DESC()
		case BeaconTypeValueFloat64:
			err = beaconDESC.SortByValueFloat64DESC()
		case BeaconTypeValueString:
			err = beaconDESC.SortByValueStringDESC()
		case BeaconTypeKey:
			err = beaconDESC.SortByKeyDesc()
		default:
			err = beaconDESC.SortByKeyDesc()
		}
		if err != nil {
			beaconDESC.SetInitialized(false)
			slog.Error("failed to sort keyBeaconDESC", "error", err)
		}
	}

}

func (s *swamp) addToKeyBeacon(treasureInterface treasure.Treasure) {
	// check if the index is already built
	// if not, then we don't need to add the treasures to the index
	if !s.keyBeaconASC.IsInitialized() {
		return
	}
	s.keyBeaconASC.Add(treasureInterface)
	err := s.keyBeaconASC.SortByKeyAsc()
	if err != nil {
		slog.Error("failed to sort keyBeaconASC", "error", err)
	}
	s.keyBeaconDESC.Add(treasureInterface)
	err = s.keyBeaconDESC.SortByKeyDesc()
	if err != nil {
		slog.Error("failed to sort keyBeaconDESC", "error", err)
	}
}

// addToCreationTimeBeacon - add the treasures to the creationTimeBeaconASC and creationTimeBeaconDESC slices if the treasure
// is not already in the slices
func (s *swamp) addToCreationTimeBeacon(treasureInterface treasure.Treasure) {
	// check if the index is already built
	// if not, then we don't need to add the treasures to the index
	if !s.creationTimeBeaconASC.IsInitialized() {
		return
	}
	s.creationTimeBeaconASC.Add(treasureInterface)
	err := s.creationTimeBeaconASC.SortByCreationTimeAsc()
	if err != nil {
		slog.Error("failed to sort creationTimeBeaconASC", "error", err)
	}
	s.creationTimeBeaconDESC.Add(treasureInterface)
	err = s.creationTimeBeaconDESC.SortByCreationTimeDesc()
	if err != nil {
		slog.Error("failed to sort creationTimeBeaconDESC", "error", err)
	}
}
func (s *swamp) addToUpdateTimeBeacon(treasureInterface treasure.Treasure) {
	// check if the index is already built
	// if not, then we don't need to add the treasures to the index
	if !s.updateTimeBeaconASC.IsInitialized() {
		return
	}
	s.updateTimeBeaconASC.Add(treasureInterface)
	err := s.updateTimeBeaconASC.SortByUpdateTimeAsc()
	if err != nil {
		slog.Error("failed to sort updateTimeBeaconASC", "error", err)
	}
	s.updateTimeBeaconDESC.Add(treasureInterface)
	err = s.updateTimeBeaconDESC.SortByUpdateTimeDesc()
	if err != nil {
		slog.Error("failed to sort updateTimeBeaconDESC", "error", err)
	}

}
func (s *swamp) addToExpirationTimeBeacon(treasureInterface treasure.Treasure) {
	// check if the index is already built
	// if not, then we don't need to add the treasures to the index
	if !s.expirationTimeBeaconASC.IsInitialized() {
		return
	}
	s.expirationTimeBeaconASC.Add(treasureInterface)
	err := s.expirationTimeBeaconASC.SortByExpirationTimeAsc()
	if err != nil {
		slog.Error("failed to sort expirationTimeBeaconASC", "error", err)
	}

	s.expirationTimeBeaconDESC.Add(treasureInterface)
	err = s.expirationTimeBeaconDESC.SortByExpirationTimeDesc()
	if err != nil {
		slog.Error("failed to sort expirationTimeBeaconDESC", "error", err)
	}

}
func (s *swamp) addToValueBeacon(treasureInterface treasure.Treasure) {
	// check if the index is already built
	// if not, then we don't need to add the treasures to the index
	if !s.valueBeaconASC.IsInitialized() {
		return
	}
	s.valueBeaconASC.Add(treasureInterface)
	err := s.valueBeaconASC.SortByValueInt64ASC()
	if err != nil {
		slog.Error("failed to sort valueIntBeaconASC", "error", err)
	}
	s.valueBeaconDESC.Add(treasureInterface)
	err = s.valueBeaconDESC.SortByValueInt64DESC()
	if err != nil {
		slog.Error("failed to sort valueIntBeaconDESC", "error", err)
	}
}

// sendEventToHydra sends the event to the ManagerInterface
func (s *swamp) sendEventToHydra(newTreasure, oldTreasure treasure.Treasure, status treasure.TreasureStatus) {

	if atomic.LoadInt32(&s.isEventSendingActive) == 0 {
		return
	}

	swampName := s.GetName()

	// create the event_channel_handler for the ManagerInterface database
	event := &Event{
		SwampName:       swampName,
		Treasure:        newTreasure,
		OldTreasure:     oldTreasure,
		DeletedTreasure: nil,
		EventTime:       time.Now().UTC().UnixNano(),
		StatusType:      status,
	}

	s.swampEventCallback(event)

}

func (s *swamp) startWriteListener() {

	s.mu.RLock()
	writeInterval := s.writeInterval
	s.mu.RUnlock()

	writeTicker := time.NewTicker(writeInterval)
	defer writeTicker.Stop()

	for {
		select {
		case <-s.goRoutineContext.Done():
			// return
			return
		case <-writeTicker.C:

			func() {

				// zárjuk a lockot, hogy a leállító művelet várakozzon a file kiírásának befejezésére és csak utána legyen képes
				// leállítani a swampot
				s.closeWriteMutex.Lock()
				defer s.closeWriteMutex.Unlock()

				if atomic.LoadInt32(&s.isFilesystemWritingActive) == 1 || atomic.LoadInt32(&s.closing) == 1 || s.treasuresWaitingForWriter.Count() == 0 {
					// nem kell kiírni a fileba, mert vagy már kiírás alatt van, vagy már le van állítva a swamp, vagy nincs mit kiírni így
					// egyből fel is szabadítjuk a lockot
					return
				}

				// kiírjuk a fileba a várakozó treasureket
				s.fileWriterHandler(false)

			}()

		}
	}

}

func (s *swamp) startCloseListener() {

	closeGapDuration := 1 * time.Second

	closeTicker := time.NewTicker(closeGapDuration)
	defer closeTicker.Stop()

	for {
		select {
		case <-s.goRoutineContext.Done():

			// return
			return

		case <-closeTicker.C:

			// closeMonitoring monitors the object and closes the swamp when the minimum open time is passed and if all
			// goroutines are finished their work
			currentTime := time.Now()
			lastInteractionTime := time.Unix(0, atomic.LoadInt64(&s.lastInteractionTime))

			func() {

				// lockolunk, hogy az ellenőrzés ideje alatt ne tudjon leállítani senki és írni se tudjon senki, de a fiepointer eventek se kerüljenek be,
				// mert azokat is ki kell írni a fileba.
				s.closeWriteMutex.Lock()
				defer s.closeWriteMutex.Unlock()

				// Ha ez egy in-memory swamp, akkor nem kell vizsgálni a lezárásnál, hogy a isFilesystemWritingActive 1-e, mert nincs
				// filerednszer szintű írás, csak a memóriában tároljuk a treasureket és csak azt kell ellenőrizni, hogy nincs-e aktív tranzakció
				// és nincs-e aktív vigília és az utolsó interakció óta eltelt idő nagyobb-e mint a closeAfterIdle
				// és ezt kjövetően már be is lehet zárni a swampot
				if atomic.LoadInt32(&s.inMemorySwamp) == 1 {
					if !s.Vigil.HasActiveVigils() && atomic.LoadInt32(&s.closing) == 0 && currentTime.After(lastInteractionTime.Add(s.closeAfterIdle+closeGapDuration)) {
						s.Close()
					}
				} else {
					if atomic.LoadInt32(&s.isFilesystemWritingActive) == 0 && !s.Vigil.HasActiveVigils() && atomic.LoadInt32(&s.closing) == 0 && currentTime.After(lastInteractionTime.Add(s.closeAfterIdle+closeGapDuration)) {
						// a swampot éppp nem írja senki, nincs aktív tranzakció, nem zárjuk éppen le és megfelelünk annak a követelménynek is, hogy
						// az utoljára történt interakció óta eltelt idő nagyobb legyen mint a closeAfterIdle, így a swamp leállítható biztonságosan
						s.Close()
					}
				}

			}()

		}
	}

}

// FilePointerCallbackFunction ez egy callback funkció, amit a chroniclerInterface hív meg, amikor egy filepointer
// event érkezik
func (s *swamp) FilePointerCallbackFunction(filePointerEvents []*chronicler.FileNameEvent) error {

	// ne tegyünk semmit, ha a swamp éppen leállítás alatt van
	if atomic.LoadInt32(&s.closing) == 1 {
		return errors.New("swamp is closing")
	}

	if filePointerEvents == nil {
		return nil
	}

	for _, e := range filePointerEvents {
		if s.beaconKey != nil && e != nil && e.TreasureKey != "" {

			func() {
				treasureObj := s.beaconKey.Get(e.TreasureKey)
				if treasureObj == nil {
					return
				}
				lockerID := treasureObj.StartTreasureGuard(true, guard.BodyAuthID)
				defer treasureObj.ReleaseTreasureGuard(lockerID)
				// set the loader pointer of the treasure
				treasureObj.BodySetFileName(lockerID, e.FileName)
			}()

		}
	}

	return nil

}

--------------------------------------------------------------------------------

/==============================================================================\
| FILE: core\hydra\swamp\swamp_test.go
| PATH: C:\go\src\hydraide\app\core\hydra\swamp\swamp_test.go
| SIZE: 41.1 KB
\==============================================================================/

package swamp

import (
	"fmt"
	"github.com/hydraide/hydraide/app/core/filesystem"
	"github.com/hydraide/hydraide/app/core/hydra/swamp/chronicler"
	"github.com/hydraide/hydraide/app/core/hydra/swamp/metadata"
	"github.com/hydraide/hydraide/app/core/settings"
	"github.com/hydraide/hydraide/app/name"
	"github.com/stretchr/testify/assert"
	"strconv"
	"sync"
	"sync/atomic"
	"testing"
	"time"
)

const (
	sanctuaryForQuickTest = "quick-test"
	testAllServers        = 100
	testMaxDepth          = 3
	testMaxFolderPerLevel = 2000
)

func TestNew(t *testing.T) {

	fsInterface := filesystem.New()
	settingsInterface := settings.New(testMaxDepth, testMaxFolderPerLevel)
	// gyors filementés és bezárás a tesztekhez
	fss := &settings.FileSystemSettings{
		WriteIntervalSec: 1,
		MaxFileSizeByte:  8192,
	}
	settingsInterface.RegisterPattern(name.New().Sanctuary(sanctuaryForQuickTest).Realm("*").Swamp("*"), false, 1, fss)
	closeAfterIdle := 1 * time.Second
	writeInterval := 1 * time.Second
	maxFileSize := int64(8192)

	t.Run("should create a treasure", func(t *testing.T) {

		swampEventCallbackFunc := func(e *Event) {
			fmt.Println("event received")
		}

		closeCallbackFunc := func(n name.Name) {
			t.Log("swamp closed" + n.Get())
		}

		swampInfoCallbackFunc := func(i *Info) {
			fmt.Println("info received")
		}

		swampName := name.New().Sanctuary(sanctuaryForQuickTest).Realm("create").Swamp("treasure")

		hashPath := swampName.GetFullHashPath(settingsInterface.GetHydraAbsDataFolderPath(), testAllServers, testMaxDepth, testMaxFolderPerLevel)
		chroniclerInterface := chronicler.New(hashPath, maxFileSize, testMaxDepth, fsInterface, metadata.New(hashPath))
		chroniclerInterface.CreateDirectoryIfNotExists()

		fssSwamp := &FilesystemSettings{
			ChroniclerInterface: chroniclerInterface,
			WriteInterval:       writeInterval,
		}

		metadataInterface := metadata.New(hashPath)
		swampInterface := New(swampName, closeAfterIdle, fssSwamp, swampEventCallbackFunc, swampInfoCallbackFunc, closeCallbackFunc, metadataInterface)

		treasureInterface := swampInterface.CreateTreasure("test")
		assert.NotNil(t, treasureInterface)

		swampInterface.Destroy()

	})

	t.Run("should close a swamp by the close function", func(t *testing.T) {

		swampName := name.New().Sanctuary(sanctuaryForQuickTest).Realm("should-close-the-swamp").Swamp("by-the-close-button")

		hashPath := swampName.GetFullHashPath(settingsInterface.GetHydraAbsDataFolderPath(), testAllServers, testMaxDepth, testMaxFolderPerLevel)
		chroniclerInterface := chronicler.New(hashPath, maxFileSize, testMaxDepth, fsInterface, metadata.New(hashPath))
		chroniclerInterface.CreateDirectoryIfNotExists()

		wg := &sync.WaitGroup{}
		wg.Add(1)

		closeCounter := 0

		swampEventCallbackFunc := func(e *Event) {
			fmt.Println("event received")
		}

		closeCallbackFunc := func(n name.Name) {
			t.Log("swamp closed " + n.Get())
			closeCounter++
			// a destroy funkció is küld egy closed eseményt, ezért itt 2 esemény is keletkezik
			if closeCounter == 1 {
				wg.Done()
			}
		}

		swampInfoCallbackFunc := func(i *Info) {
			fmt.Println("info received")
		}

		fssSwamp := &FilesystemSettings{
			ChroniclerInterface: chroniclerInterface,
			WriteInterval:       writeInterval,
		}

		metadataInterface := metadata.New(hashPath)
		swampInterface := New(swampName, closeAfterIdle, fssSwamp, swampEventCallbackFunc, swampInfoCallbackFunc, closeCallbackFunc, metadataInterface)
		swampInterface.BeginVigil()

		treasureInterface := swampInterface.CreateTreasure("test")
		// treasureInterface should not be nil
		assert.NotNil(t, treasureInterface)
		guardID := treasureInterface.StartTreasureGuard(true)
		treasureInterface.Save(guardID)
		treasureInterface.ReleaseTreasureGuard(guardID)

		swampInterface.CeaseVigil()
		swampInterface.Close()

		wg.Wait()

		swampInterface.Destroy()

	})

	t.Run("should close a swamp by the idle setting", func(t *testing.T) {

		swampName := name.New().Sanctuary(sanctuaryForQuickTest).Realm("should-close-the-swamp").Swamp("by-idle-setting")

		hashPath := swampName.GetFullHashPath(settingsInterface.GetHydraAbsDataFolderPath(), testAllServers, testMaxDepth, testMaxFolderPerLevel)
		chroniclerInterface := chronicler.New(hashPath, maxFileSize, testMaxDepth, fsInterface, metadata.New(hashPath))
		chroniclerInterface.CreateDirectoryIfNotExists()

		isClosed := int32(0)
		swampEventCallbackFunc := func(e *Event) {
			fmt.Println("event received")
		}

		closeCallbackFunc := func(n name.Name) {
			t.Log("swamp closed" + n.Get())
			atomic.StoreInt32(&isClosed, 1)
		}

		swampInfoCallbackFunc := func(i *Info) {
			fmt.Println("info received")
		}

		fssSwamp := &FilesystemSettings{
			ChroniclerInterface: chroniclerInterface,
			WriteInterval:       writeInterval,
		}
		metadataInterface := metadata.New(hashPath)
		swampInterface := New(swampName, closeAfterIdle, fssSwamp, swampEventCallbackFunc, swampInfoCallbackFunc, closeCallbackFunc, metadataInterface)

		swampInterface.BeginVigil()
		treasureInterface := swampInterface.CreateTreasure("test")
		if treasureInterface == nil {
			t.Errorf("treasureInterface should not be nil")
		}
		swampInterface.CeaseVigil()

		time.Sleep(2100 * time.Millisecond)

		assert.Equal(t, int32(1), atomic.LoadInt32(&isClosed), "swamp should be closed")

		swampInterface.Destroy()

	})

}

func TestSwamp_DeleteAllTreasures(t *testing.T) {

	fsInterface := filesystem.New()
	settingsInterface := settings.New(testMaxDepth, testMaxFolderPerLevel)
	// gyors filementés és bezárás a tesztekhez
	// gyors filementés és bezárás a tesztekhez
	fss := &settings.FileSystemSettings{
		WriteIntervalSec: 1,
		MaxFileSizeByte:  8192,
	}
	settingsInterface.RegisterPattern(name.New().Sanctuary(sanctuaryForQuickTest).Realm("*").Swamp("*"), false, 1, fss)
	closeAfterIdle := 1 * time.Second
	writeInterval := 1 * time.Second
	maxFileSize := int64(8192)

	t.Run("should delete all treasures", func(t *testing.T) {

		swampName := name.New().Sanctuary(sanctuaryForQuickTest).Realm("should-delete").Swamp("all-treasures")

		hashPath := swampName.GetFullHashPath(settingsInterface.GetHydraAbsDataFolderPath(), testAllServers, testMaxDepth, testMaxFolderPerLevel)
		chroniclerInterface := chronicler.New(hashPath, maxFileSize, testMaxDepth, fsInterface, metadata.New(hashPath))
		chroniclerInterface.CreateDirectoryIfNotExists()

		swampEventCallbackFunc := func(e *Event) {
			fmt.Println("event received")
		}

		closeCallbackFunc := func(n name.Name) {
			t.Log("swamp closed" + n.Get())
		}

		swampInfoCallbackFunc := func(i *Info) {
			fmt.Println("info received")
		}

		fssSwamp := &FilesystemSettings{
			ChroniclerInterface: chroniclerInterface,
			WriteInterval:       writeInterval,
		}

		metadataInterface := metadata.New(hashPath)
		swampInterface := New(swampName, closeAfterIdle, fssSwamp, swampEventCallbackFunc, swampInfoCallbackFunc, closeCallbackFunc, metadataInterface)
		swampInterface.BeginVigil()
		for i := 0; i < 100; i++ {
			treasureInterface := swampInterface.CreateTreasure(fmt.Sprintf("test-%d", i))
			if treasureInterface == nil {
				t.Errorf("treasureInterface should not be nil")
			}
			guardID := treasureInterface.StartTreasureGuard(true)
			_ = treasureInterface.Save(guardID)
			treasureInterface.ReleaseTreasureGuard(guardID)
		}

		assert.Equal(t, 100, swampInterface.CountTreasures(), "treasures should be 100")

		// get all treasures
		treasures := swampInterface.GetAll()
		for _, treasure := range treasures {
			if err := swampInterface.DeleteTreasure(treasure.GetKey(), false); err != nil {
				t.Errorf("error should be nil")
			}
		}
		assert.Equal(t, 0, swampInterface.CountTreasures(), "treasures should be 0")

		swampInterface.CeaseVigil()

	})

}

func TestSwamp_SendingInformation(t *testing.T) {

	fsInterface := filesystem.New()
	settingsInterface := settings.New(testMaxDepth, testMaxFolderPerLevel)
	// gyors filementés és bezárás a tesztekhez
	fss := &settings.FileSystemSettings{
		WriteIntervalSec: 1,
		MaxFileSizeByte:  8192,
	}
	settingsInterface.RegisterPattern(name.New().Sanctuary(sanctuaryForQuickTest).Realm("*").Swamp("*"), false, 1, fss)
	closeAfterIdle := 1 * time.Second
	writeInterval := 1 * time.Second
	maxFileSize := int64(8192)

	t.Run("should send information after all saved treasures", func(t *testing.T) {

		allTests := 100

		swampName := name.New().Sanctuary(sanctuaryForQuickTest).Realm("should-send").Swamp("information")

		hashPath := swampName.GetFullHashPath(settingsInterface.GetHydraAbsDataFolderPath(), testAllServers, testMaxDepth, testMaxFolderPerLevel)
		chroniclerInterface := chronicler.New(hashPath, maxFileSize, testMaxDepth, fsInterface, metadata.New(hashPath))
		chroniclerInterface.CreateDirectoryIfNotExists()

		wg := &sync.WaitGroup{}
		wg.Add(1)

		allInfoCounter := 0
		swampEventCallbackFunc := func(e *Event) {}

		closeCallbackFunc := func(n name.Name) {}

		swampInfoCallbackFunc := func(i *Info) {
			allInfoCounter++
			if allInfoCounter == allTests {
				wg.Done()
			}
		}

		fssSwamp := &FilesystemSettings{
			ChroniclerInterface: chroniclerInterface,
			WriteInterval:       writeInterval,
		}

		metadataInterface := metadata.New(hashPath)
		swampInterface := New(swampName, closeAfterIdle, fssSwamp, swampEventCallbackFunc, swampInfoCallbackFunc, closeCallbackFunc, metadataInterface)

		swampInterface.StartSendingInformation()

		for i := 0; i < allTests; i++ {
			treasureInterface := swampInterface.CreateTreasure(fmt.Sprintf("test-%d-%d", time.Now().UnixNano(), i))
			if treasureInterface == nil {
				t.Errorf("treasureInterface should not be nil")
			}
			guardID := treasureInterface.StartTreasureGuard(true)
			_ = treasureInterface.Save(guardID)
			treasureInterface.ReleaseTreasureGuard(guardID)
		}

		wg.Wait()

		swampInterface.StopSendingInformation()

		swampInterface.Destroy()

	})

}

func TestSwamp_SendingEvent(t *testing.T) {

	fsInterface := filesystem.New()
	settingsInterface := settings.New(testMaxDepth, testMaxFolderPerLevel)
	// gyors filementés és bezárás a tesztekhez
	fss := &settings.FileSystemSettings{
		WriteIntervalSec: 1,
		MaxFileSizeByte:  8192,
	}
	settingsInterface.RegisterPattern(name.New().Sanctuary(sanctuaryForQuickTest).Realm("*").Swamp("*"), false, 1, fss)
	closeAfterIdle := 1 * time.Second
	writeInterval := 1 * time.Second
	maxFileSize := int64(8192)

	t.Run("should send events after all saved treasures", func(t *testing.T) {

		allTests := 100

		swampName := name.New().Sanctuary(sanctuaryForQuickTest).Realm("should-send").Swamp("event")

		hashPath := swampName.GetFullHashPath(settingsInterface.GetHydraAbsDataFolderPath(), testAllServers, testMaxDepth, testMaxFolderPerLevel)
		chroniclerInterface := chronicler.New(hashPath, maxFileSize, testMaxDepth, fsInterface, metadata.New(hashPath))
		chroniclerInterface.CreateDirectoryIfNotExists()

		wg := &sync.WaitGroup{}
		wg.Add(allTests)
		eventCounter := 0
		swampEventCallbackFunc := func(e *Event) {
			eventCounter++
			if eventCounter == allTests {
				wg.Done()
			}
		}

		closeCallbackFunc := func(n name.Name) {}

		swampInfoCallbackFunc := func(i *Info) {}

		fssSwamp := &FilesystemSettings{
			ChroniclerInterface: chroniclerInterface,
			WriteInterval:       writeInterval,
		}

		metadataInterface := metadata.New(hashPath)
		swampInterface := New(swampName, closeAfterIdle, fssSwamp, swampEventCallbackFunc, swampInfoCallbackFunc, closeCallbackFunc, metadataInterface)
		defer swampInterface.Destroy()

		swampInterface.BeginVigil()
		swampInterface.StartSendingEvents()

		for i := 0; i < allTests; i++ {
			treasureInterface := swampInterface.CreateTreasure(fmt.Sprintf("test-%d-%d", time.Now().Unix(), i))
			if treasureInterface == nil {
				t.Errorf("treasureInterface should not be nil")
			}
			guardID := treasureInterface.StartTreasureGuard(true)
			_ = treasureInterface.Save(guardID)
			treasureInterface.ReleaseTreasureGuard(guardID)
		}

		swampInterface.CeaseVigil()

		wg.Done()

		swampInterface.BeginVigil()
		swampInterface.StopSendingEvents()
		swampInterface.CeaseVigil()

	})

}

func TestSwamp_GetTreasuresByBeacon(t *testing.T) {

	fsInterface := filesystem.New()
	settingsInterface := settings.New(testMaxDepth, testMaxFolderPerLevel)
	// gyors filementés és bezárás a tesztekhez
	fss := &settings.FileSystemSettings{
		WriteIntervalSec: 1,
		MaxFileSizeByte:  8192,
	}
	settingsInterface.RegisterPattern(name.New().Sanctuary(sanctuaryForQuickTest).Realm("*").Swamp("*"), false, 1, fss)
	closeAfterIdle := 1 * time.Second
	writeInterval := 1 * time.Second
	maxFileSize := int64(8192)

	t.Run("Should Get treasures by the beacon", func(t *testing.T) {

		allTests := 10

		swampName := name.New().Sanctuary(sanctuaryForQuickTest).Realm("should-get-treasure").Swamp("by-beacon")

		hashPath := swampName.GetFullHashPath(settingsInterface.GetHydraAbsDataFolderPath(), testAllServers, testMaxDepth, testMaxFolderPerLevel)
		chroniclerInterface := chronicler.New(hashPath, maxFileSize, testMaxDepth, fsInterface, metadata.New(hashPath))
		chroniclerInterface.CreateDirectoryIfNotExists()

		swampEventCallbackFunc := func(e *Event) {}

		closeCallbackFunc := func(n name.Name) {}

		swampInfoCallbackFunc := func(i *Info) {}

		fssSwamp := &FilesystemSettings{
			ChroniclerInterface: chroniclerInterface,
			WriteInterval:       writeInterval,
		}

		metadataInterface := metadata.New(hashPath)
		swampInterface := New(swampName, closeAfterIdle, fssSwamp, swampEventCallbackFunc, swampInfoCallbackFunc, closeCallbackFunc, metadataInterface)
		swampInterface.BeginVigil()

		for i := 0; i < allTests; i++ {
			treasureInterface := swampInterface.CreateTreasure(fmt.Sprintf("%d", i))
			if treasureInterface == nil {
				t.Errorf("treasureInterface should not be nil")
			}
			guardID := treasureInterface.StartTreasureGuard(true)
			treasureInterface.SetCreatedAt(guardID, time.Now())
			treasureInterface.SetModifiedAt(guardID, time.Now())
			treasureInterface.SetContentString(guardID, fmt.Sprintf("content-%d", i))
			treasureInterface.ReleaseTreasureGuard(guardID)

			guardID = treasureInterface.StartTreasureGuard(true)
			_ = treasureInterface.Save(guardID)
			treasureInterface.ReleaseTreasureGuard(guardID)

			time.Sleep(time.Millisecond * 10)
		}

		receivedTreasures, err := swampInterface.GetTreasuresByBeacon(BeaconTypeCreationTime, IndexOrderAsc, 0, 10)
		assert.Nil(t, err, "error should be nil")
		assert.Equal(t, allTests, len(receivedTreasures), "treasures should be 10")

		lastID := 0
		for _, tr := range receivedTreasures {
			keyInt, err := strconv.Atoi(tr.GetKey())
			assert.Nil(t, err, "error should be nil")
			assert.Equal(t, lastID, keyInt, "key should be in order")
			lastID++
		}

		receivedTreasures, err = swampInterface.GetTreasuresByBeacon(BeaconTypeCreationTime, IndexOrderDesc, 0, 10)
		assert.Nil(t, err, "error should be nil")
		assert.Equal(t, allTests, len(receivedTreasures), "treasures should be 10")

		lastID = 9
		for _, tr := range receivedTreasures {
			keyInt, err := strconv.Atoi(tr.GetKey())
			assert.Nil(t, err, "error should be nil")
			assert.Equal(t, lastID, keyInt, "key should be in order")
			lastID--
		}

		receivedTreasures, err = swampInterface.GetTreasuresByBeacon(BeaconTypeUpdateTime, IndexOrderAsc, 0, 5)
		assert.Nil(t, err, "error should be nil")
		assert.Equal(t, 5, len(receivedTreasures), "treasures should be 5")

		lastID = 0
		for _, tr := range receivedTreasures {
			keyInt, err := strconv.Atoi(tr.GetKey())
			assert.Nil(t, err, "error should be nil")
			assert.Equal(t, lastID, keyInt, "key should be in order")
			lastID++
		}

		receivedTreasures, err = swampInterface.GetTreasuresByBeacon(BeaconTypeUpdateTime, IndexOrderDesc, 0, 5)
		assert.Nil(t, err, "error should be nil")
		assert.Equal(t, 5, len(receivedTreasures), "treasures should be 5")

		lastID = 9
		for _, tr := range receivedTreasures {
			keyInt, err := strconv.Atoi(tr.GetKey())
			assert.Nil(t, err, "error should be nil")
			assert.Equal(t, lastID, keyInt, "key should be in order")
			lastID--
		}

		receivedTreasures, err = swampInterface.GetTreasuresByBeacon(BeaconTypeValueString, IndexOrderAsc, 0, 10)
		assert.Nil(t, err, "error should be nil")
		assert.Equal(t, 10, len(receivedTreasures), "treasures should be 10")

		lastID = 0
		for _, tr := range receivedTreasures {
			keyInt, err := strconv.Atoi(tr.GetKey())
			assert.Nil(t, err, "error should be nil")
			assert.Equal(t, lastID, keyInt, "key should be in order")
			lastID++
		}

		receivedTreasures, err = swampInterface.GetTreasuresByBeacon(BeaconTypeValueString, IndexOrderDesc, 0, 10)
		assert.Nil(t, err, "error should be nil")
		assert.Equal(t, 10, len(receivedTreasures), "treasures should be 10")

		lastID = 9
		for _, tr := range receivedTreasures {
			keyInt, err := strconv.Atoi(tr.GetKey())
			assert.Nil(t, err, "error should be nil")
			assert.Equal(t, lastID, keyInt, "key should be in order")
			lastID--
		}

		swampInterface.CeaseVigil()
		swampInterface.Destroy()

	})

	t.Run("should get treasures by the int beacon", func(t *testing.T) {

		allTests := 10

		swampName := name.New().Sanctuary(sanctuaryForQuickTest).Realm("should-get-treasure").Swamp("by-int-beacon")

		hashPath := swampName.GetFullHashPath(settingsInterface.GetHydraAbsDataFolderPath(), testAllServers, testMaxDepth, testMaxFolderPerLevel)
		chroniclerInterface := chronicler.New(hashPath, maxFileSize, testMaxDepth, fsInterface, metadata.New(hashPath))
		chroniclerInterface.CreateDirectoryIfNotExists()

		swampEventCallbackFunc := func(e *Event) {}

		closeCallbackFunc := func(n name.Name) {}

		swampInfoCallbackFunc := func(i *Info) {}

		fssSwamp := &FilesystemSettings{
			ChroniclerInterface: chroniclerInterface,
			WriteInterval:       writeInterval,
		}

		metadataInterface := metadata.New(hashPath)
		swampInterface := New(swampName, closeAfterIdle, fssSwamp, swampEventCallbackFunc, swampInfoCallbackFunc, closeCallbackFunc, metadataInterface)
		swampInterface.BeginVigil()

		for i := 0; i < allTests; i++ {
			treasureInterface := swampInterface.CreateTreasure(fmt.Sprintf("%d", i))
			if treasureInterface == nil {
				t.Errorf("treasureInterface should not be nil")
			}
			guardID := treasureInterface.StartTreasureGuard(true)
			treasureInterface.SetContentInt64(guardID, int64(i))
			treasureInterface.ReleaseTreasureGuard(guardID)

			guardID = treasureInterface.StartTreasureGuard(true)
			_ = treasureInterface.Save(guardID)
			treasureInterface.ReleaseTreasureGuard(guardID)

		}

		receivedTreasures, err := swampInterface.GetTreasuresByBeacon(BeaconTypeValueInt64, IndexOrderAsc, 0, 10)
		assert.Nil(t, err, "error should be nil")
		assert.Equal(t, allTests, len(receivedTreasures), "treasures should be 10")

		lastID := 0
		for _, tr := range receivedTreasures {
			i, _ := tr.GetContentInt64()
			assert.Nil(t, err, "error should be nil")
			assert.Equal(t, int64(lastID), i, "key should be in order")
			lastID++
		}

		receivedTreasures, err = swampInterface.GetTreasuresByBeacon(BeaconTypeValueInt64, IndexOrderDesc, 0, 10)
		assert.Nil(t, err, "error should be nil")
		assert.Equal(t, allTests, len(receivedTreasures), "treasures should be 10")

		lastID = 9
		for _, tr := range receivedTreasures {
			keyInt, err := strconv.Atoi(tr.GetKey())
			assert.Nil(t, err, "error should be nil")
			assert.Equal(t, lastID, keyInt, "key should be in order")
			lastID--
		}

		swampInterface.CeaseVigil()
		swampInterface.Destroy()

	})

	t.Run("should get treasures by the float beacon", func(t *testing.T) {

		allTests := 10

		swampName := name.New().Sanctuary(sanctuaryForQuickTest).Realm("should-get-treasure").Swamp("by-float-beacon")

		hashPath := swampName.GetFullHashPath(settingsInterface.GetHydraAbsDataFolderPath(), testAllServers, testMaxDepth, testMaxFolderPerLevel)
		chroniclerInterface := chronicler.New(hashPath, maxFileSize, testMaxDepth, fsInterface, metadata.New(hashPath))
		chroniclerInterface.CreateDirectoryIfNotExists()

		swampEventCallbackFunc := func(e *Event) {}

		closeCallbackFunc := func(n name.Name) {}

		swampInfoCallbackFunc := func(i *Info) {}

		fssSwamp := &FilesystemSettings{
			ChroniclerInterface: chroniclerInterface,
			WriteInterval:       writeInterval,
		}

		metadataInterface := metadata.New(hashPath)
		swampInterface := New(swampName, closeAfterIdle, fssSwamp, swampEventCallbackFunc, swampInfoCallbackFunc, closeCallbackFunc, metadataInterface)
		swampInterface.BeginVigil()

		for i := 0; i < allTests; i++ {
			treasureInterface := swampInterface.CreateTreasure(fmt.Sprintf("%d", i))
			if treasureInterface == nil {
				t.Errorf("treasureInterface should not be nil")
			}
			guardID := treasureInterface.StartTreasureGuard(true)
			treasureInterface.SetContentFloat64(guardID, 0.12+float64(i))
			treasureInterface.ReleaseTreasureGuard(guardID)

			guardID = treasureInterface.StartTreasureGuard(true)
			_ = treasureInterface.Save(guardID)
			treasureInterface.ReleaseTreasureGuard(guardID)

		}

		receivedTreasures, err := swampInterface.GetTreasuresByBeacon(BeaconTypeValueFloat64, IndexOrderAsc, 0, 10)
		assert.Nil(t, err, "error should be nil")
		assert.Equal(t, allTests, len(receivedTreasures), "treasures should be 10")

		lastID := 0
		for _, tr := range receivedTreasures {
			keyInt, err := strconv.Atoi(tr.GetKey())
			assert.Nil(t, err, "error should be nil")
			assert.Equal(t, lastID, keyInt, "key should be in order")
			lastID++
		}

		receivedTreasures, err = swampInterface.GetTreasuresByBeacon(BeaconTypeValueFloat64, IndexOrderDesc, 0, 10)
		assert.Nil(t, err, "error should be nil")
		assert.Equal(t, allTests, len(receivedTreasures), "treasures should be 10")

		lastID = 9
		for _, tr := range receivedTreasures {
			keyInt, err := strconv.Atoi(tr.GetKey())
			assert.Nil(t, err, "error should be nil")
			assert.Equal(t, lastID, keyInt, "key should be in order")
			lastID--
		}

		swampInterface.CeaseVigil()
		swampInterface.Destroy()

	})

	t.Run("should get treasures by the expiration time beacon", func(t *testing.T) {

		allTests := 10

		swampName := name.New().Sanctuary(sanctuaryForQuickTest).Realm("should-get-treasure").Swamp("by-expiration-time-beacon")

		hashPath := swampName.GetFullHashPath(settingsInterface.GetHydraAbsDataFolderPath(), testAllServers, testMaxDepth, testMaxFolderPerLevel)
		chroniclerInterface := chronicler.New(hashPath, maxFileSize, testMaxDepth, fsInterface, metadata.New(hashPath))
		chroniclerInterface.CreateDirectoryIfNotExists()

		swampEventCallbackFunc := func(e *Event) {}

		closeCallbackFunc := func(n name.Name) {}

		swampInfoCallbackFunc := func(i *Info) {}

		fssSwamp := &FilesystemSettings{
			ChroniclerInterface: chroniclerInterface,
			WriteInterval:       writeInterval,
		}

		metadataInterface := metadata.New(hashPath)
		swampInterface := New(swampName, closeAfterIdle, fssSwamp, swampEventCallbackFunc, swampInfoCallbackFunc, closeCallbackFunc, metadataInterface)
		swampInterface.BeginVigil()

		for i := 0; i < allTests; i++ {
			treasureInterface := swampInterface.CreateTreasure(fmt.Sprintf("%d", i))
			if treasureInterface == nil {
				t.Errorf("treasureInterface should not be nil")
			}
			guardID := treasureInterface.StartTreasureGuard(true)
			treasureInterface.SetContentFloat64(guardID, 0.12+float64(i))
			treasureInterface.SetExpirationTime(guardID, time.Now().Add(-time.Second*time.Duration(i)))
			treasureInterface.ReleaseTreasureGuard(guardID)

			guardID = treasureInterface.StartTreasureGuard(true)
			_ = treasureInterface.Save(guardID)
			treasureInterface.ReleaseTreasureGuard(guardID)

			time.Sleep(time.Millisecond * 10)
		}

		receivedTreasures, err := swampInterface.GetTreasuresByBeacon(BeaconTypeExpirationTime, IndexOrderAsc, 0, 10)
		assert.Nil(t, err, "error should be nil")
		assert.Equal(t, allTests, len(receivedTreasures), "treasures should be 10")

		lastID := 9
		for _, tr := range receivedTreasures {
			keyInt, err := strconv.Atoi(tr.GetKey())
			assert.Nil(t, err, "error should be nil")
			assert.Equal(t, lastID, keyInt, "key should be in order")
			lastID--
		}

		receivedTreasures, err = swampInterface.GetTreasuresByBeacon(BeaconTypeExpirationTime, IndexOrderDesc, 0, 10)
		assert.Nil(t, err, "error should be nil")
		assert.Equal(t, allTests, len(receivedTreasures), "treasures should be 10")

		lastID = 0
		for _, tr := range receivedTreasures {
			keyInt, err := strconv.Atoi(tr.GetKey())
			assert.Nil(t, err, "error should be nil")
			assert.Equal(t, lastID, keyInt, "key should be in order")
			lastID++
		}

		swampInterface.CeaseVigil()
		swampInterface.Destroy()

	})

	t.Run("should get treasures from the beacon after deleting some treasures", func(t *testing.T) {

		allTests := 10

		swampName := name.New().Sanctuary(sanctuaryForQuickTest).Realm("should-get-treasure-from-beacon").Swamp("after-deleting-some-treasures")

		hashPath := swampName.GetFullHashPath(settingsInterface.GetHydraAbsDataFolderPath(), testAllServers, testMaxDepth, testMaxFolderPerLevel)
		chroniclerInterface := chronicler.New(hashPath, maxFileSize, testMaxDepth, fsInterface, metadata.New(hashPath))
		chroniclerInterface.CreateDirectoryIfNotExists()

		swampEventCallbackFunc := func(e *Event) {}

		closeCallbackFunc := func(n name.Name) {}

		swampInfoCallbackFunc := func(i *Info) {}

		fssSwamp := &FilesystemSettings{
			ChroniclerInterface: chroniclerInterface,
			WriteInterval:       writeInterval,
		}

		metadataInterface := metadata.New(hashPath)
		swampInterface := New(swampName, closeAfterIdle, fssSwamp, swampEventCallbackFunc, swampInfoCallbackFunc, closeCallbackFunc, metadataInterface)
		swampInterface.BeginVigil()
		defer swampInterface.CeaseVigil()

		defaultTime := time.Now()

		// set treasures for the swamp
		for i := 0; i < allTests; i++ {

			func() {

				treasureInterface := swampInterface.CreateTreasure(fmt.Sprintf("%d", i))
				if treasureInterface == nil {
					t.Errorf("treasureInterface should not be nil")
				}

				guardID := treasureInterface.StartTreasureGuard(true)
				defer treasureInterface.ReleaseTreasureGuard(guardID)

				treasureInterface.SetCreatedAt(guardID, defaultTime.Add(time.Duration(i)*time.Nanosecond))
				treasureInterface.SetContentString(guardID, fmt.Sprintf("content-%d", i))
				_ = treasureInterface.Save(guardID)

			}()

		}

		// try to get all treasures back from the creation time beacon
		allTreasures, err := swampInterface.GetTreasuresByBeacon(BeaconTypeCreationTime, IndexOrderAsc, 0, 100000)
		assert.NoError(t, err, "error should be nil")
		assert.Equal(t, allTests, len(allTreasures), "treasures should be 10")

		// delete 1 treasure from the swamp with key 3
		_ = swampInterface.DeleteTreasure("3", false)

		// try to get all treasures back from the creation time beacon
		allTreasures, err = swampInterface.GetTreasuresByBeacon(BeaconTypeCreationTime, IndexOrderAsc, 0, 100000)
		assert.NoError(t, err, "error should be nil")
		assert.Equal(t, allTests-1, len(allTreasures), "treasures should be 8")

	})

	t.Run("should get treasures from beacon after the swamp closed, treasure deleted then got from the beacon", func(t *testing.T) {

		allTests := 10

		swampName := name.New().Sanctuary(sanctuaryForQuickTest).Realm("should-get-treasure-from-beacon").Swamp("after-swamp-closed")

		hashPath := swampName.GetFullHashPath(settingsInterface.GetHydraAbsDataFolderPath(), testAllServers, testMaxDepth, testMaxFolderPerLevel)
		chroniclerInterface := chronicler.New(hashPath, maxFileSize, testMaxDepth, fsInterface, metadata.New(hashPath))
		chroniclerInterface.CreateDirectoryIfNotExists()

		swampEventCallbackFunc := func(e *Event) {}

		closeCallbackFunc := func(n name.Name) {}

		swampInfoCallbackFunc := func(i *Info) {}

		fssSwamp := &FilesystemSettings{
			ChroniclerInterface: chroniclerInterface,
			WriteInterval:       writeInterval,
		}

		metadataInterface := metadata.New(hashPath)
		swampInterface := New(swampName, closeAfterIdle, fssSwamp, swampEventCallbackFunc, swampInfoCallbackFunc, closeCallbackFunc, metadataInterface)
		swampInterface.BeginVigil()
		defer swampInterface.CeaseVigil()

		defaultTime := time.Now()

		// set treasures for the swamp
		for i := 0; i < allTests; i++ {

			func() {

				treasureInterface := swampInterface.CreateTreasure(fmt.Sprintf("%d", i))
				if treasureInterface == nil {
					t.Errorf("treasureInterface should not be nil")
				}

				guardID := treasureInterface.StartTreasureGuard(true)
				defer treasureInterface.ReleaseTreasureGuard(guardID)

				treasureInterface.SetCreatedAt(guardID, defaultTime.Add(time.Duration(i)*time.Nanosecond))
				treasureInterface.SetContentString(guardID, fmt.Sprintf("content-%d", i))
				_ = treasureInterface.Save(guardID)

			}()

		}

		// wait for the swamp to close/write all treasures to the filesystem
		time.Sleep(3 * time.Second)

		fssSwamp = &FilesystemSettings{
			ChroniclerInterface: chroniclerInterface,
			WriteInterval:       writeInterval,
		}

		// create a new swamp with the same name and simulate the re-summoning of the swamp
		metadataInterface = metadata.New(hashPath)
		swampInterface = New(swampName, closeAfterIdle, fssSwamp, swampEventCallbackFunc, swampInfoCallbackFunc, closeCallbackFunc, metadataInterface)
		swampInterface.BeginVigil()
		defer swampInterface.CeaseVigil()

		// delete 1 treasure from the swamp with key 3
		_ = swampInterface.DeleteTreasure("3", false)

		// try to get all treasures back from the creation time beacon
		allTreasures, err := swampInterface.GetTreasuresByBeacon(BeaconTypeCreationTime, IndexOrderAsc, 0, 100000)
		assert.NoError(t, err, "error should be nil")
		assert.Equal(t, allTests-1, len(allTreasures), "treasures should be 9")

	})

}

// Test for GetChronicler
// Test for GetName
// Test for GetTreasure
// Test for GetManyTreasures
// Test for TreasureExists
func TestSwamp_GetTreasuresByBeaconWithVariousMethod(t *testing.T) {

	fsInterface := filesystem.New()
	settingsInterface := settings.New(testMaxDepth, testMaxFolderPerLevel)
	// gyors filementés és bezárás a tesztekhez

	fss := &settings.FileSystemSettings{
		WriteIntervalSec: 1,
		MaxFileSizeByte:  8192,
	}

	settingsInterface.RegisterPattern(name.New().Sanctuary(sanctuaryForQuickTest).Realm("*").Swamp("*"), false, 1, fss)
	closeAfterIdle := 1 * time.Second
	writeInterval := 1 * time.Second
	maxFileSize := int64(8192)

	t.Run("should get treasures by the beacon with various method", func(t *testing.T) {

		allTests := 10

		swampName := name.New().Sanctuary(sanctuaryForQuickTest).Realm("should-get-treasure-from-beacon").Swamp("wit-various-method")

		hashPath := swampName.GetFullHashPath(settingsInterface.GetHydraAbsDataFolderPath(), testAllServers, testMaxDepth, testMaxFolderPerLevel)
		chroniclerInterface := chronicler.New(hashPath, maxFileSize, testMaxDepth, fsInterface, metadata.New(hashPath))
		chroniclerInterface.CreateDirectoryIfNotExists()

		swampEventCallbackFunc := func(e *Event) {}

		closeCallbackFunc := func(n name.Name) {}

		swampInfoCallbackFunc := func(i *Info) {}

		fssSwamp := &FilesystemSettings{
			ChroniclerInterface: chroniclerInterface,
			WriteInterval:       writeInterval,
		}

		metadataInterface := metadata.New(hashPath)
		swampInterface := New(swampName, closeAfterIdle, fssSwamp, swampEventCallbackFunc, swampInfoCallbackFunc, closeCallbackFunc, metadataInterface)
		swampInterface.BeginVigil()

		for i := 0; i < allTests; i++ {
			treasureInterface := swampInterface.CreateTreasure(fmt.Sprintf("%d", i))
			if treasureInterface == nil {
				t.Errorf("treasureInterface should not be nil")
			}
			guardID := treasureInterface.StartTreasureGuard(true)
			treasureInterface.SetContentFloat64(guardID, 0.12+float64(i))
			treasureInterface.SetCreatedAt(guardID, time.Now())
			treasureInterface.SetExpirationTime(guardID, time.Now().Add(-time.Second*time.Duration(i)))
			treasureInterface.ReleaseTreasureGuard(guardID)

			guardID = treasureInterface.StartTreasureGuard(true)
			_ = treasureInterface.Save(guardID)
			treasureInterface.ReleaseTreasureGuard(guardID)

			time.Sleep(time.Millisecond * 10)
		}

		receivedChroniclerInterface := swampInterface.GetChronicler()
		assert.NotNil(t, receivedChroniclerInterface, "chroniclerInterface should not be nil")
		assert.True(t, receivedChroniclerInterface.IsFilesystemInitiated(), "chroniclerInterface should be initiated")

		receivedName := swampInterface.GetName()
		assert.Equal(t, swampName, receivedName, "name should be equal")

		treasureObject, err := swampInterface.GetTreasure("0")
		assert.Nil(t, err, "error should be nil")
		assert.NotNil(t, treasureObject, "treasureObject should not be nil")
		assert.Equal(t, "0", treasureObject.GetKey(), "key should be equal")
		assert.True(t, swampInterface.TreasureExists("0"), "treasure should exist")

		// get and delete the treasure 0
		treasureObject, err = swampInterface.GetTreasure("0")
		_ = swampInterface.DeleteTreasure(treasureObject.GetKey(), false)

		assert.Nil(t, err, "error should be nil")
		assert.NotNil(t, treasureObject, "treasureObject should not be nil")
		assert.Equal(t, "0", treasureObject.GetKey(), "key should be equal")
		assert.False(t, swampInterface.TreasureExists("0"), "treasure should NOT exist anymore")

		treasureObject, err = swampInterface.GetTreasure("0")
		assert.NotNil(t, err, fmt.Sprintf("error should be nil err: %s", err))
		assert.Nil(t, treasureObject, "treasureObject should be nil")

		swampInterface.CeaseVigil()
		swampInterface.Destroy()

	})

}

// Test for GetAndDeleteRandomTreasures
// Test for GetAndDeleteExpiredTreasures
func TestSwamp_GetAndDelete(t *testing.T) {

	fsInterface := filesystem.New()
	settingsInterface := settings.New(testMaxDepth, testMaxFolderPerLevel)
	// gyors filementés és bezárás a tesztekhez

	fss := &settings.FileSystemSettings{
		WriteIntervalSec: 1,
		MaxFileSizeByte:  8192,
	}

	settingsInterface.RegisterPattern(name.New().Sanctuary(sanctuaryForQuickTest).Realm("*").Swamp("*"), false, 1, fss)
	closeAfterIdle := 1 * time.Second
	writeInterval := 1 * time.Second
	maxFileSize := int64(8192)

	t.Run("should get and delete treasures", func(t *testing.T) {

		allTests := 10

		swampName := name.New().Sanctuary(sanctuaryForQuickTest).Realm("should-get").Swamp("and-delete-treasures")

		hashPath := swampName.GetFullHashPath(settingsInterface.GetHydraAbsDataFolderPath(), testAllServers, testMaxDepth, testMaxFolderPerLevel)
		chroniclerInterface := chronicler.New(hashPath, maxFileSize, testMaxDepth, fsInterface, metadata.New(hashPath))
		chroniclerInterface.CreateDirectoryIfNotExists()

		swampEventCallbackFunc := func(e *Event) {}

		closeCallbackFunc := func(n name.Name) {}

		swampInfoCallbackFunc := func(i *Info) {}

		fssSwamp := &FilesystemSettings{
			ChroniclerInterface: chroniclerInterface,
			WriteInterval:       writeInterval,
		}

		metadataInterface := metadata.New(hashPath)
		swampInterface := New(swampName, closeAfterIdle, fssSwamp, swampEventCallbackFunc, swampInfoCallbackFunc, closeCallbackFunc, metadataInterface)
		swampInterface.BeginVigil()

		for i := 0; i < allTests; i++ {
			treasureInterface := swampInterface.CreateTreasure(fmt.Sprintf("%d", i))
			if treasureInterface == nil {
				t.Errorf("treasureInterface should not be nil")
			}
			guardID := treasureInterface.StartTreasureGuard(true)
			treasureInterface.SetContentFloat64(guardID, 0.12+float64(i))
			treasureInterface.SetCreatedAt(guardID, time.Now())
			treasureInterface.SetExpirationTime(guardID, time.Now().Add(-time.Second*time.Duration(i)))
			treasureInterface.ReleaseTreasureGuard(guardID)

			guardID = treasureInterface.StartTreasureGuard(true)
			_ = treasureInterface.Save(guardID)
			treasureInterface.ReleaseTreasureGuard(guardID)

			time.Sleep(time.Millisecond * 10)
		}

		assert.Equal(t, allTests, swampInterface.CountTreasures())

		swampInterface.CeaseVigil()
		swampInterface.Destroy()

	})

}

func TestSwamp_GetAllTreasures(t *testing.T) {

	fsInterface := filesystem.New()
	settingsInterface := settings.New(testMaxDepth, testMaxFolderPerLevel)
	// gyors filementés és bezárás a tesztekhez

	fss := &settings.FileSystemSettings{
		WriteIntervalSec: 1,
		MaxFileSizeByte:  8192,
	}

	settingsInterface.RegisterPattern(name.New().Sanctuary(sanctuaryForQuickTest).Realm("*").Swamp("*"), false, 1, fss)
	closeAfterIdle := 1 * time.Second
	writeInterval := 1 * time.Second
	maxFileSize := int64(8192)

	t.Run("should get all treasures", func(t *testing.T) {

		allTests := 10

		swampName := name.New().Sanctuary(sanctuaryForQuickTest).Realm("should-get").Swamp("all-treasures")

		hashPath := swampName.GetFullHashPath(settingsInterface.GetHydraAbsDataFolderPath(), testAllServers, testMaxDepth, testMaxFolderPerLevel)
		chroniclerInterface := chronicler.New(hashPath, maxFileSize, testMaxDepth, fsInterface, metadata.New(hashPath))
		chroniclerInterface.CreateDirectoryIfNotExists()

		swampEventCallbackFunc := func(e *Event) {}

		closeCallbackFunc := func(n name.Name) {}

		swampInfoCallbackFunc := func(i *Info) {}

		fssSwamp := &FilesystemSettings{
			ChroniclerInterface: chroniclerInterface,
			WriteInterval:       writeInterval,
		}

		metadataInterface := metadata.New(hashPath)
		swampInterface := New(swampName, closeAfterIdle, fssSwamp, swampEventCallbackFunc, swampInfoCallbackFunc, closeCallbackFunc, metadataInterface)
		swampInterface.BeginVigil()

		receivedTreasures := swampInterface.GetAll()
		assert.Nil(t, receivedTreasures, "treasures should be nil")

		for i := 0; i < allTests; i++ {
			treasureInterface := swampInterface.CreateTreasure(fmt.Sprintf("%d", i))
			if treasureInterface == nil {
				t.Errorf("treasureInterface should not be nil")
			}
			guardID := treasureInterface.StartTreasureGuard(true)
			treasureInterface.SetContentString(guardID, fmt.Sprintf("content-%d", i))
			treasureInterface.ReleaseTreasureGuard(guardID)

			guardID = treasureInterface.StartTreasureGuard(true)
			_ = treasureInterface.Save(guardID)
			treasureInterface.ReleaseTreasureGuard(guardID)

		}

		treasures := swampInterface.GetAll()
		assert.Equal(t, allTests, len(treasures), "treasures should be 10")

		swampInterface.CeaseVigil()

	})
}

// elapsed time in seconds: 0.072401
// all elements int the swamp after end: 10000
// elements per second: 138119.261507
func TestSaveSpeed(t *testing.T) {

	allTest := 10

	fsInterface := filesystem.New()
	settingsInterface := settings.New(testMaxDepth, testMaxFolderPerLevel)
	// gyors filementés és bezárás a tesztekhez

	fss := &settings.FileSystemSettings{
		WriteIntervalSec: 1,
		MaxFileSizeByte:  8192,
	}

	settingsInterface.RegisterPattern(name.New().Sanctuary(sanctuaryForQuickTest).Realm("*").Swamp("*"), false, 1, fss)
	closeAfterIdle := 1 * time.Second
	writeInterval := 0 * time.Second
	maxFileSize := int64(8192)

	swampName := name.New().Sanctuary(sanctuaryForQuickTest).Realm("testing").Swamp("save-speed")

	hashPath := swampName.GetFullHashPath(settingsInterface.GetHydraAbsDataFolderPath(), testAllServers, testMaxDepth, testMaxFolderPerLevel)
	chroniclerInterface := chronicler.New(hashPath, maxFileSize, testMaxDepth, fsInterface, metadata.New(hashPath))
	chroniclerInterface.CreateDirectoryIfNotExists()

	swampEventCallbackFunc := func(e *Event) {}
	closeCallbackFunc := func(n name.Name) {}
	swampInfoCallbackFunc := func(i *Info) {}

	fssSwamp := &FilesystemSettings{
		ChroniclerInterface: chroniclerInterface,
		WriteInterval:       writeInterval,
	}

	metadataInterface := metadata.New(hashPath)
	swampInterface := New(swampName, closeAfterIdle, fssSwamp, swampEventCallbackFunc, swampInfoCallbackFunc, closeCallbackFunc, metadataInterface)

	swampInterface.BeginVigil()

	fmt.Printf("all elements int the swamp before starting: %d \n", swampInterface.CountTreasures())

	begin := time.Now()

	finishedChannel := make(chan bool)
	waiter := make(chan bool)
	go func() {
		finishedCount := 0
		for {
			<-finishedChannel
			finishedCount++
			if finishedCount == allTest {
				fmt.Println("all done")
				waiter <- true
			}
		}
	}()

	for i := 0; i < allTest; i++ {
		go func(counter int, fc chan<- bool) {

			newTreasure := swampInterface.CreateTreasure(fmt.Sprintf("test-%d", counter))
			guardID := newTreasure.StartTreasureGuard(true)

			newTreasure.SetContentString(guardID, "lorem ipsum dolor sit")
			defer newTreasure.ReleaseTreasureGuard(guardID)

			_ = newTreasure.Save(guardID)

			fc <- true
		}(i, finishedChannel)
	}

	<-waiter

	end := time.Now()
	elapsed := end.Sub(begin)

	fmt.Printf("elapsed time in seconds: %f \n", elapsed.Seconds())
	fmt.Printf("all elements int the swamp after end: %d \n", swampInterface.CountTreasures())

	// calculate how many elements per second
	fmt.Printf("elements per second: %f \n", float64(allTest)/elapsed.Seconds())

	swampInterface.CeaseVigil()

}

--------------------------------------------------------------------------------

/==============================================================================\
| FILE: core\hydra\swamp\treasure\guard\guard.go
| PATH: C:\go\src\hydraide\app\core\hydra\swamp\treasure\guard\guard.go
| SIZE: 8.9 KB
\==============================================================================/

// Package guard provides a concurrency-safe way to transaction a Treasure for exclusive access.
// It ensures that only one goroutine can execute operations on a Treasure at a given time.
// It also maintains a queue of goroutines waiting for the transaction, ensuring that they
// gain access to the Treasure in the order they requested it.
//
// As you can see, we use the guardID for every function call except for the GetKey function.
// The Guard object and the GuardID ensure that a given function, e.g. CloneContent, runs only when
// another goroutine is not using it. The Guard is not a standard sync.Mutex, but a special object that not
// only prevents another routine from accessing a single treasure at the same time, but also establishes an
// order, as it's very important in databases to have calling routines modify or access information in the
// order they were called. For example, if a user wants to top up their balance, we first top it up, and then
// they can purchase anything from their balance. If the two routines come in almost simultaneously, the regular
// Sync package doesn't guarantee that the order would necessarily be top-up followed by purchase. That's why we
// use the Guard to protect the data and also ensure the correct sequence.
package guard

import (
	"errors"
	"sync"
	"sync/atomic"
)

// Guard is an interface that defines methods for locking and unlocking a Treasure in a thread-safe and
// orderly manner. The interface is specifically designed to be part of the Treasure interface.
//
// Methods:
// - StartTreasureGuard: Acquires a transaction and returns a unique guardID.
// - ReleaseTreasureGuard: Releases the transaction for a given guardID.
// - CanExecute: Checks if the given guardID is first in the queue, and thus can perform operations on the Treasure.
type Guard interface {

	// StartTreasureGuard is a function that acquires a transaction on the Treasure and returns a unique guardID.
	// The function can be called with or without the waiting parameter. If waiting is true, the function will
	// block the goroutine until the Treasure is unlocked. If waiting is false, the function will return immediately
	// with a guardID of 0 if the Treasure is locked. This allows the calling goroutine to decide whether to wait
	// for the Treasure to be unlocked or to proceed with other operations.
	//
	// Example usage:
	//     guardID := treasure.StartTreasureGuard(true)
	//     // Perform your operations
	//     ...
	//     // Release the transaction
	//     treasure.ReleaseTreasureGuard(guardID)
	//
	StartTreasureGuard(waiting bool, bodyAuthID ...string) (guardID ID)

	// ReleaseTreasureGuard is a function that releases the transaction on the Treasure for the given guardID.
	// Once a goroutine completes its operations on the Treasure, it should call this method to free up
	// the Treasure for other goroutines in the queue.
	//
	// This is crucial for maintaining the order and flow of operations, as well as for system resources,
	// since failing to call this function could lead to other goroutines being indefinitely blocked or a resource deadlock.
	//
	// The function expects the guardID that was obtained from the StartTreasureGuard call. It's essential
	// to match the guardID correctly; otherwise, the unlock operation won't be successful.
	//
	// Example usage:
	//     guardID := treasure.StartTreasureGuard()
	//     // Perform your operations
	//     ...
	//     // Release the transaction
	//     treasure.ReleaseTreasureGuard(guardID)
	//
	// Important: Always make sure to call this function after you've completed your operations on the Treasure.
	// Failure to do so will prevent other goroutines in the queue from accessing the Treasure.
	//
	// Parameters:
	// - guardID int64: The unique identifier that was used to transaction the Treasure.
	//
	// Note: There is no need to manually call CanExecute before calling this function. The Guard system internally
	// handles the logic to allow the next goroutine in the queue to proceed.
	ReleaseTreasureGuard(guardID ID)

	// CanExecute is an internal function that checks if the given guardID is the first in the queue,
	// thereby determining if the calling goroutine can proceed with operations on the Treasure.
	//
	// IMPORTANT: This function is integrated into all Treasure-related functions and SHOULD NOT be called
	// directly, especially not from the Hydra head. Doing so can cause unintended behaviors and may disrupt
	// the sequencing of operations on the Treasure.
	//
	// The function waits until the guardID at the head of the queue matches the given guardID, effectively
	// blocking the goroutine until it's its turn. This ensures that operations are executed in the order they
	// were initiated, which is crucial for data consistency in database-like settings.
	//
	// Once CanExecute confirms that the guardID is at the head of the queue, the Treasure-related function will
	// proceed with its operation.
	//
	// Note: CanExecute is designed to be part of the internal workflow of the Treasure system. It ensures
	// correct sequencing but is not meant for external invocation. Always use the other functions provided by
	// the Treasure interface, and they will handle the sequencing internally using CanExecute.
	CanExecute(guardID ID, isBodyFunction ...bool) error
}

type ID int64

type guard struct {
	mu             sync.RWMutex
	cond           *sync.Cond
	waitForUnlock  []int64 // Queue of transaction IDs waiting for the Treasure to be unlocked.
	largestGuardID int64   // The highest transaction ID that has been unlocked.
	bodyAuthID     string  // The bodyAuthID of the goroutine that currently holds the transaction.
}

const (
	BodyAuthID = "kby1CXR0wkj@qpa2ynq"
)

// New creates a new Guard instance.
func New() Guard {
	l := &guard{
		waitForUnlock: make([]int64, 0),
	}
	l.cond = sync.NewCond(&l.mu)
	return l
}

// StartTreasureGuard start the treasure guard for the treasure and waits until the Treasure is unlocked if the waiting is true.
// otherwise it returns with 0
func (g *guard) StartTreasureGuard(waiting bool, bodyAuthID ...string) (guardID ID) {
	// Lock the condition's associated lock to ensure thread safety
	g.cond.L.Lock()
	defer g.cond.L.Unlock() // Ensure the lock is always released at the end of the function

	// If bodyAuthID is provided and g.bodyAuthID is empty, set it
	if len(bodyAuthID) > 0 {
		if g.bodyAuthID == "" {
			g.bodyAuthID = bodyAuthID[0]
		}
	}

	// If waiting is true, wait until the treasure is unlocked
	if waiting {
		// Increment the largestGuardID atomically and assign it to gID
		gID := atomic.AddInt64(&g.largestGuardID, 1)
		// Swamp the new guard ID to the waitForUnlock slice
		g.waitForUnlock = append(g.waitForUnlock, gID)
		if len(bodyAuthID) > 0 {
			g.bodyAuthID = bodyAuthID[0]
		}
		// Wait while the current guard ID is not the first in the queue
		for g.waitForUnlock[0] != gID {
			g.cond.Wait()
		}
		// Return the guard ID
		return ID(gID)
	} else {
		// If not waiting, and there are no other guards waiting
		if len(g.waitForUnlock) == 0 {
			// Increment the largestGuardID atomically and assign it to gID
			gID := atomic.AddInt64(&g.largestGuardID, 1)
			// Swamp the new guard ID to the waitForUnlock slice
			g.waitForUnlock = append(g.waitForUnlock, gID)
			if len(bodyAuthID) > 0 {
				g.bodyAuthID = bodyAuthID[0]
			}
			// Return the guard ID
			return ID(gID)
		}
	}

	// If not waiting and there are other guards waiting, return 0
	return ID(0)
}

// ReleaseTreasureGuard releases the transaction on the Treasure for the given guardID.
// It also notifies all waiting goroutines that the Treasure is now unlocked.
func (g *guard) ReleaseTreasureGuard(guardID ID) {

	g.cond.L.Lock()
	defer func() {
		g.cond.L.Unlock()
	}()

	if len(g.waitForUnlock) > 0 && g.waitForUnlock[0] == int64(guardID) {
		g.waitForUnlock = g.waitForUnlock[1:]
		if len(g.waitForUnlock) == 0 {
			atomic.StoreInt64(&g.largestGuardID, 0)
		}
		g.cond.Broadcast()
		return
	}

}

// CanExecute checks if the given guardID is the first in the queue.
// If it's not, the function panics, indicating a critical programming error.
// it will also check if the bodyAuthID is the same as the one that was used to transaction the Treasure.
// It will return error only if the bodyAuthID is not the same as the one that was used to transaction the Treasure and the
// function is a body function.... otherwise it will return nil.
func (g *guard) CanExecute(guardID ID, isBodyFunction ...bool) error {
	g.cond.L.Lock()
	defer g.cond.L.Unlock()
	if len(isBodyFunction) > 0 && isBodyFunction[0] {
		if g.bodyAuthID != BodyAuthID {
			return errors.New("can not execute body function, the bodyAuthID is not correct")
		}
	}
	if g.waitForUnlock[0] != int64(guardID) {
		return errors.New("the given guardID is not the first in the queue - execution aborted")
	}
	return nil
}

--------------------------------------------------------------------------------

/==============================================================================\
| FILE: core\hydra\swamp\treasure\guard\guard_test.go
| PATH: C:\go\src\hydraide\app\core\hydra\swamp\treasure\guard\guard_test.go
| SIZE: 2.5 KB
\==============================================================================/

package guard

import (
	"sync"
	"testing"
)

// MyObject is a sample object that uses the Guard interface to ensure
// thread-safe access to its parameters.
type MyObject struct {
	Guard
	firstParam  int
	secondParam int
}

// NewMyObject initializes a new MyObject with a Guard.
func NewMyObject() *MyObject {
	return &MyObject{
		Guard: New(),
	}
}

// IncreaseFirstParam safely increments the firstParam field.
// It uses the Guard to ensure that only one goroutine can execute this method at a time.
func (o *MyObject) IncreaseFirstParam(lockerID ID) {
	_ = o.Guard.CanExecute(lockerID)
	o.firstParam++
}

// IncreaseSecondParam safely increments the secondParam field.
// It uses the Guard to ensure that only one goroutine can execute this method at a time.
func (o *MyObject) IncreaseSecondParam(lockerID ID) {
	_ = o.Guard.CanExecute(lockerID)
	o.secondParam++
}

// TestNew tests the NewMyObject function and the Guard implementation.
// It spawns 1000 goroutines that try to increment the parameters of a shared MyObject instance.
func TestNew(t *testing.T) {

	myObject := NewMyObject()

	wg := sync.WaitGroup{}
	for i := 0; i < 1000; i++ {
		wg.Add(1)
		go func(i int, myObject *MyObject) {
			lockerID := myObject.StartTreasureGuard(true)
			myObject.IncreaseFirstParam(lockerID)
			myObject.IncreaseSecondParam(lockerID)
			myObject.ReleaseTreasureGuard(lockerID)
			wg.Done()
		}(i, myObject)
	}

	wg.Wait()
}

// BenchmarkNew benchmarks the Guard implementation.
// It measures the time it takes to acquire and release a transaction using the Guard.
// goos: windows
// goarch: amd64
// cpu: AMD Ryzen 9 5950X 16-Core Processor
//
// BenchmarkNew
// BenchmarkNew-26         28281244                41.98 ns/op
// PASS
//
// goos: linux
// goarch: amd64
// pkg: github.com/hydraide/hydraide/app/core/hydra/swamp/treasure/guard
// cpu: AMD Ryzen 9 5950X 16-Core Processor
//
// BenchmarkNew
// BenchmarkNew-32    	30823390	        54.59 ns/op
// goos: linux
// goarch: amd64
// pkg: github.com/hydraide/hydraide/app/core/hydra/swamp/treasure/guard
// cpu: AMD Ryzen 9 5950X 16-Core Processor
// BenchmarkNew
// BenchmarkNew-32    	24532616	        66.54 ns/op
// PASS
func BenchmarkNew(b *testing.B) {
	myObject := NewMyObject()
	for i := 0; i < b.N; i++ {
		lockerID := myObject.StartTreasureGuard(true)
		if lockerID == 0 {
			continue
		} else {
			_ = myObject.CanExecute(lockerID)
			myObject.ReleaseTreasureGuard(lockerID)
		}
	}
}

--------------------------------------------------------------------------------

/==============================================================================\
| FILE: core\hydra\swamp\treasure\treasure.go
| PATH: C:\go\src\hydraide\app\core\hydra\swamp\treasure\treasure.go
| SIZE: 82.5 KB
\==============================================================================/

package treasure

import (
	"bytes"
	"encoding/binary"
	"encoding/gob"
	"fmt"
	"github.com/hydraide/hydraide/app/core/hydra/swamp/treasure/guard"
	"reflect"
	"sync"
	"time"
)

// Treasure represents a single piece of data in a swamp, along with a set of
// operations that can be executed upon it. It's designed to be concurrency-safe
// and to ensure the correct sequence of operations on the data.
//
// Most of the methods in Treasure interface require a guardID which is
// provided by the Guard interface. This ensures that the methods are
// executed in the order they were called by different goroutines.
type Treasure interface {

	// -------------------------- HEAD FUNCTIONS -------------------------- //
	// Head function are functions that are used by the Had and the Body of the Hydra as well

	// Guard is a function that is used to protect the treasure from being modified by other goroutines
	//
	// As you can see, we use the guardID for every function call except for the GetKey function.
	// The Guard object and the GuardID ensure that a given function, e.g. CloneContent, runs only when
	// another goroutine is not using it. The Guard is not a standard sync.Mutex, but a special object that not
	// only prevents another routine from accessing a single treasure at the same time, but also establishes an
	// order, as it's very important in databases to have calling routines modify or access information in the
	// order they were called. For example, if a user wants to top up their balance, we first top it up, and then
	// they can purchase anything from their balance. If the two routines come in almost simultaneously, the regular
	// Sync package doesn't guarantee that the order would necessarily be top-up followed by purchase. That's why we
	// use the Guard to protect the data and also ensure the correct sequence.
	guard.Guard

	Clone(guardID guard.ID) Treasure

	// GetKey returns the unique key identifying the treasure in the database.
	//
	// GetKey is an exception to the guard protection rule, and can be called without
	// acquiring a guardID from Guard interface. This is because reading the key is
	// considered a non-mutating and non-order-sensitive operation.
	//
	// Example:
	//     treasure := acquireTreasureFromDB("someKey")
	//     key := treasure.GetKey()
	//     fmt.Println("The key is:", key)
	//
	// Use-cases:
	// 1. Fetching the key for logging or debugging purposes.
	// 2. Using the key to index into other data structures or databases.
	// 3. Passing the key to other services or components that need to identify the treasure.
	GetKey() string

	// IsDifferentFrom returns true if the content of the treasure is different from the content of the otherTreasure.
	// This function is useful for comparing two treasures to determine if they are different.
	//
	// This function requires a guardID, which ensures that the method
	// is executed in a concurrency-safe manner and in the sequence
	// it was called among other methods that require a guardID.
	//
	// To acquire and release a guardID, use the Guard interface's
	// StartTreasureGuard and ReleaseTreasureGuard methods, respectively.
	//
	// Example:
	//     ...
	//
	//     treasure := swamp.GetTreasure("someKey")
	//     guardID := treasure.StartTreasureGuard()
	//     isDifferent := treasure.IsDifferentFrom(guardID, otherTreasure)
	//     treasure.ReleaseTreasureGuard(guardID)
	//     fmt.Println("The content is different:", isDifferent)
	//
	// Use-cases:
	// 1. To determine if the content of a treasure has changed.
	// 2. To perform conditional logic based on whether the content is different.
	IsDifferentFrom(guardID guard.ID, otherTreasure Treasure) bool

	// GetContentType returns the type of content stored in the treasure.
	//
	// This function requires a guardID, which ensures that the method
	// is executed in a concurrency-safe manner and in the sequence
	// it was called among other methods that require a guardID.
	//
	// Example:
	//     ...
	//
	//     treasure := swamp.GetTreasure("someKey")
	//     contentType := treasure.GetContentType()
	//     fmt.Println("The content type is:", contentType)
	//
	// Use-cases:
	// 1. To perform conditional logic based on the content type.
	// 2. To log or debug the type of content being worked upon.
	// 3. To facilitate type-specific serialization or deserialization processes.
	GetContentType() ContentType

	// GetCreatedAt returns the UnixNano timestamp marking the creation time of the treasure.
	// This is useful for auditing, tracking life cycle, and time-sensitive operations on the treasure.
	//
	//
	// Example:
	//     treasure := swamp.GetTreasure("someKey")
	//     creationTime := treasure.GetCreatedAt()
	//     fmt.Println("The treasure was created at:", time.Unix(0, creationTime))
	//
	// Use-cases:
	// 1. For auditing purposes to know when the treasure was created.
	// 2. To implement time-based expiration policies.
	// 3. To sort or filter treasures based on their age.
	GetCreatedAt() int64

	// GetCreatedBy returns the userID of the entity who created the treasure.
	// This method can help in situations where ownership or creatorship information is necessary for
	// authorization or auditing. If the treasure is system-generated, or if the CreatedBy field is not set,
	// this method returns an empty string.
	//
	// Example:
	//     treasure := swamp.GetTreasure("someKey")
	//     creator := treasure.GetCreatedBy()
	//     fmt.Println("The treasure was created by:", creator)
	//
	// Use-cases:
	// 1. Auditing who created specific treasures.
	// 2. Implementing ownership-based access controls.
	// 3. Data analytics related to user-generated treasures.
	GetCreatedBy() string

	// GetDeletedAt returns the UnixNano timestamp indicating when the treasure was deleted.
	// This can be useful for auditing or record-keeping. If the treasure has not been deleted, this method
	// returns 0. To ensure a synchronized and safe access, a guardID obtained from StartTreasureGuard is
	// necessary.
	//
	// It is crucial to release the guardID after its use with the method ReleaseTreasureGuard to avoid
	// locking the treasure for future access.
	//
	// Example:
	//     treasure := swamp.GetTreasure("someKey")
	//     deletionTime := treasure.GetDeletedAt()
	//     if deletionTime == 0 {
	//         fmt.Println("The treasure has not been deleted.")
	//     } else {
	//         fmt.Println("The treasure was deleted at:", deletionTime)
	//     }
	//
	// Use-cases:
	// 1. Auditing or record-keeping of when specific treasures were deleted.
	// 2. Conditional logic based on whether a treasure has been deleted.
	// 3. Data analytics related to treasure lifecycle.
	GetDeletedAt() int64

	// GetDeletedBy returns the userID of the user who deleted the treasure.
	// This function is useful for auditing or identifying who performed the deletion action.
	// The method returns an empty string if the treasure hasn't been deleted yet, or if the DeletedBy field
	// was not set during the deletion process.
	//
	// A guardID, obtained via the StartTreasureGuard method, is required for synchronized and safe access.
	//
	// It's important to release the guardID using the method ReleaseTreasureGuard to ensure that the
	// treasure can be accessed by others in the future.
	//
	// Example:
	//     treasure := swamp.GetTreasure("someKey")
	//     deletedBy := treasure.GetDeletedBy()
	//     if deletedBy == "" {
	//         fmt.Println("The treasure has not been deleted, or the deleter is not specified.")
	//     } else {
	//         fmt.Println("The treasure was deleted by:", deletedBy)
	//     }
	//
	// Use-cases:
	// 1. Auditing to find out who deleted specific treasures.
	// 2. Implementing business logic that varies depending on the user who deleted the treasure.
	// 3. Providing informative logs or analytics data.
	GetDeletedBy() string

	// GetShadowDelete returns true if the treasure has been shadow-deleted.
	GetShadowDelete() bool

	// GetModifiedAt returns the UnixNano timestamp of the last modification made to the treasure.
	// This function is useful for tracking changes and understanding the state of the treasure over time.
	// The method returns 0 if the treasure has not been modified since its creation.
	//
	// Example:
	//     treasure := swamp.GetTreasure("someKey")
	//     modifiedAt := treasure.GetModifiedAt()
	//     if modifiedAt == 0 {
	//         fmt.Println("The treasure has not been modified yet.")
	//     } else {
	//         fmt.Println("The treasure was last modified at UnixNano time:", modifiedAt)
	//     }
	//
	// Use-cases:
	// 1. For auditing and change tracking of treasures.
	// 2. To implement caching mechanisms that rely on last modification time.
	// 3. To provide a historical context in analytics or dashboards.
	GetModifiedAt() int64

	// GetModifiedBy returns the userID of the individual who last modified the treasure.
	// This function serves as a means to track who last made changes to the treasure, thus aiding in auditing and accountability.
	// The returned string will be empty if the treasure has not been modified or if the ModifiedBy field is not set.
	//
	// Example:
	//     treasure := swamp.GetTreasure("someKey")
	//     modifiedBy := treasure.GetModifiedBy()
	//     if modifiedBy == "" {
	//         fmt.Println("The treasure has not been modified yet or the ModifiedBy field is not set.")
	//     } else {
	//         fmt.Println("The treasure was last modified by:", modifiedBy)
	//     }
	//
	// Use-cases:
	// 1. For auditing purposes, to know who last modified the treasure.
	// 2. To implement permissions and role-based access control.
	// 3. To facilitate communication within a team by knowing who to reach out to about specific changes.
	GetModifiedBy() string

	// GetExpirationTime returns the expiration time of the treasure in UnixNano format.
	// This function is used to determine when a particular treasure will expire and become eligible for specific tasks or removal.
	// Example:
	//     treasure := swamp.GetTreasure("someKey")
	//     expirationTime := treasure.GetExpirationTime()
	//
	//     if expirationTime == 0 {
	//         fmt.Println("The treasure does not have an expiration time set.")
	//     } else {
	//         fmt.Println("The treasure will expire at:", expirationTime)
	//     }
	//
	// Use-cases:
	// 1. To implement rate limiting, for example, not accessing a website more frequently than every 10 seconds.
	// 2. To perform actions only after a certain period has elapsed.
	// 3. To clean up or recycle resources that are no longer needed after their expiration.
	GetExpirationTime() int64

	// IsExpired returns true if the treasure's ExpirationTime is set and the current time is greater than the ExpirationTime.
	// IsExpired returns false if the ExpirationTime is not set or if the current time is less than the ExpirationTime.
	// This function allows for quick checks to determine if a treasure should no longer be utilized or accessed.
	//
	// It's imperative to release the guardID using the ReleaseTreasureGuard method, ensuring that the treasure remains accessible to others.
	//
	// Example:
	//     treasure := swamp.GetTreasure("someKey")
	//     if treasure.IsExpired() {
	//         fmt.Println("The treasure is expired.")
	//     } else {
	//         fmt.Println("The treasure is not expired.")
	//     }
	//
	// Use-cases:
	// 1. To prevent making API calls or resource-consuming operations on expired treasures.
	// 2. To execute cleanup routines selectively.
	// 3. For decision-making in conditional logic where expiration is a key factor.
	IsExpired() bool

	// GetContentString returns the content of the treasure as a string.
	// This function allows for type-safe retrieval of string data stored within the treasure.
	//
	// The function returns an error if the content type is not a string.
	// If the content is nil, the function will return an empty string but the error will be nil.
	//
	// Example:
	//     treasure := swamp.GetTreasure("someKey")
	//     content, err := treasure.GetContentString()
	//     if err != nil {
	//         fmt.Println("Error:", err)
	//     } else {
	//         fmt.Println("Content:", content)
	//     }
	//
	// Use-cases:
	// 1. When we need to selectively read string data without wanting to deal with type assertions.
	// 2. For avoiding run-time panics due to incorrect type assertions.
	// 3. In applications where string data types are frequently used and must be safely accessed.
	GetContentString() (string, error)

	// GetContentUint8 returns the content of the treasure as a uint8.
	// Returns an error if the content type is not uint8. If the content is nil, it returns 0 with no error.
	GetContentUint8() (uint8, error)
	// GetContentUint16 returns the content of the treasure as a uint16.
	// Returns an error if the content type is not uint16. If the content is nil, it returns 0 with no error.
	GetContentUint16() (uint16, error)
	// GetContentUint32 returns the content of the treasure as a uint32.
	// Returns an error if the content type is not uint32. If the content is nil, it returns 0 with no error.
	GetContentUint32() (uint32, error)
	// GetContentUint64 returns the content of the treasure as a uint64.
	// Returns an error if the content type is not uint64. If the content is nil, it returns 0 with no error.
	GetContentUint64() (uint64, error)
	// GetContentInt8 returns the content of the treasure as an int8.
	// Returns an error if the content type is not int8. If the content is nil, it returns 0 with no error.
	GetContentInt8() (int8, error)
	// GetContentInt16 returns the content of the treasure as an int16.
	// Returns an error if the content type is not int16. If the content is nil, it returns 0 with no error.
	GetContentInt16() (int16, error)
	// GetContentInt32 returns the content of the treasure as an int32.
	// Returns an error if the content type is not int32. If the content is nil, it returns 0 with no error.
	GetContentInt32() (int32, error)
	// GetContentInt64 returns the content of the treasure as an int64.
	// Returns an error if the content type is not int64. If the content is nil, it returns 0 with no error.
	GetContentInt64() (int64, error)
	// GetContentFloat32 returns the content of the treasure as a float32.
	// Returns an error if the content type is not float32. If the content is nil, it returns 0.0 with no error.
	GetContentFloat32() (float32, error)
	// GetContentFloat64 returns the content of the treasure as a float64.
	// Returns an error if the content type is not float64. If the content is nil, it returns 0.0 with no error.
	GetContentFloat64() (float64, error)

	// Uint32SliceGetAll returns all stored uint32 values in the Uint32Slice.
	// This function retrieves the entire slice as a Uint32Slice type, ensuring that
	// the stored data remains structured in 4-byte aligned uint32 blocks.
	//
	// Returns an error if the content type is invalid or the slice is uninitialized.
	//
	// Example:
	//     slice, err := treasure.Uint32SliceGetAll()
	//     if err != nil {
	//         fmt.Println("Error:", err)
	//     } else {
	//         fmt.Println("Stored values:", slice)
	//     }
	//
	// Use cases:
	// - When an application needs to perform set operations on the stored uint32 values.
	// - To retrieve all associated domain IDs or unique identifiers efficiently.
	Uint32SliceGetAll() ([]uint32, error)

	// Uint32SlicePush adds one or more uint32 values to the Uint32Slice.
	// This function ensures that duplicate values are not inserted, preserving the integrity
	// of the stored set. Each uint32 value is stored in a compact 4-byte format.
	//
	// If the slice does not exist, it initializes it before appending new values.
	//
	// Returns an error if the operation fails due to memory constraints or internal inconsistencies.
	//
	// Example:
	//     err := treasure.Uint32SlicePush([]uint32{123456, 789012})
	//     if err != nil {
	//         fmt.Println("Error adding values:", err)
	//     }
	//
	// Use cases:
	// - Efficiently indexing new uint32 values without duplicates.
	// - Preventing redundant storage of identifiers in memory-sensitive applications.
	Uint32SlicePush([]uint32) error

	// Uint32SliceDelete removes specific uint32 values from the Uint32Slice.
	// This function scans the slice and removes occurrences of the specified values,
	// ensuring that the remaining data remains intact.
	//
	// If a value is not found, it is simply ignored. The function restructures the slice
	// to maintain a continuous 4-byte aligned structure.
	//
	// Returns an error if the operation encounters an issue, such as invalid data formatting.
	//
	// Example:
	//     err := treasure.Uint32SliceDelete([]uint32{123456})
	//     if err != nil {
	//         fmt.Println("Error deleting values:", err)
	//     }
	//
	// Use cases:
	// - Dynamically managing uint32-based identifiers, such as domain indexes or lookup keys.
	// - Reducing storage size by eliminating unnecessary or outdated values.
	Uint32SliceDelete([]uint32) error

	// Uint32SliceSize returns the number of uint32 values stored in the Uint32Slice.
	// Since each value is stored in 4 bytes, the size is computed as `len(slice) / 4`.
	//
	// If the slice is empty or uninitialized, it returns 0 without an error.
	//
	// Example:
	//     count, err := treasure.Uint32SliceSize()
	//     if err != nil {
	//         fmt.Println("Error retrieving size:", err)
	//     } else {
	//         fmt.Println("Total stored values:", count)
	//     }
	//
	// Use cases:
	// - Checking if a Uint32Slice is empty before performing operations.
	// - Monitoring storage efficiency by tracking the number of stored uint32 identifiers.
	Uint32SliceSize() (int, error)

	// GetContentBool returns the content of the treasure as a boolean.
	// This function provides a type-safe way to retrieve boolean data stored within the treasure.
	//
	// The function returns an error if the content type is not a boolean.
	// If the content is nil, the function will return false, but the error will be nil.
	// Example:
	//     treasure := swamp.GetTreasure("someKey")
	//
	//     content, err := treasure.GetContentBool()
	//     if err != nil {
	//         fmt.Println("Error:", err)
	//     } else {
	//         fmt.Println("Content:", content)
	//     }
	// Use-cases:
	// 1. When the application needs to selectively read boolean data without dealing with type assertions.
	// 2. To avoid run-time panics that can occur with incorrect type assertions.
	// 3. In feature flags, settings, or condition checks where boolean values control application behavior.
	GetContentBool() (bool, error)

	// GetContentByteArray retrieves the content of the treasure as a byte array.
	// This method is particularly useful for storing and retrieving large datasets or binary files within a treasure.
	//
	// The method returns an error if the content type is not a byte array.
	// If the content is nil, the returned byte array will also be nil, but the error will be nil.
	// Example:
	//     treasure := swamp.GetTreasure("fileKey")
	//
	//     byteArray, err := treasure.GetContentByteArray()
	//     if err != nil {
	//         fmt.Println("Error:", err)
	//     } else {
	//         fmt.Println("Retrieved byte array:", byteArray)
	//     }
	//
	// Use-cases:
	// 1. Storing and retrieving binary files like images, audio, or executables.
	// 2. Handling large chunks of data that are best represented in raw byte form.
	// 3. For optimal performance when handling data that doesn't need to be parsed or altered.
	GetContentByteArray() ([]byte, error)

	// CloneContent returns a copy of the content of the treasure, decoupled from
	// the original treasure. This means any modifications made to the returned
	// content will not affect the original treasure's content.
	//
	// This function requires a guardID for concurrency-safe access to the treasure.
	// Obtaining a guardID and not releaseing it can result in locking the treasure
	// from future accesses.
	//
	// Example:
	//     treasure := swamp.GetTreasure("someKey")
	//     guardID := treasure.StartTreasureGuard()
	//
	//     clonedContent := treasure.CloneContent(guardID)
	//
	//     treasure.ReleaseTreasureGuard(guardID)
	//     // Now, clonedContent can be modified without affecting the original treasure's content.
	//
	// Use-cases:
	// 1. To perform operations on the content without affecting the original treasure.
	// 2. To generate a snapshot of the content for backup or versioning.
	// 3. To simplify operations that require the content but not the treasure itself.
	CloneContent(guardID guard.ID) Content

	// SetContent replaces the content of the treasure with the specified content,
	// decoupled from the original treasure. This means any modifications made to
	// the original content will not affect the new content set by this function.
	//
	// This function requires a guardID for concurrency-safe access to the treasure.
	// Obtaining a guardID and not releaseing it can result in locking the treasure
	// from future accesses.
	//
	// IMPORTANT: Use this function only if the new content has been obtained using
	// the CloneContent method. If not, consider using specialized setter methods like
	// SetContentByteArray instead.
	//
	// Example:
	//     treasure := swamp.GetTreasure("someKey")
	//     guardID := treasure.StartTreasureGuard()
	//
	//     // First, clone the content
	//     clonedContent := treasure.CloneContent(guardID)
	//
	//     // Perform operations on clonedContent
	//
	//     // Now, replace the original content with the modified cloned content
	//     treasure.SetContent(guardID, clonedContent)
	//
	//     treasure.ReleaseTreasureGuard(guardID)
	//     // The original content has been replaced by clonedContent, and can now be
	//     // independently modified.
	//
	// Use-cases:
	// 1. To replace the content after having performed certain operations on a cloned version.
	// 2. To update the content in a concurrency-safe manner.
	// 3. To maintain versioning or backups by replacing content only when it's confirmed to be safe.
	//
	SetContent(guardID guard.ID, content Content)

	// SetExpirationTime sets a future expiration time for the treasure.
	SetExpirationTime(guardID guard.ID, expirationTime time.Time)

	// SetContentVoid sets the content of the treasure to nil.
	// This effectively wipes the existing content, freeing up storage and resetting the state.
	// A guardID, which can be obtained via the StartTreasureGuard method, is required to synchronize and secure access to the treasure.
	//
	// Example:
	//     treasure := swamp.GetTreasure("someKey")
	//     guardID := treasure.StartTreasureGuard()
	//
	//     treasure.SetContentVoid(guardID)
	//
	// Use-cases:
	// 1. Deleting a dataset but keeping the treasure itself for future use.
	// 2. Temporarily disabling a treasure without removing it from the system.
	// 3. Resource management, e.g., releasing memory or storage when the content is no longer needed.
	SetContentVoid(guardID guard.ID)

	// ResetContentVoid resets the 'ContentTypeVoid' field of the treasure's content to false.
	// This method should be called whenever the content type of the treasure changes from 'ContentTypeVoid' to any other type.
	// A guardID, which can be obtained via the StartTreasureGuard method, is required to synchronize and secure access to the treasure.
	//
	// Warning:
	// If you change the content from 'ContentTypeVoid' to any other type, it is imperative to call this function to ensure proper behavior.
	//
	// Example:
	//     treasure := swamp.GetTreasure("someKey")
	//     guardID := treasure.StartTreasureGuard()
	//
	//     treasure.SetContentInt64(guardID, 42)  // Content changes from 'ContentTypeVoid' to 'ContentTypeInt64'
	//     treasure.ResetContentVoid(guardID)  // Must be called to reset the 'ContentTypeVoid' status
	//
	//     treasure.ReleaseTreasureGuard(guardID)
	//
	// Use-cases:
	// 1. Ensuring that the treasure's content type is correctly reset when changing from 'ContentTypeVoid' to any other type.
	// 2. Resource management, e.g., making sure that the treasure's state is consistent.
	ResetContentVoid(guardID guard.ID)

	// SetContentString sets the content of the treasure to a string value.
	// A guardID, which can be obtained via the StartTreasureGuard method, is required to synchronize and secure access to the treasure.
	//
	// Example:
	//     treasure := swamp.GetTreasure("someKey")
	//     guardID := treasure.StartTreasureGuard()
	//
	//     treasure.SetContentString(guardID, "Hello, world!")  // Content is set to a string
	//
	//     treasure.ReleaseTreasureGuard(guardID)
	//
	// Use-cases:
	// 1. Updating or assigning a string value to the treasure's content.
	// 2. Data population, especially when the treasure's previous content type is not a string.
	SetContentString(guardID guard.ID, content string)

	// ResetContentString resets the 'ContentTypeString' field of the treasure's content to nil.
	// This method should be called whenever the content type of the treasure changes from 'ContentTypeString' to any other type.
	// A guardID, which can be obtained via the StartTreasureGuard method, is required to synchronize and secure access to the treasure.
	//
	// Warning:
	// If you change the content from 'ContentTypeString' to any other type, it is imperative to call this function to ensure proper behavior.
	//
	// Example:
	//     treasure := swamp.GetTreasure("someKey")
	//     guardID := treasure.StartTreasureGuard()
	//
	//     treasure.SetContentInt64(guardID, 42)  // Content changes from 'ContentTypeString' to 'ContentTypeInt64'
	//     treasure.ResetContentString(guardID)  // Must be called to reset the 'ContentTypeString' status
	//
	//     treasure.ReleaseTreasureGuard(guardID)
	//
	// Use-cases:
	// 1. Ensuring that the treasure's content type is correctly reset when changing from 'ContentTypeString' to any other type.
	// 2. Resource management, e.g., making sure that the treasure's state is consistent.
	ResetContentString(guardID guard.ID)

	SetContentUint8(guardID guard.ID, content uint8)
	SetContentUint16(guardID guard.ID, content uint16)
	SetContentUint32(guardID guard.ID, content uint32)
	SetContentUint64(guardID guard.ID, content uint64)
	SetContentInt8(guardID guard.ID, content int8)
	SetContentInt16(guardID guard.ID, content int16)
	SetContentInt32(guardID guard.ID, content int32)
	SetContentInt64(guardID guard.ID, content int64)

	ResetContentUint8(guardID guard.ID)
	ResetContentUint16(guardID guard.ID)
	ResetContentUint32(guardID guard.ID)
	ResetContentUint64(guardID guard.ID)
	ResetContentInt8(guardID guard.ID)
	ResetContentInt16(guardID guard.ID)
	ResetContentInt32(guardID guard.ID)
	ResetContentInt64(guardID guard.ID)

	ResetContentUint32Slice(guardID guard.ID)

	SetContentFloat32(guardID guard.ID, content float32)
	SetContentFloat64(guardID guard.ID, content float64)

	ResetContentFloat32(guardID guard.ID)
	ResetContentFloat64(guardID guard.ID)

	// SetContentBool sets the content of the treasure to a boolean value.
	// A guardID, which can be obtained via the StartTreasureGuard method, is required to synchronize and secure access to the treasure.
	//
	// Example:
	//     treasure := swamp.GetTreasure("someKey")
	//     guardID := treasure.StartTreasureGuard()
	//
	//     treasure.SetContentBool(guardID, true)  // Content is set to boolean
	//
	//     treasure.ReleaseTreasureGuard(guardID)
	//
	// Use-cases:
	// 1. Updating or assigning a boolean value to the treasure's content.
	// 2. Data population, especially when the treasure's previous content type is not boolean.
	SetContentBool(guardID guard.ID, content bool)

	// ResetContentBool resets the 'Bool' field of the treasure's content to nil.
	// This method should be called whenever the content type of the treasure changes from 'Bool' to any other type.
	// A guardID, which can be obtained via the StartTreasureGuard method, is required to synchronize and secure access to the treasure.
	//
	// Warning:
	// If you change the content from 'Bool' to any other type, it is imperative to call this function to ensure proper behavior.
	//
	// Example:
	//     treasure := swamp.GetTreasure("someKey")
	//     guardID := treasure.StartTreasureGuard()
	//
	//     treasure.SetContentInt64(guardID, 42)  // Content changes from 'Bool' to 'ContentTypeInt64'
	//     treasure.ResetContentBool(guardID)  // Must be called to reset the 'Bool' status
	//
	//     treasure.ReleaseTreasureGuard(guardID)
	//
	// Use-cases:
	// 1. Ensuring that the treasure's content type is correctly reset when changing from 'Bool' to any other type.
	// 2. Resource management, e.g., making sure that the treasure's state is consistent.
	ResetContentBool(guardID guard.ID)

	// SetContentByteArray sets the content of the treasure to a byte array.
	// A guardID, which can be obtained via the StartTreasureGuard method, is required to synchronize and secure access to the treasure.
	//
	// Example:
	//     treasure := swamp.GetTreasure("someKey")
	//     guardID := treasure.StartTreasureGuard()
	//
	//     byteArrayContent := []byte{0x01, 0x02, 0x03}
	//     treasure.SetContentByteArray(guardID, byteArrayContent)  // Content is set to a byte array
	//
	//     treasure.ReleaseTreasureGuard(guardID)
	//
	// Use-cases:
	// 1. Updating or assigning a byte array value to the treasure's content.
	// 2. Data population, especially when the treasure's previous content type is not a byte array.
	SetContentByteArray(guardID guard.ID, content []byte)

	// ResetContentByteArray resets the 'ContentTypeByteArray' field of the treasure's content to nil.
	// This method should be called whenever the content type of the treasure changes from 'ContentTypeByteArray' to any other type.
	// A guardID, which can be obtained via the StartTreasureGuard method, is required to synchronize and secure access to the treasure.
	//
	// Warning:
	// If you change the content from 'ContentTypeByteArray' to any other type, it is imperative to call this function to ensure proper behavior.
	//
	// Example:
	//     treasure := swamp.GetTreasure("someKey")
	//     guardID := treasure.StartTreasureGuard()
	//
	//     treasure.SetContentString(guardID, "new value")       // Content changes from 'ContentTypeByteArray' to 'ContentTypeString'
	//     treasure.ResetContentByteArray(guardID)              // Must be called to reset the 'ContentTypeByteArray' status
	//
	//     treasure.ReleaseTreasureGuard(guardID)
	//
	// Use-cases:
	// 1. Ensuring that the treasure's content type is correctly reset when changing from 'ContentTypeByteArray' to any other type.
	// 2. Resource management, e.g., making sure that the treasure's state is consistent.
	ResetContentByteArray(guardID guard.ID)

	// SetCreatedAt sets the UnixNano timestamp marking the creation time of the Treasure.
	// This optional method enriches the Treasure metadata, offering more granularity in
	// data tracking and potential auditing or versioning capabilities.
	//
	// A guardID, obtainable via the StartTreasureGuard method, is required for synchronized and secure access.
	//
	// Example:
	//     treasure := swamp.GetTreasure("someKey")
	//     guardID := treasure.StartTreasureGuard()
	//
	//     treasure.SetCreatedAt(guardID)  // Automatically sets the creation time to the current time in UnixNano
	//
	//     treasure.ReleaseTreasureGuard(guardID)
	//
	// Use-cases:
	// 1. Auditing and tracking of data creation.
	// 2. Historical data versioning and management.
	//
	// Note: The method automatically assigns the current UnixNano timestamp as the creation time.
	//
	// This is an optional field. Developers are encouraged to use it where applicable for better data governance.
	SetCreatedAt(guardID guard.ID, createdAt time.Time)

	// SetModifiedAt sets the UnixNano timestamp marking the last modification time of the Treasure.
	// This optional method is particularly useful for tracking data changes over time, potentially aiding
	// in debugging, auditing, or other operational insights.
	//
	// A guardID, obtainable via the StartTreasureGuard method, is required for synchronized and secure access.
	//
	// Example:
	//     treasure := swamp.GetTreasure("someKey")
	//     guardID := treasure.StartTreasureGuard()
	//
	//     treasure.SetModifiedAt(guardID)  // Automatically sets the modification time to the current time in UnixNano
	//
	//     treasure.ReleaseTreasureGuard(guardID)
	//
	// Use-cases:
	// 1. Auditing and tracking of data modification.
	// 2. Historical data versioning and management.
	//
	// Note: The method automatically assigns the current UnixNano timestamp as the modification time.
	//
	// This is an optional field. Developers are encouraged to use it where applicable for better data governance.
	SetModifiedAt(guardID guard.ID, modifiedAt time.Time)

	// SetCreatedBy sets the creator ID and the current time as the creation time of the treasure.
	// This function is optional but recommended to use for better user operation tracking.
	// A guardID, which can be obtained via the StartTreasureGuard method, is required to synchronize and secure access to the treasure.
	//
	// Note:
	// If you are storing large data sets like logs where user information is not crucial, you can skip calling this method to save storage space.
	//
	// Example:
	//     treasure := swamp.GetTreasure("someKey")
	//     guardID := treasure.StartTreasureGuard()
	//
	//     treasure.SetCreatedBy(guardID, "userID123")  // Sets the creator ID and the creation time
	//
	//     treasure.ReleaseTreasureGuard(guardID)
	//
	// Use-cases:
	// 1. To identify who created the treasure.
	// 2. For auditing and tracking purposes.
	SetCreatedBy(guardID guard.ID, createdBy string)

	// SetModifiedBy sets the modifier ID and the current time as the modified time of the treasure.
	// This function is optional but recommended to use for better user operation tracking.
	// A guardID, which can be obtained via the StartTreasureGuard method, is required to synchronize and secure access to the treasure.
	//
	// Note:
	// If you are storing large data sets like logs where user information is not crucial, you can skip calling this method to save storage space.
	//
	// Example:
	//     treasure := swamp.GetTreasure("someKey")
	//     guardID := treasure.StartTreasureGuard()
	//
	//     treasure.SetModifiedBy(guardID, "userID456")  // Sets the modifier ID and the modification time
	//
	//     treasure.ReleaseTreasureGuard(guardID)
	//
	// Use-cases:
	// 1. To identify who last modified the treasure.
	// 2. For auditing and tracking purposes.
	SetModifiedBy(guardID guard.ID, modifiedBy string)

	// LoadFromClone loads the Treasure from a Clone.
	// This function is used by the Hydra Body to load the Treasure from a Clone.
	LoadFromClone(guardID guard.ID, clone Treasure)

	// Save saves the Treasure to the file system.
	Save(guardID guard.ID) TreasureStatus

	CheckIfContentChanged(newContent *Content) bool

	IsContentChanged() bool

	IsContentTypeChanged() bool
	IsExpirationTimeChanged() bool
	IsCreatedAtChanged() bool
	IsCreatedByChanged() bool
	IsDeletedAtChanged() bool
	IsDeletedByChanged() bool
	IsModifiedAtChanged() bool
	IsModifiedByChanged() bool

	// -------------------------- BODY FUNCTIONS -------------------------- //
	// System function are functions that are used by the system and should not be used by the Head of the Hydra

	// GetFileName returns the name of the file where the Treasure is stored.
	// The string pointer will be nil if the treasure is not stored in a file yet and resides only in memory.
	// This function is not accessible from Head Plugins.
	//
	// Example:
	//     treasure := swamp.GetTreasure("someKey")
	//     fileName := treasure.GetFileName()  // Retrieves the file name or nil
	//
	// Use-cases:
	// 1. For internal system-level auditing or tracking.
	// 2. To diagnose issues with file storage.
	GetFileName() *string

	// BodySetFileName sets the file name where the Treasure is stored.
	// This function is not accessible from Head Plugins.
	//
	// A guardID, which can be obtained via the StartTreasureGuard method, is required to synchronize and secure access to the treasure.
	//
	// Example:
	//     treasure := swamp.GetTreasure("someKey")
	//     guardID := treasure.StartTreasureGuard()
	//
	//     treasure.SetFileName(guardID, "newFile.txt")  // Sets the file name
	//
	//     treasure.ReleaseTreasureGuard(guardID)
	//
	// Use-cases:
	// 1. To explicitly specify where the treasure will be stored in the file system.
	// 2. To manage the organization and naming of treasures in persistent storage.
	BodySetFileName(guardID guard.ID, fileName string)

	// BodySetForDeletion sets the treasure for deletion.
	// This function marks the treasure as deleted by setting various fields: `DeletedAt` and `DeletedBy`.
	// It can optionally remove the content and expiration time based on the `shadowDelete` parameter.
	//
	// The `shadowDelete` parameter determines whether the content and expiration time should be removed:
	// - If `shadowDelete` is set to `true`, the treasure will be marked as deleted, but its content and expiration time
	//   will remain intact, allowing for potential restoration or reference to the original state of the treasure.
	// - If `shadowDelete` is set to `false`, the function sets the content to `nil`, the expiration time to 0, and the version
	//   is set to 0, indicating that the treasure is effectively purged but can still be accessed in memory until the Chronicler
	//   finalizes the deletion.
	//
	// The treasure remains accessible in memory with a deleted status indicator until the Chronicler commits the changes to the
	// file system. Once committed, the Chronicler will actually delete the data, removing the key from the file system and
	// subsequently purging it from memory as well.
	//
	// A `guardID`, which can be obtained via the `StartTreasureGuard` method, is required to synchronize and secure access to the treasure.
	//
	// Example:
	//     treasure := swamp.GetTreasure("someKey")
	//     guardID := treasure.StartTreasureGuard()
	//
	//     treasure.BodySetForDeletion(guardID, "userID123", true)  // Marks the treasure for shadow deletion
	//     treasure.BodySetForDeletion(guardID, "userID123", false) // Marks the treasure for complete deletion
	//
	//     treasure.ReleaseTreasureGuard(guardID)
	//
	// Use-cases:
	// 1. To initiate the secure removal of sensitive or obsolete data.
	// 2. To manage the lifecycle of a treasure, especially in situations where the data is ephemeral or subject to frequent changes.
	// 3. To perform a "soft delete" operation with `shadowDelete` for future restoration or auditing purposes.
	BodySetForDeletion(guardID guard.ID, byUserID string, shadowDelete bool)

	// BodySetKey sets the key of the treasure when it is created.
	// This function is critical as it establishes the unique identifier for the treasure. It is called only once,
	// at the moment of the treasure's creation within the system. Once the key is set, it cannot be changed.
	//
	// A guardID, which can be obtained via the StartTreasureGuard method, is required to synchronize and secure access to the treasure.
	//
	// Example:
	//     treasure := swamp.GetTreasure("someKey")
	//     guardID := treasure.StartTreasureGuard()
	//
	//     treasure.SetKey(guardID, "newUniqueKey")  // Sets the unique key for the treasure
	//
	//     treasure.ReleaseTreasureGuard(guardID)
	//
	// Use-cases:
	// 1. To uniquely identify a newly created treasure.
	// 2. To ensure data integrity by preventing duplicate keys in the system.
	//
	// Note: This function should only be called at the time of treasure creation.
	BodySetKey(guardID guard.ID, key string)

	// ConvertToByte serializes the Treasure to a binary
	//
	// Note: This method is reserved for use by the Hydra Body. Hydra Head Plugins should NOT invoke this method.
	//
	// A guardID, obtainable via the StartTreasureGuard method, is required for synchronized and secure access.
	//
	// Example:
	//     treasure := swamp.GetTreasure("someKey")
	//     guardID := treasure.StartTreasureGuard()
	//
	//     jsonBytes, err := treasure.ConvertToByte(guardID)
	//
	//     if err != nil {
	//         log.Println("Failed to convert Treasure to JSON:", err)
	//     }
	//
	//     treasure.ReleaseTreasureGuard(guardID)
	//
	// Use-cases:
	// 1. Persisting the Treasure state to disk.
	// 2. Sharing the Treasure state with other parts of the system that can read JSON.
	ConvertToByte(guardID guard.ID) ([]byte, error)

	// LoadFromByte load the Treasure from a binary
	//
	// Note: This method is reserved for use by the Hydra Body. Hydra Head Plugins should NOT invoke this method.
	//
	// A guardID, obtainable via the StartTreasureGuard method, is required for synchronized and secure access.
	//
	// Example:
	//     treasure := swamp.GetTreasure("someKey")
	//     guardID := treasure.StartTreasureGuard()
	//
	//     err := treasure.LoadFromByte(guardID, jsonBytes, "someFileName")
	//
	//     if err != nil {
	//         log.Println("Failed to load Treasure from JSON:", err)
	//     }
	//
	//     treasure.ReleaseTreasureGuard(guardID)
	//
	// Use-cases:
	// 1. Loading a previously saved Treasure state from disk.
	// 2. Initializing a new Treasure instance from a JSON representation.
	LoadFromByte(guardID guard.ID, b []byte, fileName string) error
}

// ContentType represents the type of the content stored in a Treasure instance.
// Different constants are defined to help developers specify and understand
// the type of data they are dealing with. It aids in both serialization and
// deserialization processes and adds a layer of type safety.
type ContentType int

const (
	ContentTypeVoid ContentType = iota
	ContentTypeUint8
	ContentTypeUint16
	ContentTypeUint32
	ContentTypeUint64
	ContentTypeInt8
	ContentTypeInt16
	ContentTypeInt32
	ContentTypeInt64
	ContentTypeFloat32
	ContentTypeFloat64
	ContentTypeString
	ContentTypeBoolean
	ContentTypeByteArray
	ContentTypeUint32Slice
)

// Uint32Slice is a specialized byte slice designed for storing
// and managing 4-byte (uint32) values in a compact and efficient format.
//
// This type is useful when working with datasets where fixed-size
// 32-bit integers need to be stored, searched, and manipulated
// while minimizing memory overhead compared to traditional structures.
//
// Key use cases:
// - Efficient storage of large sets of uint32 identifiers (e.g., hashed keys, IDs).
// - Compact representation of indexed data to reduce memory footprint.
// - Fast binary operations such as searching, appending, and deleting elements.
//
// Unlike a generic []byte slice, Uint32Slice ensures that its contents
// are structured in 4-byte segments, making operations predictable
// and optimized for performance.
type Uint32Slice []byte

// Content is a struct that holds the actual data in a Treasure instance.
// The use of pointer fields and omitempty allows us to minimize the memory footprint
// and serialization size by only including fields that are actually used.
type Content struct {
	Void      bool     // If true, indicates that the content is void, optimizing storage.
	Uint8     *uint8   // Holds an integer value if applicable. Nil if not used.
	Uint16    *uint16  // Holds an integer value if applicable. Nil if not used.
	Uint32    *uint32  // Holds an integer value if applicable. Nil if not used.
	Uint64    *uint64  // Holds an integer value if applicable. Nil if not used.
	Int8      *int8    // Holds an integer value if applicable. Nil if not used.
	Int16     *int16   // Holds an integer value if applicable. Nil if not used.
	Int32     *int32   // Holds an integer value if applicable. Nil if not used.
	Int64     *int64   // Holds an integer value if applicable. Nil if not used.
	Float32   *float32 // Holds a floating-point value if applicable. Nil if not used.
	Float64   *float64 // Holds a floating-point value if applicable. Nil if not used.
	String    *string  // Holds a string value if applicable. Nil if not used.
	Boolean   *bool    // Holds a boolean value if applicable. Nil if not used.
	ByteArray []byte   // Holds binary data if applicable. Empty if not used.
	// Uint32Slice is a specialized byte slice designed for storing and managing 4-byte (uint32) values in a
	// compact and efficient format.
	Uint32Slice *Uint32Slice
}

// TreasureStatus is an enumeration type representing the status of a "Treasure" operation in the Swamp.
//
// This enumeration defines various status values that indicate the result of operations related to "Treasures" in the Swamp.
// It is used to provide information about the outcome of functions such as storing, updating, or deleting treasures.
//
// Possible Values:
// - StatusVoid (TreasureStatus): This is a special status value indicating that no status should be sent to the channel.
// - StatusNew (TreasureStatus): Sent to the channel when a new Treasure is created in the Swamp.
// - StatusModified (TreasureStatus): Sent to the channel when a Treasure is modified.
// - StatusDeleted (TreasureStatus): Sent to the channel when a Treasure is deleted.
// - StatusSame (TreasureStatus): Not sent to the channel when a Treasure is not modified.
//
// Use-cases:
// 1. Providing clear status information about Treasure-related operations.
// 2. Determining the outcome of operations and taking appropriate actions based on the status value.
type TreasureStatus int8

const (
	StatusVoid     TreasureStatus = -1   // This is a special status that indicates that we don't want to send any status to the channel.
	StatusNew      TreasureStatus = iota // StatusNew send to the channel when a new Treasure is created in the swamp as new Treasure.
	StatusModified                       // StatusModified send to the channel when a Treasure is modified
	StatusDeleted                        // StatusDeleted send to the channel when a Treasure is deleted
	StatusSame                           // StatusSame not send any data to the channel when a Treasure is not modified
)

// Model is the model of the treasure but DO NOT modify this struct from outside the package
type Model struct {
	Key              string   // unique key of the content. This is the string from the map[string]
	Content          *Content // content of the treasure. May be nil if we want to delete the content or the content is EMPTY
	CreatedAt        int64    // when the data inserted into the system in UnixNano
	CreatedBy        string   // UID of the creator, who created the treasure
	CreatedByChanged bool     // flag to indicate if the created by is changed or not
	DeletedAt        int64    // the unix time (UnixNano) if the content was removed from the map
	DeletedBy        string   // UID of the deleter, who deleted the treasure
	ModifiedAt       int64    // the unix time (UnixNano) if the content was modified
	ModifiedBy       string   // UID of the modifier, who modified the treasure
	ExpirationTime   int64    // the unix time for time type ordering. This field should be empty, but useful if we want to create a message queue
	FileName         *string  // the current file name pointer. Pointer because we don't want to store the file name in the database
}

type treasure struct {
	mu       sync.RWMutex
	treasure Model
	guard.Guard
	saveMethod            func(t Treasure, guardID guard.ID) TreasureStatus
	expirationTimeChanged bool // flag to indicate if the expiration time is changed or not
	contentChanged        bool // flag to indicate if the content is changed or not
	contentTypeChanged    bool // flag to indicate if the content type is changed or not
	createdAtChanged      bool // flag to indicate if the created at is changed or not
	createdByChanged      bool // flag to indicate if the created by is changed or not
	deletedAtChanged      bool // flag to indicate if the deleted at is changed or not
	deletedByChanged      bool // flag to indicate if the deleted by is changed or not
	shadowDeleted         bool // flag to indicate if the treasure is shadow deleted or not
	modifiedAtChanged     bool // flag to indicate if the modified at is changed or not
	modifiedByChanged     bool // flag to indicate if the modified by is changed or not
}

func New(saveMethod func(t Treasure, guardID guard.ID) TreasureStatus) Treasure {
	return &treasure{
		treasure:   Model{},
		Guard:      guard.New(),
		saveMethod: saveMethod,
	}
}

// LoadFromClone loads the treasure from a clone
func (t *treasure) LoadFromClone(guardID guard.ID, clone Treasure) {
	_ = t.Guard.CanExecute(guardID)
	t.treasure = clone.(*treasure).treasure
}

// GetContentType returns the content type of the treasure
func (t *treasure) GetContentType() ContentType {

	t.mu.RLock()
	defer t.mu.RUnlock()

	if t.treasure.Content == nil || t.treasure.Content.Void {
		return ContentTypeVoid
	}
	if t.treasure.Content.Uint8 != nil {
		return ContentTypeUint8
	}
	if t.treasure.Content.Uint16 != nil {
		return ContentTypeUint16
	}
	if t.treasure.Content.Uint32 != nil {
		return ContentTypeUint32
	}
	if t.treasure.Content.Uint64 != nil {
		return ContentTypeUint64
	}
	if t.treasure.Content.Int8 != nil {
		return ContentTypeInt8
	}
	if t.treasure.Content.Int16 != nil {
		return ContentTypeInt16
	}
	if t.treasure.Content.Int32 != nil {
		return ContentTypeInt32
	}
	if t.treasure.Content.Int64 != nil {
		return ContentTypeInt64
	}
	if t.treasure.Content.Float32 != nil {
		return ContentTypeFloat32
	}
	if t.treasure.Content.Float64 != nil {
		return ContentTypeFloat64
	}
	if t.treasure.Content.String != nil {
		return ContentTypeString
	}
	if t.treasure.Content.Boolean != nil {
		return ContentTypeBoolean
	}
	if t.treasure.Content.ByteArray != nil {
		return ContentTypeByteArray
	}
	if t.treasure.Content.Uint32Slice != nil {
		return ContentTypeUint32Slice
	}
	return ContentTypeVoid
}

func (t *treasure) ResetContentByteArray(guardID guard.ID) {
	_ = t.Guard.CanExecute(guardID)
	if t.treasure.Content != nil && t.treasure.Content.ByteArray != nil {
		t.contentChanged = true
		t.contentTypeChanged = true
		t.treasure.Content.ByteArray = nil
	}
}
func (t *treasure) ResetContentBool(guardID guard.ID) {
	_ = t.Guard.CanExecute(guardID)
	if t.treasure.Content != nil && t.treasure.Content.Boolean != nil {
		t.contentChanged = true
		t.contentTypeChanged = true
		t.treasure.Content.Boolean = nil
	}
}
func (t *treasure) ResetContentFloat32(guardID guard.ID) {
	_ = t.Guard.CanExecute(guardID)
	if t.treasure.Content != nil && t.treasure.Content.Float32 != nil {
		t.contentChanged = true
		t.contentTypeChanged = true
		t.treasure.Content.Float32 = nil
	}
}
func (t *treasure) ResetContentFloat64(guardID guard.ID) {
	_ = t.Guard.CanExecute(guardID)
	if t.treasure.Content != nil && t.treasure.Content.Float64 != nil {
		t.contentChanged = true
		t.contentTypeChanged = true
		t.treasure.Content.Float64 = nil
	}
}
func (t *treasure) ResetContentUint8(guardID guard.ID) {
	_ = t.Guard.CanExecute(guardID)
	if t.treasure.Content != nil && t.treasure.Content.Uint8 != nil {
		t.contentChanged = true
		t.contentTypeChanged = true
		t.treasure.Content.Uint8 = nil
	}
}
func (t *treasure) ResetContentUint16(guardID guard.ID) {
	_ = t.Guard.CanExecute(guardID)
	if t.treasure.Content != nil && t.treasure.Content.Uint16 != nil {
		t.contentChanged = true
		t.contentTypeChanged = true
		t.treasure.Content.Uint16 = nil
	}
}
func (t *treasure) ResetContentUint32(guardID guard.ID) {
	_ = t.Guard.CanExecute(guardID)
	if t.treasure.Content != nil && t.treasure.Content.Uint32 != nil {
		t.contentChanged = true
		t.contentTypeChanged = true
		t.treasure.Content.Uint32 = nil
	}
}
func (t *treasure) ResetContentUint64(guardID guard.ID) {
	_ = t.Guard.CanExecute(guardID)
	if t.treasure.Content != nil && t.treasure.Content.Uint64 != nil {
		t.contentChanged = true
		t.contentTypeChanged = true
		t.treasure.Content.Uint64 = nil
	}
}
func (t *treasure) ResetContentInt8(guardID guard.ID) {
	_ = t.Guard.CanExecute(guardID)
	if t.treasure.Content != nil && t.treasure.Content.Int8 != nil {
		t.contentChanged = true
		t.contentTypeChanged = true
		t.treasure.Content.Int8 = nil
	}
}
func (t *treasure) ResetContentInt16(guardID guard.ID) {
	_ = t.Guard.CanExecute(guardID)
	if t.treasure.Content != nil && t.treasure.Content.Int16 != nil {
		t.contentChanged = true
		t.contentTypeChanged = true
		t.treasure.Content.Int16 = nil
	}
}
func (t *treasure) ResetContentInt32(guardID guard.ID) {
	_ = t.Guard.CanExecute(guardID)
	if t.treasure.Content != nil && t.treasure.Content.Int32 != nil {
		t.contentChanged = true
		t.contentTypeChanged = true
		t.treasure.Content.Int32 = nil
	}
}
func (t *treasure) ResetContentInt64(guardID guard.ID) {
	_ = t.Guard.CanExecute(guardID)
	if t.treasure.Content != nil && t.treasure.Content.Int64 != nil {
		t.contentChanged = true
		t.contentTypeChanged = true
		t.treasure.Content.Int64 = nil
	}
}
func (t *treasure) ResetContentUint32Slice(guardID guard.ID) {
	_ = t.Guard.CanExecute(guardID)
	if t.treasure.Content != nil && t.treasure.Content.Uint32Slice != nil {
		t.contentChanged = true
		t.contentTypeChanged = true
		t.treasure.Content.Uint32Slice = nil
	}
}

func (t *treasure) ResetContentString(guardID guard.ID) {
	_ = t.Guard.CanExecute(guardID)
	if t.treasure.Content != nil && t.treasure.Content.String != nil {
		t.contentChanged = true
		t.contentTypeChanged = true
		t.treasure.Content.String = nil
	}
}
func (t *treasure) ResetContentVoid(guardID guard.ID) {
	_ = t.Guard.CanExecute(guardID)
	if t.treasure.Content != nil && t.treasure.Content.Void {
		t.contentTypeChanged = true
		t.contentChanged = true
		t.treasure.Content.Void = false
	}
}

func (t *treasure) SetCreatedBy(guardID guard.ID, createdBy string) {
	_ = t.Guard.CanExecute(guardID)
	t.createdByChanged = true
	t.treasure.CreatedBy = createdBy
	t.treasure.CreatedAt = time.Now().UTC().UnixNano()
}
func (t *treasure) SetModifiedBy(guardID guard.ID, modifiedBy string) {
	_ = t.Guard.CanExecute(guardID)
	t.modifiedByChanged = true
	t.treasure.ModifiedBy = modifiedBy
	t.treasure.ModifiedAt = time.Now().UTC().UnixNano()
}

func (t *treasure) Clone(guardID guard.ID) Treasure {

	_ = t.Guard.CanExecute(guardID)

	newObj := &treasure{
		treasure: Model{
			Key:            t.treasure.Key,
			ExpirationTime: t.treasure.ExpirationTime,
			Content:        nil,
			CreatedAt:      t.treasure.CreatedAt,
			CreatedBy:      t.treasure.CreatedBy,
			DeletedAt:      0,
			DeletedBy:      "",
			ModifiedAt:     t.treasure.ModifiedAt,
			ModifiedBy:     t.treasure.ModifiedBy,
			// We don't want to clone the file name pointer because this treasure will be a new treasure and the fileName
			// should be a new, too.
			// And the chronicler will write the treasure as a new one, only if the fileName is nil
			FileName: nil,
		},
		Guard: guard.New(),
	}

	// clone just the content
	newContent := Content{}
	if t.treasure.Content != nil {
		newContent = t.cloneContent()
	}

	newObj.treasure.Content = &newContent

	return newObj

}

func (t *treasure) CloneContent(guardID guard.ID) Content {
	_ = t.Guard.CanExecute(guardID)
	return t.cloneContent()
}

func (t *treasure) cloneContent() Content {
	newContent := Content{}
	if t.treasure.Content != nil {
		if t.treasure.Content.String != nil {
			newString := *t.treasure.Content.String
			newContent.String = &newString
		} else if t.treasure.Content.Uint8 != nil {
			newInt := *t.treasure.Content.Uint8
			newContent.Uint8 = &newInt
		} else if t.treasure.Content.Uint16 != nil {
			newInt := *t.treasure.Content.Uint16
			newContent.Uint16 = &newInt
		} else if t.treasure.Content.Uint32 != nil {
			newInt := *t.treasure.Content.Uint32
			newContent.Uint32 = &newInt
		} else if t.treasure.Content.Uint64 != nil {
			newInt := *t.treasure.Content.Uint64
			newContent.Uint64 = &newInt
		} else if t.treasure.Content.Int8 != nil {
			newInt := *t.treasure.Content.Int8
			newContent.Int8 = &newInt
		} else if t.treasure.Content.Int16 != nil {
			newInt := *t.treasure.Content.Int16
			newContent.Int16 = &newInt
		} else if t.treasure.Content.Int32 != nil {
			newInt := *t.treasure.Content.Int32
			newContent.Int32 = &newInt
		} else if t.treasure.Content.Int64 != nil {
			newInt := *t.treasure.Content.Int64
			newContent.Int64 = &newInt
		} else if t.treasure.Content.Float32 != nil {
			newFloat := *t.treasure.Content.Float32
			newContent.Float32 = &newFloat
		} else if t.treasure.Content.Float64 != nil {
			newFloat := *t.treasure.Content.Float64
			newContent.Float64 = &newFloat
		} else if t.treasure.Content.Boolean != nil {
			newBool := *t.treasure.Content.Boolean
			newContent.Boolean = &newBool
		} else if t.treasure.Content.ByteArray != nil {
			newByteArray := make([]byte, len(t.treasure.Content.ByteArray))
			copy(newByteArray, t.treasure.Content.ByteArray)
			newContent.ByteArray = newByteArray
		} else if t.treasure.Content.Uint32Slice != nil {
			newSlice := make(Uint32Slice, len(*t.treasure.Content.Uint32Slice))
			copy(newSlice, *t.treasure.Content.Uint32Slice)
			newContent.Uint32Slice = &newSlice
		} else if t.treasure.Content.Void {
			newContent.Void = true
		}
	}
	return newContent
}

func (t *treasure) SetContent(guardID guard.ID, content Content) {

	_ = t.Guard.CanExecute(guardID)

	t.contentChanged = false
	if t.IsContentTypeChanged() {
		t.contentChanged = true
	}

	t.treasure.Content = &content

}

func (t *treasure) CheckIfContentChanged(newContent *Content) bool {

	// ha még nincs benne tartalom, de most bekerülne akkor biztos új tartalom lesz
	if t.treasure.Content == nil && newContent != nil {
		return true
	}

	// lekédezzük a treasure jelenlegi content típusát
	ct := t.GetContentType()

	switch ct {
	case ContentTypeVoid:
		if newContent != nil && !newContent.Void {
			return true
		}
	case ContentTypeUint8:
		if newContent == nil || newContent.Uint8 == nil || *newContent.Uint8 != *t.treasure.Content.Uint8 {
			return true
		}
	case ContentTypeUint16:
		if newContent == nil || newContent.Uint16 == nil || *newContent.Uint16 != *t.treasure.Content.Uint16 {
			return true
		}
	case ContentTypeUint32:
		if newContent == nil || newContent.Uint32 == nil || *newContent.Uint32 != *t.treasure.Content.Uint32 {
			return true
		}
	case ContentTypeUint64:
		if newContent == nil || newContent.Uint64 == nil || *newContent.Uint64 != *t.treasure.Content.Uint64 {
			return true
		}
	case ContentTypeInt8:
		if newContent == nil || newContent.Int8 == nil || *newContent.Int8 != *t.treasure.Content.Int8 {
			return true
		}
	case ContentTypeInt16:
		if newContent == nil || newContent.Int16 == nil || *newContent.Int16 != *t.treasure.Content.Int16 {
			return true
		}
	case ContentTypeInt32:
		if newContent == nil || newContent.Int32 == nil || *newContent.Int32 != *t.treasure.Content.Int32 {
			return true
		}
	case ContentTypeInt64:
		if newContent == nil || newContent.Int64 == nil || *newContent.Int64 != *t.treasure.Content.Int64 {
			return true
		}
	case ContentTypeFloat32:
		if newContent == nil || newContent.Float32 == nil || *newContent.Float32 != *t.treasure.Content.Float32 {
			return true
		}
	case ContentTypeFloat64:
		if newContent == nil || newContent.Float64 == nil || *newContent.Float64 != *t.treasure.Content.Float64 {
			return true
		}
	case ContentTypeString:
		if newContent == nil || newContent.String == nil || *newContent.String != *t.treasure.Content.String {
			return true
		}
	case ContentTypeBoolean:
		if newContent == nil || newContent.Boolean == nil || *newContent.Boolean != *t.treasure.Content.Boolean {
			return true
		}
	case ContentTypeByteArray:
		if newContent == nil || newContent.ByteArray == nil || !bytes.Equal(newContent.ByteArray, t.treasure.Content.ByteArray) {
			return true
		}
	case ContentTypeUint32Slice:
		if newContent == nil || newContent.Uint32Slice == nil || !bytes.Equal(*newContent.Uint32Slice, *t.treasure.Content.Uint32Slice) {
			return true
		}
	default:
		return false
	}

	return false

}

func (t *treasure) BodySetFileName(guardID guard.ID, fileName string) {
	if canExecuteErr := t.Guard.CanExecute(guardID); canExecuteErr != nil {
		return
	}
	// does not increase the version because the fileName is not part of the content
	t.treasure.FileName = &fileName
}

func (t *treasure) BodySetForDeletion(guardID guard.ID, byUserID string, shadowDelete bool) {
	if canExecuteErr := t.Guard.CanExecute(guardID); canExecuteErr != nil {
		return
	}
	timeNow := time.Now().UTC().UnixNano()

	t.deletedAtChanged = true
	t.deletedByChanged = true

	t.treasure.DeletedAt = timeNow
	t.treasure.DeletedBy = byUserID

	t.shadowDeleted = shadowDelete

	// DO NOT DELETE THE CONTENT and the expiration time from the treasure if the shadowDelete is true, because we need
	// the whole treasure in unchanged state to be able to restore it, or read it as a deleted treasure
	if !shadowDelete {
		// set the content to nil
		t.treasure.Content = nil
		// set the expiration time to 0 because the treasure is deleted, and we don't want to process it by the expiration time
		t.treasure.ExpirationTime = 0
	}

}

func (t *treasure) GetKey() string {
	t.mu.RLock()
	defer t.mu.RUnlock()
	return t.treasure.Key
}

func (t *treasure) SetExpirationTime(guardID guard.ID, expirationTime time.Time) {
	_ = t.Guard.CanExecute(guardID)
	t.expirationTimeChanged = true
	t.treasure.ExpirationTime = expirationTime.UTC().UnixNano()
}

func (t *treasure) GetExpirationTime() int64 {
	t.mu.RLock()
	defer t.mu.RUnlock()
	return t.treasure.ExpirationTime
}

func (t *treasure) GetCreatedAt() int64 {
	t.mu.RLock()
	defer t.mu.RUnlock()
	return t.treasure.CreatedAt
}

func (t *treasure) GetCreatedBy() string {
	t.mu.RLock()
	defer t.mu.RUnlock()
	return t.treasure.CreatedBy
}

func (t *treasure) GetDeletedAt() int64 {
	t.mu.RLock()
	defer t.mu.RUnlock()
	return t.treasure.DeletedAt
}

func (t *treasure) GetDeletedBy() string {
	t.mu.RLock()
	defer t.mu.RUnlock()
	return t.treasure.DeletedBy
}

func (t *treasure) GetShadowDelete() bool {
	t.mu.RLock()
	defer t.mu.RUnlock()
	return t.shadowDeleted
}

func (t *treasure) SetModifiedAt(guardID guard.ID, modifiedAt time.Time) {
	_ = t.Guard.CanExecute(guardID)
	t.modifiedAtChanged = true
	t.treasure.ModifiedAt = modifiedAt.UTC().UnixNano()
}

func (t *treasure) GetModifiedAt() int64 {
	t.mu.RLock()
	defer t.mu.RUnlock()
	return t.treasure.ModifiedAt
}

func (t *treasure) GetModifiedBy() string {
	t.mu.RLock()
	defer t.mu.RUnlock()
	return t.treasure.ModifiedBy
}

func (t *treasure) GetFileName() *string {
	t.mu.RLock()
	defer t.mu.RUnlock()
	return t.treasure.FileName
}

// BodySetKey sets the key of the treasure
func (t *treasure) BodySetKey(guardID guard.ID, key string) {
	if canExecuteErr := t.Guard.CanExecute(guardID); canExecuteErr != nil {
		return // do nothing
	}
	t.treasure.DeletedBy = ""
	t.treasure.DeletedAt = 0
	t.treasure.Key = key
}

func (t *treasure) ConvertToByte(guardID guard.ID) ([]byte, error) {

	if canExecuteErr := t.Guard.CanExecute(guardID); canExecuteErr != nil {
		return nil, canExecuteErr
	}

	// copy the treasure to a new variable
	// and set the filePointer to empty one, because we don't want to save the filePointer to the Chronicler
	newObj := &treasure{
		treasure: Model{
			Key:            t.treasure.Key,
			ExpirationTime: t.treasure.ExpirationTime,
			CreatedAt:      t.treasure.CreatedAt,
			CreatedBy:      t.treasure.CreatedBy,
			DeletedAt:      t.treasure.DeletedAt,
			DeletedBy:      t.treasure.DeletedBy,
			ModifiedAt:     t.treasure.ModifiedAt,
			ModifiedBy:     t.treasure.ModifiedBy,
			Content:        t.treasure.Content,
			FileName:       nil,
		},
	}

	// if the treasure content is not VOID
	if newObj.treasure.Content != nil && !newObj.treasure.Content.Void {
		newObj.treasure.Content = t.treasure.Content
	}

	var buf bytes.Buffer
	encoder := gob.NewEncoder(&buf)
	err := encoder.Encode(t.treasure)
	if err != nil {
		return nil, err
	}
	return buf.Bytes(), nil

}

func (t *treasure) LoadFromByte(guardID guard.ID, b []byte, fileName string) error {
	// guard ellenőrzése
	if canExecuteErr := t.Guard.CanExecute(guardID); canExecuteErr != nil {
		return canExecuteErr
	}

	// bináris adat betöltése
	buf := bytes.NewReader(b)

	// Dekódolás gob formátumból
	decoder := gob.NewDecoder(buf)
	err := decoder.Decode(&t.treasure)
	if err != nil {
		return err
	}
	// filenév beállítása
	t.treasure.FileName = &fileName
	return nil
}

func (t *treasure) SetContentVoid(guardID guard.ID) {
	_ = t.Guard.CanExecute(guardID)

	// if the content is not changed, do nothing
	if t.treasure.Content != nil && t.treasure.Content.Void {
		return
	}

	t.contentChanged = true
	if t.treasure.Content == nil {
		t.treasure.Content = &Content{
			Void: true,
		}
	}

	if t.treasure.Content.Void != false {
		t.treasure.Content.Void = true
	}

}

func (t *treasure) SetContentString(guardID guard.ID, content string) {
	_ = t.Guard.CanExecute(guardID)

	// if the content is not changed, do nothing
	if t.treasure.Content != nil && t.treasure.Content.String != nil && *t.treasure.Content.String == content {
		return
	}

	t.contentChanged = true
	t.treasure.Content = &Content{
		String: &content,
	}
}

func (t *treasure) SetContentUint8(guardID guard.ID, content uint8) {
	_ = t.Guard.CanExecute(guardID)
	// if the content is not changed, do nothing
	if t.treasure.Content != nil && t.treasure.Content.Uint8 != nil && *t.treasure.Content.Uint8 == content {
		return
	}
	t.contentChanged = true
	t.treasure.Content = &Content{
		Uint8: &content,
	}
}
func (t *treasure) SetContentUint16(guardID guard.ID, content uint16) {
	_ = t.Guard.CanExecute(guardID)
	// if the content is not changed, do nothing
	if t.treasure.Content != nil && t.treasure.Content.Uint16 != nil && *t.treasure.Content.Uint16 == content {
		return
	}
	t.contentChanged = true
	t.treasure.Content = &Content{
		Uint16: &content,
	}
}
func (t *treasure) SetContentUint32(guardID guard.ID, content uint32) {
	_ = t.Guard.CanExecute(guardID)
	// if the content is not changed, do nothing
	if t.treasure.Content != nil && t.treasure.Content.Uint32 != nil && *t.treasure.Content.Uint32 == content {
		return
	}
	t.contentChanged = true
	t.treasure.Content = &Content{
		Uint32: &content,
	}
}
func (t *treasure) SetContentUint64(guardID guard.ID, content uint64) {
	_ = t.Guard.CanExecute(guardID)
	// if the content is not changed, do nothing
	if t.treasure.Content != nil && t.treasure.Content.Uint64 != nil && *t.treasure.Content.Uint64 == content {
		return
	}
	t.contentChanged = true
	t.treasure.Content = &Content{
		Uint64: &content,
	}
}
func (t *treasure) SetContentInt8(guardID guard.ID, content int8) {
	_ = t.Guard.CanExecute(guardID)
	// if the content is not changed, do nothing
	if t.treasure.Content != nil && t.treasure.Content.Int8 != nil && *t.treasure.Content.Int8 == content {
		return
	}
	t.contentChanged = true
	t.treasure.Content = &Content{
		Int8: &content,
	}
}
func (t *treasure) SetContentInt16(guardID guard.ID, content int16) {
	_ = t.Guard.CanExecute(guardID)
	// if the content is not changed, do nothing
	if t.treasure.Content != nil && t.treasure.Content.Int16 != nil && *t.treasure.Content.Int16 == content {
		return
	}
	t.contentChanged = true
	t.treasure.Content = &Content{
		Int16: &content,
	}
}
func (t *treasure) SetContentInt32(guardID guard.ID, content int32) {
	_ = t.Guard.CanExecute(guardID)
	// if the content is not changed, do nothing
	if t.treasure.Content != nil && t.treasure.Content.Int32 != nil && *t.treasure.Content.Int32 == content {
		return
	}
	t.contentChanged = true
	t.treasure.Content = &Content{
		Int32: &content,
	}
}
func (t *treasure) SetContentInt64(guardID guard.ID, content int64) {

	_ = t.Guard.CanExecute(guardID)

	// if the content is not changed, do nothing
	if t.treasure.Content != nil && t.treasure.Content.Int64 != nil && *t.treasure.Content.Int64 == content {
		return
	}

	t.contentChanged = true
	t.treasure.Content = &Content{
		Int64: &content,
	}
}

func (t *treasure) SetContentFloat32(guardID guard.ID, content float32) {
	_ = t.Guard.CanExecute(guardID)

	// if treasure content is not changed, do nothing
	if t.treasure.Content != nil && t.treasure.Content.Float32 != nil && *t.treasure.Content.Float32 == content {
		return
	}

	t.contentChanged = true
	t.treasure.Content = &Content{
		Float32: &content,
	}
}

func (t *treasure) SetContentFloat64(guardID guard.ID, content float64) {
	_ = t.Guard.CanExecute(guardID)

	// if treasure content is not changed, do nothing
	if t.treasure.Content != nil && t.treasure.Content.Float64 != nil && *t.treasure.Content.Float64 == content {
		return
	}

	t.contentChanged = true
	t.treasure.Content = &Content{
		Float64: &content,
	}
}

func (t *treasure) SetContentBool(guardID guard.ID, content bool) {
	_ = t.Guard.CanExecute(guardID)

	// if treasure content is not changed, do nothing
	if t.treasure.Content != nil && t.treasure.Content.Boolean != nil && *t.treasure.Content.Boolean == content {
		return
	}

	t.contentChanged = true
	t.treasure.Content = &Content{
		Boolean: &content,
	}

}

func (t *treasure) SetContentByteArray(guardID guard.ID, content []byte) {
	_ = t.Guard.CanExecute(guardID)
	// if the content is not changed, do nothing
	if t.treasure.Content != nil && t.treasure.Content.ByteArray != nil && bytes.Equal(t.treasure.Content.ByteArray, content) {
		return
	}
	t.contentChanged = true
	t.treasure.Content = &Content{
		ByteArray: content,
	}
}

// SetCreatedAt set the created at of the treasure to the current time without locking the mutex
func (t *treasure) SetCreatedAt(guardID guard.ID, createdAt time.Time) {
	_ = t.Guard.CanExecute(guardID)
	t.createdAtChanged = true
	t.treasure.CreatedAt = createdAt.UTC().UnixNano()
}

// GetContentString gets the content of the treasure as a string
func (t *treasure) GetContentString() (string, error) {
	t.mu.RLock()
	defer t.mu.RUnlock()
	if t.treasure.Content == nil || t.treasure.Content.String == nil {
		return "", fmt.Errorf("content type is not a string")
	}
	return *t.treasure.Content.String, nil
}

func (t *treasure) GetContentUint8() (uint8, error) {
	t.mu.RLock()
	defer t.mu.RUnlock()
	if t.treasure.Content == nil || t.treasure.Content.Uint8 == nil {
		return 0, fmt.Errorf("content type is not uint8")
	}
	return *t.treasure.Content.Uint8, nil
}
func (t *treasure) GetContentUint16() (uint16, error) {
	t.mu.RLock()
	defer t.mu.RUnlock()
	if t.treasure.Content == nil || t.treasure.Content.Uint16 == nil {
		return 0, fmt.Errorf("content type is not uint16")
	}
	return *t.treasure.Content.Uint16, nil
}
func (t *treasure) GetContentUint32() (uint32, error) {
	t.mu.RLock()
	defer t.mu.RUnlock()
	if t.treasure.Content == nil || t.treasure.Content.Uint32 == nil {
		return 0, fmt.Errorf("content type is not uint32")
	}
	return *t.treasure.Content.Uint32, nil
}
func (t *treasure) GetContentUint64() (uint64, error) {
	t.mu.RLock()
	defer t.mu.RUnlock()
	if t.treasure.Content == nil || t.treasure.Content.Uint64 == nil {
		return 0, fmt.Errorf("content type is not uint64")
	}
	return *t.treasure.Content.Uint64, nil
}
func (t *treasure) GetContentInt8() (int8, error) {
	t.mu.RLock()
	defer t.mu.RUnlock()
	if t.treasure.Content == nil || t.treasure.Content.Int8 == nil {
		return 0, fmt.Errorf("content type is not int8")
	}
	return *t.treasure.Content.Int8, nil
}
func (t *treasure) GetContentInt16() (int16, error) {
	t.mu.RLock()
	defer t.mu.RUnlock()
	if t.treasure.Content == nil || t.treasure.Content.Int16 == nil {
		return 0, fmt.Errorf("content type is not int16")
	}
	return *t.treasure.Content.Int16, nil
}
func (t *treasure) GetContentInt32() (int32, error) {
	t.mu.RLock()
	defer t.mu.RUnlock()
	if t.treasure.Content == nil || t.treasure.Content.Int32 == nil {
		return 0, fmt.Errorf("content type is not int32")
	}
	return *t.treasure.Content.Int32, nil
}

// GetContentInt64 gets the content of the treasure as an integer
func (t *treasure) GetContentInt64() (int64, error) {
	t.mu.RLock()
	defer t.mu.RUnlock()
	if t.treasure.Content == nil || t.treasure.Content.Int64 == nil {
		return 0, fmt.Errorf("content type is not int64")
	}
	return *t.treasure.Content.Int64, nil
}

func (t *treasure) GetContentFloat32() (float32, error) {
	t.mu.RLock()
	defer t.mu.RUnlock()
	if t.treasure.Content == nil || t.treasure.Content.Float32 == nil {
		return 0, fmt.Errorf("content type is not a float32")
	}
	return *t.treasure.Content.Float32, nil
}

func (t *treasure) GetContentFloat64() (float64, error) {
	t.mu.RLock()
	defer t.mu.RUnlock()
	if t.treasure.Content == nil || t.treasure.Content.Float64 == nil {
		return 0, fmt.Errorf("content type is not a float64")
	}
	return *t.treasure.Content.Float64, nil
}

// GetContentBool gets the content of the treasure as a bool
func (t *treasure) GetContentBool() (bool, error) {
	t.mu.RLock()
	defer t.mu.RUnlock()
	if t.treasure.Content == nil || t.treasure.Content.Boolean == nil {
		return false, fmt.Errorf("content type is not a bool")
	}
	return *t.treasure.Content.Boolean, nil
}

// GetContentByteArray gets the content of the treasure as a byte array
func (t *treasure) GetContentByteArray() ([]byte, error) {

	t.mu.RLock()
	defer t.mu.RUnlock()

	// Checking if the content is nil or if the content type is not a byte array.
	if t.treasure.Content == nil || t.treasure.Content.ByteArray == nil {
		return nil, fmt.Errorf("content type is not a byte array")
	}

	return t.treasure.Content.ByteArray, nil

}

// IsExpired checks if the treasure's time order is expired
func (t *treasure) IsExpired() bool {
	t.mu.RLock()
	defer t.mu.RUnlock()
	if t.treasure.ExpirationTime == 0 {
		return false
	}
	return t.treasure.ExpirationTime < time.Now().UTC().UnixNano()
}

// IsDifferentFrom checks if the treasure is different from another treasure
func (t *treasure) IsDifferentFrom(guardID guard.ID, otherTreasure Treasure) bool {

	_ = t.Guard.CanExecute(guardID)

	if t.treasure.Key != otherTreasure.GetKey() {
		return true
	}
	if t.treasure.ExpirationTime != otherTreasure.GetExpirationTime() {
		return true
	}

	cat := otherTreasure.GetCreatedAt()

	if t.treasure.CreatedAt != cat {
		return true
	}
	if t.treasure.CreatedBy != otherTreasure.GetCreatedBy() {
		return true
	}
	if t.treasure.DeletedAt != otherTreasure.GetDeletedAt() {
		return true
	}
	if t.treasure.DeletedBy != otherTreasure.GetDeletedBy() {
		return true
	}
	if t.treasure.ModifiedAt != otherTreasure.GetModifiedAt() {
		return true
	}
	if t.treasure.ModifiedBy != otherTreasure.GetModifiedBy() {
		return true
	}

	switch otherTreasure.GetContentType() {
	case ContentTypeVoid:
		if t.treasure.Content == nil || (t.treasure.Content != nil && t.treasure.Content.Void) {
			return true
		}
	case ContentTypeString:
		if t.treasure.Content == nil {
			return true
		} else {
			stringContent, err := otherTreasure.GetContentString()
			if err != nil {
				return true
			}
			if *t.treasure.Content.String != stringContent {
				return true
			}
		}
	case ContentTypeUint8:
		if t.treasure.Content == nil {
			return true
		} else {
			uintContent, err := otherTreasure.GetContentUint8()
			if err != nil {
				return true
			}
			if *t.treasure.Content.Uint8 != uintContent {
				return true
			}
		}
	case ContentTypeUint16:
		if t.treasure.Content == nil {
			return true
		} else {
			uintContent, err := otherTreasure.GetContentUint16()
			if err != nil {
				return true
			}
			if *t.treasure.Content.Uint16 != uintContent {
				return true
			}
		}
	case ContentTypeUint32:
		if t.treasure.Content == nil {
			return true
		} else {
			uintContent, err := otherTreasure.GetContentUint32()
			if err != nil {
				return true
			}
			if *t.treasure.Content.Uint32 != uintContent {
				return true
			}
		}
	case ContentTypeUint64:
		if t.treasure.Content == nil {
			return true
		} else {
			uintContent, err := otherTreasure.GetContentUint64()
			if err != nil {
				return true
			}
			if *t.treasure.Content.Uint64 != uintContent {
				return true
			}
		}
	case ContentTypeInt8:
		if t.treasure.Content == nil {
			return true
		} else {
			intContent, err := otherTreasure.GetContentInt8()
			if err != nil {
				return true
			}
			if *t.treasure.Content.Int8 != intContent {
				return true
			}
		}
	case ContentTypeInt16:
		if t.treasure.Content == nil {
			return true
		} else {
			intContent, err := otherTreasure.GetContentInt16()
			if err != nil {
				return true
			}
			if *t.treasure.Content.Int16 != intContent {
				return true
			}
		}
	case ContentTypeInt32:
		if t.treasure.Content == nil {
			return true
		} else {
			intContent, err := otherTreasure.GetContentInt32()
			if err != nil {
				return true
			}
			if *t.treasure.Content.Int32 != intContent {
				return true
			}
		}
	case ContentTypeInt64:
		if t.treasure.Content == nil {
			return true
		} else {
			intContent, err := otherTreasure.GetContentInt64()
			if err != nil {
				return true
			}
			if *t.treasure.Content.Int64 != intContent {
				return true
			}
		}
	case ContentTypeFloat32:
		if t.treasure.Content == nil {
			return true
		} else {
			floatContent, err := otherTreasure.GetContentFloat32()
			if err != nil {
				return true
			}
			if *t.treasure.Content.Float32 != floatContent {
				return true
			}
		}
	case ContentTypeFloat64:
		if t.treasure.Content == nil {
			return true
		} else {
			floatContent, err := otherTreasure.GetContentFloat64()
			if err != nil {
				return true
			}
			if *t.treasure.Content.Float64 != floatContent {
				return true
			}
		}
	case ContentTypeBoolean:
		if t.treasure.Content == nil {
			return true
		} else {
			boolContent, err := otherTreasure.GetContentBool()
			if err != nil {
				return true
			}
			if *t.treasure.Content.Boolean != boolContent {
				return true
			}
		}
	case ContentTypeByteArray:
		if t.treasure.Content == nil {
			return true
		} else {
			byteArrayContent, err := otherTreasure.GetContentByteArray()
			if err != nil {
				return true
			}
			if !reflect.DeepEqual(t.treasure.Content.ByteArray, byteArrayContent) {
				return true
			}
		}
	case ContentTypeUint32Slice:
		if t.treasure.Content == nil {
			return true
		} else {
			uint32SliceContent, err := otherTreasure.Uint32SliceGetAll()
			if err != nil {
				return true
			}
			if !reflect.DeepEqual(t.treasure.Content.Uint32Slice, uint32SliceContent) {
				return true
			}
		}
	}
	return false
}

// Save saves the treasure to the Swamp
func (t *treasure) Save(guardID guard.ID) TreasureStatus {
	_ = t.Guard.CanExecute(guardID)
	return t.saveMethod(t, guardID)
}

func (t *treasure) IsContentChanged() bool {
	t.mu.RLock()
	defer t.mu.RUnlock()
	return t.contentChanged
}

func (t *treasure) IsExpirationTimeChanged() bool {
	t.mu.RLock()
	defer t.mu.RUnlock()
	return t.expirationTimeChanged
}

func (t *treasure) IsCreatedAtChanged() bool {
	t.mu.RLock()
	defer t.mu.RUnlock()
	return t.createdAtChanged
}

func (t *treasure) IsCreatedByChanged() bool {
	t.mu.RLock()
	defer t.mu.RUnlock()
	return t.createdByChanged
}

func (t *treasure) IsDeletedAtChanged() bool {
	t.mu.RLock()
	defer t.mu.RUnlock()
	return t.deletedAtChanged
}

func (t *treasure) IsDeletedByChanged() bool {
	t.mu.RLock()
	defer t.mu.RUnlock()
	return t.deletedByChanged
}

func (t *treasure) IsModifiedAtChanged() bool {
	t.mu.RLock()
	defer t.mu.RUnlock()
	return t.modifiedAtChanged
}

func (t *treasure) IsModifiedByChanged() bool {
	t.mu.RLock()
	defer t.mu.RUnlock()
	return t.modifiedByChanged
}

func (t *treasure) IsContentTypeChanged() bool {
	t.mu.RLock()
	defer t.mu.RUnlock()
	return t.contentTypeChanged
}

func (t *treasure) Uint32SliceGetAll() ([]uint32, error) {
	t.mu.RLock()
	defer t.mu.RUnlock()
	if t.treasure.Content == nil || t.treasure.Content.Uint32Slice == nil {
		return nil, fmt.Errorf("content type is not a uint32 slice")
	}
	var result []uint32
	for i := 0; i < len(*t.treasure.Content.Uint32Slice); i += 4 {
		result = append(result, binary.LittleEndian.Uint32((*t.treasure.Content.Uint32Slice)[i:i+4]))
	}
	return result, nil
}

func (t *treasure) Uint32SlicePush(values []uint32) error {

	t.mu.Lock()
	defer t.mu.Unlock()

	if t.treasure.Content == nil {
		t.treasure.Content = &Content{}
	}
	if t.treasure.Content.Uint32Slice == nil {
		t.treasure.Content.Uint32Slice = new(Uint32Slice)
	}

	// Konvertáljuk a meglévő slice-ot egy gyors lookup map-pé
	existing := make(map[uint32]struct{})
	for i := 0; i < len(*t.treasure.Content.Uint32Slice); i += 4 {
		v := binary.LittleEndian.Uint32((*t.treasure.Content.Uint32Slice)[i : i+4])
		existing[v] = struct{}{}
	}

	// Új elemek hozzáadása (csak, ha még nem léteznek)
	var buf []byte
	for _, v := range values {
		if _, found := existing[v]; !found {
			temp := make([]byte, 4)
			binary.LittleEndian.PutUint32(temp, v)
			buf = append(buf, temp...)
			existing[v] = struct{}{} // Hozzáadjuk a lookup map-hez is
		}
	}

	// Ha van új elem, akkor appendeljük
	if len(buf) > 0 {
		*t.treasure.Content.Uint32Slice = append(*t.treasure.Content.Uint32Slice, buf...)
		t.contentChanged = true
	}

	return nil

}

func (t *treasure) Uint32SliceDelete(values []uint32) error {

	t.mu.Lock()
	defer t.mu.Unlock()

	if t.treasure.Content == nil || t.treasure.Content.Uint32Slice == nil {
		return nil // Ha nincs adat, nincs mit törölni
	}

	var newSlice []byte
	for i := 0; i < len(*t.treasure.Content.Uint32Slice); i += 4 {
		v := binary.LittleEndian.Uint32((*t.treasure.Content.Uint32Slice)[i : i+4])
		shouldDelete := false
		for _, del := range values {
			if v == del {
				shouldDelete = true
				break
			}
		}
		if !shouldDelete {
			t.contentChanged = true
			newSlice = append(newSlice, (*t.treasure.Content.Uint32Slice)[i:i+4]...)
		}
	}

	// Frissítjük a slice-ot a törölt elemek nélkül
	*t.treasure.Content.Uint32Slice = newSlice

	return nil

}
func (t *treasure) Uint32SliceSize() (int, error) {

	t.mu.RLock()
	defer t.mu.RUnlock()

	if t.treasure.Content == nil || t.treasure.Content.Uint32Slice == nil {
		return 0, fmt.Errorf("content type is not a uint32 slice")
	}

	// Az összes bájt számát elosztjuk 4-gyel (mert 1 elem = 4 bájt)
	return len(*t.treasure.Content.Uint32Slice) / 4, nil

}

--------------------------------------------------------------------------------

/==============================================================================\
| FILE: core\hydra\swamp\treasure\treasure_test.go
| PATH: C:\go\src\hydraide\app\core\hydra\swamp\treasure\treasure_test.go
| SIZE: 20.6 KB
\==============================================================================/

package treasure

import (
	"github.com/hydraide/hydraide/app/core/hydra/swamp/treasure/guard"
	"github.com/stretchr/testify/assert"
	"testing"
	"time"
)

func MySaveMethod(_ Treasure, _ guard.ID) TreasureStatus {
	return StatusNew
}

func TestGetContentType(t *testing.T) {

	t.Run("should return ContentTypeVoid when treasure content is ContentTypeVoid", func(t *testing.T) {
		treasureInterface := New(MySaveMethod)
		guardID := treasureInterface.StartTreasureGuard(true)
		treasureInterface.SetContentVoid(guardID)
		assert.Equal(t, treasureInterface.GetContentType(), ContentTypeVoid)

		treasureInterface.ResetContentVoid(guardID)
		treasureInterface.SetContentString(guardID, "test")
		assert.Equal(t, treasureInterface.GetContentType(), ContentTypeString)

		treasureInterface.ReleaseTreasureGuard(guardID)
	})

	t.Run("should handle Uint32Slice", func(t *testing.T) {
		treasureInterface := New(MySaveMethod)

		guardID := treasureInterface.StartTreasureGuard(true)
		testUintSlice := []uint32{12, 13, 14}

		// próbálunk törölni a sliceból, ameddig az nem is létetik
		err := treasureInterface.Uint32SliceDelete(testUintSlice)
		assert.Nil(t, err, "Uint32SliceDelete should not return error")

		// próbáljuk lékérdezni a slicet, ameddig az nem is létetik
		_, err = treasureInterface.Uint32SliceGetAll()
		assert.NotNil(t, err, "Uint32SliceGetAll should return error")

		// próbáljuk a méretét lekérdezni, ameddig nem is létezik
		_, err = treasureInterface.Uint32SliceSize()
		assert.NotNil(t, err, "Uint32SliceSize should return error")

		isContentChanged := treasureInterface.IsContentChanged()
		assert.False(t, isContentChanged, "IsContentChanged should return false")

		err = treasureInterface.Uint32SlicePush(testUintSlice)
		assert.Nil(t, err, "Uint32SlicePush should not return error")

		isContentChanged = treasureInterface.IsContentChanged()
		assert.True(t, isContentChanged, "IsContentChanged should return true")

		// push content again
		err = treasureInterface.Uint32SlicePush(testUintSlice)
		assert.Nil(t, err, "Uint32SlicePush should not return error")

		assert.Equal(t, treasureInterface.GetContentType(), ContentTypeUint32Slice)

		uintSLiceFromTreasure, err := treasureInterface.Uint32SliceGetAll()
		assert.Equal(t, nil, err, "Uint32SliceGetAll should not return error")
		assert.Equal(t, testUintSlice, uintSLiceFromTreasure, "Uint32SliceGetAll should return the same slice")

		// beszúrunk 3 új számot
		testUintSlice2 := []uint32{12, 13, 17, 19, 35}
		err = treasureInterface.Uint32SlicePush(testUintSlice2)
		assert.Nil(t, err, "Uint32SlicePush should not return error")

		uintSLiceFromTreasure, err = treasureInterface.Uint32SliceGetAll()
		assert.Equal(t, nil, err, "Uint32SliceGetAll should not return error")
		// összesen 5 szám kell legyen a slice-ban
		expectedNumbers := []uint32{12, 13, 14, 17, 19, 35}
		assert.Equal(t, expectedNumbers, uintSLiceFromTreasure, "Uint32SliceGetAll should return the same slice")

		isContentChanged = treasureInterface.IsContentChanged()
		assert.True(t, isContentChanged, "IsContentChanged should return true")

		// törlünk 2 számot és egy nem létező számot is
		testUintSlice3 := []uint32{13, 19, 99}
		err = treasureInterface.Uint32SliceDelete(testUintSlice3)
		assert.Nil(t, err, "Uint32SliceDelete should not return error")

		uintSLiceFromTreasure, err = treasureInterface.Uint32SliceGetAll()
		assert.Equal(t, nil, err, "Uint32SliceGetAll should not return error")
		expectedNumbers = []uint32{12, 14, 17, 35}
		assert.Equal(t, expectedNumbers, uintSLiceFromTreasure, "Uint32SliceGetAll should return the same slice")

		// ellenőrizzük a slice méretét
		size, err := treasureInterface.Uint32SliceSize()
		assert.Nil(t, err, "Uint32SliceSize should not return error")
		assert.Equal(t, 4, size, "Uint32SliceSize should return 4")

		// töröljük az összes fennmaradó számot
		numbersForDelete := []uint32{12, 14, 17, 35}
		err = treasureInterface.Uint32SliceDelete(numbersForDelete)
		assert.Nil(t, err, "Uint32SliceDelete should not return error")

		isContentChanged = treasureInterface.IsContentChanged()
		assert.True(t, isContentChanged, "IsContentChanged should return true")

		// ellenőrizzük a slice méretét
		size, err = treasureInterface.Uint32SliceSize()
		assert.Nil(t, err, "Uint32SliceSize should not return error")
		assert.Equal(t, 0, size, "Uint32SliceSize should return 0")

		treasureInterface.ResetContentUint32Slice(guardID)
		assert.Equal(t, treasureInterface.GetContentType(), ContentTypeVoid)

		treasureInterface.ReleaseTreasureGuard(guardID)
	})

	t.Run("should return uint8 when treasure content is uint8", func(t *testing.T) {
		treasureInterface := New(MySaveMethod)
		guardID := treasureInterface.StartTreasureGuard(true)
		testInt := uint8(12)
		treasureInterface.SetContentUint8(guardID, testInt)
		assert.Equal(t, treasureInterface.GetContentType(), ContentTypeUint8)
		getInt, err := treasureInterface.GetContentUint8()
		assert.Equal(t, err, nil)
		assert.Equal(t, getInt, testInt)

		treasureInterface.ResetContentUint8(guardID)
		assert.Equal(t, treasureInterface.GetContentType(), ContentTypeVoid)

		treasureInterface.ReleaseTreasureGuard(guardID)
	})

	t.Run("should return uint16 when treasure content is uint16", func(t *testing.T) {
		treasureInterface := New(MySaveMethod)
		guardID := treasureInterface.StartTreasureGuard(true)
		testInt := uint16(12)
		treasureInterface.SetContentUint16(guardID, testInt)
		assert.Equal(t, treasureInterface.GetContentType(), ContentTypeUint16)
		getInt, err := treasureInterface.GetContentUint16()
		assert.Equal(t, err, nil)
		assert.Equal(t, getInt, testInt)

		treasureInterface.ResetContentUint16(guardID)
		assert.Equal(t, treasureInterface.GetContentType(), ContentTypeVoid)

		treasureInterface.ReleaseTreasureGuard(guardID)
	})

	t.Run("should return uint32 when treasure content is uint32", func(t *testing.T) {
		treasureInterface := New(MySaveMethod)
		guardID := treasureInterface.StartTreasureGuard(true)
		testInt := uint32(12)
		treasureInterface.SetContentUint32(guardID, testInt)
		assert.Equal(t, treasureInterface.GetContentType(), ContentTypeUint32)
		getInt, err := treasureInterface.GetContentUint32()
		assert.Equal(t, err, nil)
		assert.Equal(t, getInt, testInt)

		treasureInterface.ResetContentUint32(guardID)
		assert.Equal(t, treasureInterface.GetContentType(), ContentTypeVoid)

		treasureInterface.ReleaseTreasureGuard(guardID)
	})

	t.Run("should return uint64 when treasure content is uint64", func(t *testing.T) {
		treasureInterface := New(MySaveMethod)
		guardID := treasureInterface.StartTreasureGuard(true)
		testInt := uint64(12)
		treasureInterface.SetContentUint64(guardID, testInt)
		assert.Equal(t, treasureInterface.GetContentType(), ContentTypeUint64)
		getInt, err := treasureInterface.GetContentUint64()
		assert.Equal(t, err, nil)
		assert.Equal(t, getInt, testInt)

		treasureInterface.ResetContentUint64(guardID)
		assert.Equal(t, treasureInterface.GetContentType(), ContentTypeVoid)

		treasureInterface.ReleaseTreasureGuard(guardID)
	})

	t.Run("should return int8 when treasure content is int8", func(t *testing.T) {
		treasureInterface := New(MySaveMethod)
		guardID := treasureInterface.StartTreasureGuard(true)
		testInt := int8(12)
		treasureInterface.SetContentInt8(guardID, testInt)
		assert.Equal(t, treasureInterface.GetContentType(), ContentTypeInt8)
		getInt, err := treasureInterface.GetContentInt8()
		assert.Equal(t, err, nil)
		assert.Equal(t, getInt, testInt)

		treasureInterface.ResetContentInt8(guardID)
		assert.Equal(t, treasureInterface.GetContentType(), ContentTypeVoid)

		treasureInterface.ReleaseTreasureGuard(guardID)
	})

	t.Run("should return int32 when treasure content is int32", func(t *testing.T) {
		treasureInterface := New(MySaveMethod)
		guardID := treasureInterface.StartTreasureGuard(true)
		testInt := int32(12)
		treasureInterface.SetContentInt32(guardID, testInt)
		assert.Equal(t, treasureInterface.GetContentType(), ContentTypeInt32)
		getInt, err := treasureInterface.GetContentInt32()
		assert.Equal(t, err, nil)
		assert.Equal(t, getInt, testInt)

		treasureInterface.ResetContentInt32(guardID)
		assert.Equal(t, treasureInterface.GetContentType(), ContentTypeVoid)

		treasureInterface.ReleaseTreasureGuard(guardID)
	})

	t.Run("should return int64 when treasure content is int64", func(t *testing.T) {
		treasureInterface := New(MySaveMethod)
		guardID := treasureInterface.StartTreasureGuard(true)
		testInt := int64(12)
		treasureInterface.SetContentInt64(guardID, testInt)
		assert.Equal(t, treasureInterface.GetContentType(), ContentTypeInt64)
		getInt, err := treasureInterface.GetContentInt64()
		assert.Equal(t, err, nil)
		assert.Equal(t, getInt, testInt)

		treasureInterface.ResetContentInt64(guardID)
		assert.Equal(t, treasureInterface.GetContentType(), ContentTypeVoid)

		treasureInterface.ReleaseTreasureGuard(guardID)
	})

	t.Run("should return float32 when treasure content is float32", func(t *testing.T) {
		treasureInterface := New(MySaveMethod)
		guardID := treasureInterface.StartTreasureGuard(true)
		testFloat := float32(12.0)
		treasureInterface.SetContentFloat32(guardID, testFloat)
		assert.Equal(t, treasureInterface.GetContentType(), ContentTypeFloat32)
		getFloat, err := treasureInterface.GetContentFloat32()
		assert.Equal(t, err, nil)
		assert.Equal(t, getFloat, testFloat)

		treasureInterface.ResetContentFloat32(guardID)
		assert.Equal(t, treasureInterface.GetContentType(), ContentTypeVoid)
		treasureInterface.ReleaseTreasureGuard(guardID)

	})

	t.Run("should return float64 when treasure content is float64", func(t *testing.T) {
		treasureInterface := New(MySaveMethod)
		guardID := treasureInterface.StartTreasureGuard(true)
		testFloat := 12.0
		treasureInterface.SetContentFloat64(guardID, testFloat)
		assert.Equal(t, treasureInterface.GetContentType(), ContentTypeFloat64)
		getFloat, err := treasureInterface.GetContentFloat64()
		assert.Equal(t, err, nil)
		assert.Equal(t, getFloat, testFloat)

		treasureInterface.ResetContentFloat64(guardID)
		assert.Equal(t, treasureInterface.GetContentType(), ContentTypeVoid)

		treasureInterface.ReleaseTreasureGuard(guardID)
	})

	t.Run("should return ContentTypeString when treasure content is ContentTypeString", func(t *testing.T) {
		treasureInterface := New(MySaveMethod)
		guardID := treasureInterface.StartTreasureGuard(true)
		testString := "test"
		treasureInterface.SetContentString(guardID, testString)
		assert.Equal(t, treasureInterface.GetContentType(), ContentTypeString)
		getString, err := treasureInterface.GetContentString()
		assert.Equal(t, err, nil)
		assert.Equal(t, getString, testString)

		treasureInterface.ResetContentString(guardID)
		assert.Equal(t, treasureInterface.GetContentType(), ContentTypeVoid)

		treasureInterface.ReleaseTreasureGuard(guardID)
	})

	t.Run("should return ContentTypeBoolean when treasure content is ContentTypeBoolean", func(t *testing.T) {
		treasureInterface := New(MySaveMethod)
		guardID := treasureInterface.StartTreasureGuard(true)
		treasureInterface.SetContentBool(guardID, true)
		assert.Equal(t, treasureInterface.GetContentType(), ContentTypeBoolean)
		getBool, err := treasureInterface.GetContentBool()
		assert.Equal(t, err, nil)
		assert.Equal(t, getBool, true)

		treasureInterface.ResetContentBool(guardID)
		assert.Equal(t, treasureInterface.GetContentType(), ContentTypeVoid)

		treasureInterface.ReleaseTreasureGuard(guardID)
	})

	t.Run("should return ContentTypeByteArray when treasure content is ContentTypeByteArray", func(t *testing.T) {
		treasureInterface := New(MySaveMethod)
		guardID := treasureInterface.StartTreasureGuard(true)
		testBytes := []byte("test")
		treasureInterface.SetContentByteArray(guardID, testBytes)
		assert.Equal(t, treasureInterface.GetContentType(), ContentTypeByteArray)
		getBytes, err := treasureInterface.GetContentByteArray()
		assert.Equal(t, err, nil)
		assert.Equal(t, getBytes, testBytes)

		treasureInterface.ResetContentByteArray(guardID)
		assert.Equal(t, treasureInterface.GetContentType(), ContentTypeVoid)

		treasureInterface.ReleaseTreasureGuard(guardID)
	})

	t.Run("should return with correct creator and modifier data", func(t *testing.T) {

		treasureInterface := New(MySaveMethod)
		guardID := treasureInterface.StartTreasureGuard(true)
		treasureInterface.SetContentString(guardID, "test")

		treasureInterface.SetCreatedBy(guardID, "creator-user")
		treasureInterface.SetCreatedAt(guardID, time.Now())
		treasureInterface.SetModifiedBy(guardID, "modifier-user")
		treasureInterface.SetModifiedAt(guardID, time.Now())

		assert.Equal(t, treasureInterface.GetModifiedBy(), "modifier-user")
		assert.Equal(t, treasureInterface.GetCreatedBy(), "creator-user")
		assert.LessOrEqual(t, treasureInterface.GetCreatedAt(), time.Now().UnixNano())
		assert.LessOrEqual(t, treasureInterface.GetModifiedAt(), time.Now().UnixNano())

		treasureInterface.ReleaseTreasureGuard(guardID)
	})

	t.Run("should set and get the expiration time of the treasure", func(t *testing.T) {
		treasureInterface := New(MySaveMethod)
		guardID := treasureInterface.StartTreasureGuard(true)
		treasureInterface.SetContentString(guardID, "test")
		treasureInterface.SetExpirationTime(guardID, time.Now().Add(time.Hour))
		assert.Greater(t, treasureInterface.GetExpirationTime(), time.Now().UnixNano(), "Expiration time should be greater than current time")
		treasureInterface.ReleaseTreasureGuard(guardID)
	})

	t.Run("should clone treasure", func(t *testing.T) {

		treasureInterface := New(MySaveMethod)
		guardID := treasureInterface.StartTreasureGuard(true, guard.BodyAuthID)

		treasureInterface.BodySetKey(guardID, "test-key")
		treasureInterface.SetContentString(guardID, "test")

		cloneTreasure := treasureInterface.Clone(guardID)
		treasureInterface.ReleaseTreasureGuard(guardID)

		assert.Equal(t, "test-key", cloneTreasure.GetKey())
		contentString, err := cloneTreasure.GetContentString()
		assert.Nil(t, err)
		assert.Equal(t, contentString, "test")

		if cloneTreasure.GetKey() != "test-key" {
			t.Error("Clone should not have file name")
		}

	})

	t.Run("should clone just the ContentTypeString content of the treasure", func(t *testing.T) {

		treasureInterface := New(MySaveMethod)
		guardID := treasureInterface.StartTreasureGuard(true, guard.BodyAuthID)

		treasureInterface.BodySetKey(guardID, "test-key")
		treasureInterface.SetContentString(guardID, "test")

		clonedContent := treasureInterface.CloneContent(guardID)
		treasureInterface.ReleaseTreasureGuard(guardID)

		expectedString := "test"
		if *clonedContent.String != expectedString {
			t.Error("Cloned content should be test")
		}

	})

	t.Run("should clone just the Integer content of the treasure", func(t *testing.T) {

		treasureInterface := New(MySaveMethod)
		guardID := treasureInterface.StartTreasureGuard(true, guard.BodyAuthID)

		treasureInterface.BodySetKey(guardID, "test-key")
		treasureInterface.SetContentInt64(guardID, 12)

		clonedContent := treasureInterface.CloneContent(guardID)
		treasureInterface.ReleaseTreasureGuard(guardID)

		expectedInt := int64(12)
		if *clonedContent.Int64 != expectedInt {
			t.Error("Cloned content should be 12")
		}

	})

	t.Run("should clone just the ContentTypeFloat64 content of the treasure", func(t *testing.T) {

		treasureInterface := New(MySaveMethod)
		guardID := treasureInterface.StartTreasureGuard(true, guard.BodyAuthID)

		treasureInterface.BodySetKey(guardID, "test-key")
		treasureInterface.SetContentFloat64(guardID, 12.0)

		clonedContent := treasureInterface.CloneContent(guardID)
		treasureInterface.ReleaseTreasureGuard(guardID)

		expectedFloat := 12.0
		if *clonedContent.Float64 != expectedFloat {
			t.Error("Cloned content should be 12.0")
		}

	})

	t.Run("should clone just the ContentTypeBoolean content of the treasure", func(t *testing.T) {

		treasureInterface := New(MySaveMethod)
		guardID := treasureInterface.StartTreasureGuard(true, guard.BodyAuthID)

		treasureInterface.BodySetKey(guardID, "test-key")
		treasureInterface.SetContentBool(guardID, true)

		clonedContent := treasureInterface.CloneContent(guardID)
		treasureInterface.ReleaseTreasureGuard(guardID)

		if *clonedContent.Boolean != true {
			t.Error("Cloned content should be true")
		}

	})

	t.Run("should clone just the ContentTypeByteArray content of the treasure", func(t *testing.T) {

		treasureInterface := New(MySaveMethod)
		guardID := treasureInterface.StartTreasureGuard(true, guard.BodyAuthID)

		testBytes := []byte("test")
		treasureInterface.BodySetKey(guardID, "test-key")
		treasureInterface.SetContentByteArray(guardID, testBytes)

		clonedContent := treasureInterface.CloneContent(guardID)
		treasureInterface.ReleaseTreasureGuard(guardID)

		if string(clonedContent.ByteArray) != string(testBytes) {
			t.Error("Cloned content should be test")
		}

	})

	t.Run("should clone just the ContentTypeVoid content of the treasure", func(t *testing.T) {

		treasureInterface := New(MySaveMethod)
		guardID := treasureInterface.StartTreasureGuard(true, guard.BodyAuthID)

		treasureInterface.BodySetKey(guardID, "test-key")
		treasureInterface.SetContentVoid(guardID)

		clonedContent := treasureInterface.CloneContent(guardID)
		treasureInterface.ReleaseTreasureGuard(guardID)

		if clonedContent.Void == false {
			t.Error("Cloned content should be ContentTypeVoid")
		}

	})

	t.Run("should set content from content interface", func(t *testing.T) {

		treasureInterface := New(MySaveMethod)
		guardID := treasureInterface.StartTreasureGuard(true)

		testStringContent := "test"
		content := Content{
			String: &testStringContent,
		}

		treasureInterface.SetContent(guardID, content)

		assert.Equal(t, treasureInterface.GetContentType(), ContentTypeString)
		contentString, err := treasureInterface.GetContentString()
		assert.Nil(t, err)
		assert.Equal(t, contentString, "test")

		treasureInterface.ReleaseTreasureGuard(guardID)

	})

	t.Run("should set the file name of the treasure", func(t *testing.T) {

		treasureInterface := New(MySaveMethod)
		guardID := treasureInterface.StartTreasureGuard(true, guard.BodyAuthID)
		treasureInterface.BodySetKey(guardID, "test-key")
		treasureInterface.SetContentString(guardID, "test")

		treasureInterface.BodySetFileName(guardID, "test-file-name")

		assert.Equal(t, *treasureInterface.GetFileName(), "test-file-name")
		treasureInterface.ReleaseTreasureGuard(guardID)

	})

	t.Run("should the treasure expired", func(t *testing.T) {

		treasureInterface := New(MySaveMethod)
		guardID := treasureInterface.StartTreasureGuard(true, guard.BodyAuthID)
		treasureInterface.BodySetKey(guardID, "test-key")
		treasureInterface.SetContentString(guardID, "test")

		assert.Equal(t, treasureInterface.IsExpired(), false)

		treasureInterface.SetExpirationTime(guardID, time.Now().Add(-time.Hour))

		assert.Equal(t, treasureInterface.IsExpired(), true)

		treasureInterface.ReleaseTreasureGuard(guardID)

	})

	t.Run("should get the deleted at and deleted by of the treasure", func(t *testing.T) {

		treasureInterface := New(MySaveMethod)
		guardID := treasureInterface.StartTreasureGuard(true, guard.BodyAuthID)
		treasureInterface.BodySetKey(guardID, "test-key")
		treasureInterface.SetContentString(guardID, "test")

		treasureInterface.BodySetForDeletion(guardID, "remover-user", false)

		assert.Equal(t, "remover-user", treasureInterface.GetDeletedBy())
		assert.LessOrEqual(t, treasureInterface.GetDeletedAt(), time.Now().UnixNano())
		assert.Equal(t, ContentTypeVoid, treasureInterface.GetContentType())

		// set the content again for the treasure
		treasureInterface.BodySetKey(guardID, "test-key")
		treasureInterface.SetContentString(guardID, "test")

		assert.Equal(t, "", treasureInterface.GetDeletedBy())
		assert.Equal(t, int64(0), treasureInterface.GetDeletedAt())

		treasureInterface.ReleaseTreasureGuard(guardID)

	})

	t.Run("should test the treasure save method", func(t *testing.T) {

		executed := false
		var SaveFunc = func(t Treasure, guardID guard.ID) TreasureStatus {
			executed = true
			return StatusNew
		}

		treasureInterface := New(SaveFunc)
		guardID := treasureInterface.StartTreasureGuard(true, guard.BodyAuthID)
		treasureInterface.BodySetKey(guardID, "test-key")
		status := treasureInterface.Save(guardID)
		treasureInterface.ReleaseTreasureGuard(guardID)
		assert.Equal(t, StatusNew, status)
		time.Sleep(100 * time.Millisecond)

		assert.Equal(t, true, executed)

	})

}

--------------------------------------------------------------------------------

/==============================================================================\
| FILE: core\hydra\swamp\vigil\vigil.go
| PATH: C:\go\src\hydraide\app\core\hydra\swamp\vigil\vigil.go
| SIZE: 3.1 KB
\==============================================================================/

// Package vigil is a simple synchronization tool that helps monitor whether there is any ongoing operation on
// the bridge in the swamp. The server needs this when the graceful stop command has to wait for the completion
// of the last database operation before shutting down Hydra and all other services.
// At the beginning of each database operation, we signal the presence of an active operation by calling the BeginVigil() method.
// At the completion of each database operation, we signal that there are no more active operations by calling the CeaseVigil() method.
package vigil

import (
	"sync"
	"sync/atomic"
)

// Vigil is an interface for managing the state of ongoing operations within the Hydra database.
// It ensures that the database remains operational as long as there are active operations to monitor,
// such as reads and writes. By providing an operation count mechanism, it acts as a safeguard against
// accidentally terminating the database, thus preventing data corruption or loss.
type Vigil interface {

	// BeginVigil indicates that a new operation has started.
	// !!! IMPORTANT !!!: Always call this method before executing any database-related operations.
	// When this method is called, it means that the Hydra database is actively being used
	// and should not be stopped. Each BeginVigil call should be paired with a corresponding CeaseVigil call.
	// Failure to call CeaseVigil will prevent the Hydra database from ever being properly shut down.
	BeginVigil()

	// CeaseVigil indicates that an operation has been completed.
	// When this method is called, it decrements the count of active operations.
	// If there are no more active operations, the Hydra database can be safely shut down.
	CeaseVigil()

	// HasActiveVigils returns a boolean value that indicates whether there are ongoing operations that
	// are currently being monitored. Returns true if active operations exist, false otherwise.
	//
	// Important Note: The function should not be invoked by the Hydra Head because it's the responsibility of the
	// Hydra to determine whether it can be shut down or not using this function!
	HasActiveVigils() bool

	// WaitForActiveVigilsClosed blocks the calling goroutine until all active operations are complete.
	// This ensures that you do not terminate the Hydra database while it's being used, preventing
	// potential data corruption or loss.
	//
	// Important Note: The function should not be invoked by the Hydra Head because it's the responsibility of the
	// Hydra to determine whether it can be shut down or not using this function!
	WaitForActiveVigilsClosed()
}

type vigil struct {
	mu     sync.RWMutex
	cond   *sync.Cond
	vigils int64
}

func New() Vigil {
	v := &vigil{}
	v.cond = sync.NewCond(&v.mu)
	return v
}

func (v *vigil) BeginVigil() {
	atomic.AddInt64(&v.vigils, 1)
}

func (v *vigil) CeaseVigil() {
	atomic.AddInt64(&v.vigils, -1)
	v.cond.Broadcast()
}

func (v *vigil) HasActiveVigils() bool {
	return atomic.LoadInt64(&v.vigils) > 0
}

func (v *vigil) WaitForActiveVigilsClosed() {
	v.cond.L.Lock()
	defer v.cond.L.Unlock()
	for v.HasActiveVigils() {
		v.cond.Wait()
	}
}

--------------------------------------------------------------------------------

/==============================================================================\
| FILE: core\hydra\swamp\vigil\vigil_test.go
| PATH: C:\go\src\hydraide\app\core\hydra\swamp\vigil\vigil_test.go
| SIZE: 1.1 KB
\==============================================================================/

package vigil

import (
	"sync/atomic"
	"testing"
)

func TestNew(t *testing.T) {

	vigilObj := New()
	vigilObj.BeginVigil()

	if !vigilObj.HasActiveVigils() {
		t.Errorf("Expected true, got false")
	}

	vigilObj.CeaseVigil()

	if vigilObj.HasActiveVigils() {
		t.Errorf("Expected false, got true")
	}

}

func TestWaitingForUnlock(t *testing.T) {

	vigilObj := New()

	allTransactions := int32(10000)

	counter := int32(0)
	for i := int32(0); i < allTransactions; i++ {
		vigilObj.BeginVigil()
		go func() {
			atomic.AddInt32(&counter, 1)
			vigilObj.CeaseVigil()
		}()
	}

	vigilObj.WaitForActiveVigilsClosed()

	if counter != allTransactions {
		t.Errorf("Expected 100, got %d", counter)
	}

}

// goos: windows
// goarch: amd64
// pkg: github.com/trendizz/neendb/neen/transaction
// cpu: AMD Ryzen 9 5950X 16-Core Processor
// BenchmarkNew
// BenchmarkNew-32         235088299                5.104 ns/op
// PASS
func BenchmarkNew(b *testing.B) {

	vigilObj := New()

	for i := 0; i < b.N; i++ {
		vigilObj.BeginVigil()
		vigilObj.CeaseVigil()
	}

}

--------------------------------------------------------------------------------

/==============================================================================\
| FILE: core\hydra\target\target.go
| PATH: C:\go\src\hydraide\app\core\hydra\target\target.go
| SIZE: 320.0 B
\==============================================================================/

package target

import "github.com/hydraide/hydraide/app/core/hydra/swamp/treasure"

type Targets struct {
	TargetSwamps map[string]*Target `json:"targets"`
}

type Target struct {
	TargetSwampName string                           `json:"tsn"`
	EventTypes      map[treasure.TreasureStatus]bool `json:"et"`
}

--------------------------------------------------------------------------------

/==============================================================================\
| FILE: core\README.md
| PATH: C:\go\src\hydraide\app\core\README.md
| SIZE: 0.0 B
\==============================================================================/



--------------------------------------------------------------------------------

/==============================================================================\
| FILE: core\safeops\safeops.go
| PATH: C:\go\src\hydraide\app\core\safeops\safeops.go
| SIZE: 2.7 KB
\==============================================================================/

// Package safeops provides a simple mechanism for locking the system during database-related operations to ensure data integrity
// and prevent the system from shutting down while any operation is running.
package safeops

import (
	"sync"
	"sync/atomic"
	"time"
)

type Safeops interface {

	// LockSystem prevents the system from shutting down. This function must be invoked before executing any database-related operations.
	// Its purpose is to prevent the system from shutting down any database-related processes or the system itself while the database operation is running.
	LockSystem()

	// MonitorPanic returns a channel that can be monitored. If a true message arrives on the channel, it indicates that a panic has occurred,
	// and the safeops emergency shutdown process should begin. During this process, no new requests are accepted; only ongoing requests are completed.
	// Real-world scenario: Useful for handling unexpected crashes or panics in the system, ensuring data integrity before shutting down.
	MonitorPanic() chan bool

	// UnlockSystem serves to unlock the system. It signals to the system that the database-related operation has completed, allowing the system to shut down if it wishes.
	UnlockSystem()

	// SystemLocked returns true if at least one process has requested a system transaction and has not yet released it.
	SystemLocked() bool

	// TriggerPanic is called when a panic occurs in the system. It sends a true value to the stopSignal channel, which can be monitored using WatchForApocalypse.
	TriggerPanic()

	// WaitForUnlock waits until the system releases the transaction. The function returns when there are no more active transaction requests in the system.
	// This is a blocking process with automatic release, which should be called before gracefulStop, allowing us to wait for the system to properly handle the locks.
	// Real-world scenario: Useful for ensuring that all critical operations have completed before initiating a safeops shutdown.
	WaitForUnlock()
}

type safeops struct {
	mu         sync.RWMutex
	stopSignal chan bool
	isLocked   int32
}

func New() Safeops {
	g := &safeops{
		stopSignal: make(chan bool),
	}
	return g
}

func (s *safeops) LockSystem() {
	atomic.AddInt32(&s.isLocked, 1)
}

func (s *safeops) UnlockSystem() {
	atomic.AddInt32(&s.isLocked, -1)
}

func (s *safeops) SystemLocked() bool {
	return atomic.LoadInt32(&s.isLocked) > 0
}

func (s *safeops) MonitorPanic() chan bool {
	return s.stopSignal
}

func (s *safeops) TriggerPanic() {
	s.stopSignal <- true
}

func (s *safeops) WaitForUnlock() {
	// waiting until the s.isLocked will be 0
	for {
		if !s.SystemLocked() {
			break
		}
		time.Sleep(100 * time.Millisecond)
	}
}

--------------------------------------------------------------------------------

/==============================================================================\
| FILE: core\safeops\safeops_test.go
| PATH: C:\go\src\hydraide\app\core\safeops\safeops_test.go
| SIZE: 3.0 KB
\==============================================================================/

package safeops

import (
	"testing"
	"time"
)

func TestSealTheGates(t *testing.T) {

	e := New()

	// Test to ensure the gates are not sealed initially
	if e.SystemLocked() {
		t.Errorf("The Safeops gates are sealed by default, which should not be the case.")
	}

	// Invoke the LockSystem method
	e.LockSystem()

	// Test to ensure the gates are now sealed
	if !e.SystemLocked() {
		t.Errorf("The Safeops gates are not sealed, but they should be.")
	}

}

func TestUnsealTheGates(t *testing.T) {

	e := New()

	// First, seal the gates to set up the test scenario
	e.LockSystem()

	// Test to ensure the gates are indeed sealed
	if !e.SystemLocked() {
		t.Errorf("The Safeops gates are not sealed, but they should be for this test.")
	}

	// Invoke the UnlockSystem method
	e.UnlockSystem()

	// Test to ensure the gates are now unsealed
	if e.SystemLocked() {
		t.Errorf("The Safeops gates are still sealed, but they should be unsealed.")
	}

}

func TestGatesSealed(t *testing.T) {

	e := New()

	// Test to ensure that the gates are initially unsealed
	if e.SystemLocked() {
		t.Errorf("The Safeops gates are initially sealed, but they should be unsealed.")
	}

	// Seal the gates
	e.LockSystem()

	// Test to ensure the gates are now sealed
	if !e.SystemLocked() {
		t.Errorf("The Safeops gates are not sealed, but they should be sealed.")
	}

	// Unseal the gates
	e.UnlockSystem()

	// Test to ensure the gates are unsealed again
	if e.SystemLocked() {
		t.Errorf("The Safeops gates are still sealed, but they should be unsealed.")
	}
}

func TestWatchForApocalypse(t *testing.T) {

	e := New()

	// Create a channel to capture the panic signal
	apocalypseChan := e.MonitorPanic()

	// Create a channel to signal test completion
	done := make(chan bool)

	go func() {
		// Watch for apocalypse signal
		select {
		case <-apocalypseChan:
			// Signal received, test should pass
			done <- true
		case <-time.After(1 * time.Second):
			// Timeout, test should fail
			done <- false
		}
	}()

	// Sound the horns to trigger apocalypse
	e.TriggerPanic()

	// Wait for the result
	if !<-done {
		t.Errorf("Failed to receive apocalypse signal, MonitorPanic is not working as expected.")
	}
}

func TestAwaitUnsealing(t *testing.T) {

	e := New()

	// Initially, the gates should be unsealed
	if e.SystemLocked() {
		t.Errorf("Initially, the gates should not be sealed.")
	}

	// Create a channel to signal test completion
	done := make(chan bool)

	go func() {
		// Listen for unsealing completion
		e.WaitForUnlock()
		done <- true
	}()

	// Seal the gates
	e.LockSystem()
	if !e.SystemLocked() {
		t.Errorf("After sealing, the gates should be sealed.")
	}

	// Unseal the gates
	e.UnlockSystem()
	if e.SystemLocked() {
		t.Errorf("After unsealing, the gates should not be sealed.")
	}

	// Check if the WaitForUnlock has finished
	select {
	case <-done:
		// Test passed
	case <-time.After(1 * time.Second):
		t.Errorf("WaitForUnlock did not complete as expected.")
	}
}

--------------------------------------------------------------------------------

/==============================================================================\
| FILE: core\settings\setting\setting.go
| PATH: C:\go\src\hydraide\app\core\settings\setting\setting.go
| SIZE: 3.5 KB
\==============================================================================/

package setting

import (
	"github.com/hydraide/hydraide/app/name"
	"time"
)

type Setting interface {
	// GetPattern returns the pattern.
	// Real-world scenario: Useful for debugging or logging to know where the swamp's data is physically stored
	GetPattern() name.Name
	// GetMaxFileSizeByte returns the maximum file size that a swamp's file can be.
	// Real-world scenario: If you have a swamp that is write-heavy and rarely deletes data, setting a higher value can
	// improve performance. If the swamp frequently deletes or modifies data, a smaller value can be more efficient.
	GetMaxFileSizeByte() int64
	// GetCloseAfterIdle returns the time after which a swamp should close itself if it's not being used.
	// Real-world scenario: For swamps that are frequently accessed, setting a higher value ensures that they remain
	// in memory for quicker access. For rarely accessed swamps, a lower value helps in freeing up memory.
	GetCloseAfterIdle() time.Duration
	// GetWriteInterval returns the time interval at which the swamp writes its data to SSD.
	// Real-world scenario: For swamps that are rarely modified, a higher value reduces unnecessary writes.
	// For swamps that are frequently modified, a lower value ensures that changes are saved more frequently.
	// If a swamp experiences a high volume of changes, it's advisable to set this value to no less than one minute
	// to batch writes and reduce both SSD and memory load.
	GetWriteInterval() time.Duration
	// GetSwampType returns the type of the swamp.
	// Real-world scenario: In-memory swamps are useful for testing and broadcasting data between services.
	// Permanent swamps are useful for storing data that needs to be persisted.
	GetSwampType() SwampType
}

type SwampType string

const (
	// InMemorySwamp the swamp just keeps the data in memory and doesn't write to SSD.
	InMemorySwamp SwampType = "InMemorySwamp"
	// PermanentSwamp the swamp writes to SSD. CloseAfterIdleSec, WriteIntervalSec, MaxFileSizeByte  settings are used.
	PermanentSwamp SwampType = "PermanentSwamp"
)

type SwampSetting struct {
	Pattern name.Name
	// InMemory true if the swamp just keeps the data in memory and doesn't write to SSD.
	// useful for testing and broadcasting data between services.
	InMemory bool
	// CloseAfterIdleSec Only used if InMemory is false, because the in-memory swamps never close.
	CloseAfterIdleSec time.Duration
	// WriteIntervalSec Only used if InMemory is false, because the in-memory swamps never write to SSD.
	WriteIntervalSec time.Duration
	// MaxFileSizeByte The maximum file size of the swamp's file. Only used if the swamp is not in-memory swamp (i.e. it writes to SSD).
	MaxFileSizeByte int64
}

type setting struct {
	ws *SwampSetting
}

func New(ws *SwampSetting) Setting {
	return &setting{
		ws: ws,
	}
}

// GetPattern get the pattern
func (s *setting) GetPattern() name.Name {
	return s.ws.Pattern
}

// GetMaxFileSizeByte get the max loader size byte of the swamp
func (s *setting) GetMaxFileSizeByte() int64 {
	return s.ws.MaxFileSizeByte
}

// GetCloseAfterIdle get the close after idle seconds of the swamp
func (s *setting) GetCloseAfterIdle() time.Duration {
	return s.ws.CloseAfterIdleSec
}

// GetWriteInterval get the write interval seconds of the swamp
func (s *setting) GetWriteInterval() time.Duration {
	return s.ws.WriteIntervalSec
}

// GetSwampType get the swamp type
func (s *setting) GetSwampType() SwampType {
	if s.ws.InMemory {
		return InMemorySwamp
	}
	return PermanentSwamp
}

--------------------------------------------------------------------------------

/==============================================================================\
| FILE: core\settings\setting\setting_test.go
| PATH: C:\go\src\hydraide\app\core\settings\setting\setting_test.go
| SIZE: 1.7 KB
\==============================================================================/

package setting

import (
	"github.com/hydraide/hydraide/app/name"
	"github.com/stretchr/testify/assert"
	"testing"
	"time"
)

func TestNew(t *testing.T) {

	t.Run("should test works", func(t *testing.T) {

		sanctuary := "dizzlets"
		realm := "trendizz.com"
		swamp := "info"

		swampSetting := &SwampSetting{
			Pattern:           name.New().Sanctuary(sanctuary).Realm(realm).Swamp(swamp),
			CloseAfterIdleSec: 1 * time.Second,
			WriteIntervalSec:  2 * time.Second,
			MaxFileSizeByte:   65536,
		}

		settingObject := New(swampSetting)

		assert.Equal(t, swampSetting.Pattern, settingObject.GetPattern())
		assert.Equal(t, int64(65536), settingObject.GetMaxFileSizeByte())
		assert.Equal(t, time.Duration(1)*time.Second, settingObject.GetCloseAfterIdle())
		assert.Equal(t, time.Duration(2)*time.Second, settingObject.GetWriteInterval())
		assert.Equal(t, PermanentSwamp, settingObject.GetSwampType())

	})

	t.Run("should test works with asterix pattern and in-memory swamp", func(t *testing.T) {

		sanctuary := "dizzlets"
		realm := "*"
		swamp := "info"

		swampSetting := &SwampSetting{
			Pattern:           name.New().Sanctuary(sanctuary).Realm(realm).Swamp(swamp),
			CloseAfterIdleSec: 1 * time.Second,
			WriteIntervalSec:  2 * time.Second,
			MaxFileSizeByte:   65536,
			InMemory:          true,
		}

		settingObject := New(swampSetting)

		assert.Equal(t, swampSetting.Pattern, settingObject.GetPattern())
		assert.Equal(t, int64(65536), settingObject.GetMaxFileSizeByte())
		assert.Equal(t, time.Duration(1)*time.Second, settingObject.GetCloseAfterIdle())
		assert.Equal(t, time.Duration(2)*time.Second, settingObject.GetWriteInterval())
		assert.Equal(t, InMemorySwamp, settingObject.GetSwampType())

	})

}

--------------------------------------------------------------------------------

/==============================================================================\
| FILE: core\settings\settings.go
| PATH: C:\go\src\hydraide\app\core\settings\settings.go
| SIZE: 11.5 KB
\==============================================================================/

// Package settings provides the ability to load and reload the setting from the config.yaml file.
package settings

import (
	"encoding/json"
	"fmt"
	"github.com/hydraide/hydraide/app/core/settings/setting"
	"github.com/hydraide/hydraide/app/name"
	"log/slog"
	"os"
	"path"
	"path/filepath"
	"sync"
	"time"
)

// Settings is the interface for managing configuration settings
type Settings interface {
	// GetHashFolderDepth returns the depth of the hash folder
	GetHashFolderDepth() int
	// GetMaxFoldersPerLevel returns the maximum number of folders in a hash folder
	GetMaxFoldersPerLevel() int
	// GetHydraAbsDataFolderPath returns the absolute path of the hydra data folder
	GetHydraAbsDataFolderPath() string
	// GetBySwampName loads the settings for a specific swamp based on its name.
	// Real-world scenario: When initializing a new swamp, you can use this function to apply pre-configured settings
	// for that specific swamp.
	GetBySwampName(swampName name.Name) setting.Setting
	// RegisterPattern registers a pattern for a swamp to the settings
	// useful when the hydra register a new Head to the system with new swamp patterns
	RegisterPattern(pattern name.Name, inMemorySwamp bool, closeAfterIdleSec int64, filesystemSettings *FileSystemSettings)
	// DeregisterPattern deregister a pattern from the settings
	DeregisterPattern(pattern name.Name)
	// CallbackAtChanges wait a callback function and the settigns will call it when the settings changed
	CallbackAtChanges(func()) chan bool
}

const (
	fileName      = "settings.json"
	writetestFile = "writetest"
)

var (
	hydraDataFolderPath     = ""
	hydraSettingsFolderPath = ""
)

type settings struct {
	mu                 sync.RWMutex
	modelMutex         sync.RWMutex
	model              *Model
	virtualNodesFrom   int
	virtualNodesTo     int
	defaultSetting     setting.Setting // nem kell kimenteni, mert a beállító fileban benne van mindig
	callbackFunctions  []func()        // nem kell kimenteni, mert újra feliratkozik akinek kell
	patterns           map[string]setting.Setting
	streamPath         string
	automoverPath      string
	pluginPath         string
	maxDepthOfFolders  int
	maxFoldersPerLevel int
}

type Model struct {
	Patterns      map[string]*PatternModel `json:"patterns,omitempty"`
	StreamPath    string                   `json:"streamPath,omitempty"`
	AutoMoverPath string                   `json:"autoMoverPath,omitempty"`
}

type PatternModel struct {
	NameCanonicalForm string `json:"nameCanonicalForm,omitempty"`
	InMemory          bool   `json:"inMemory,omitempty"`
	CloseAfterIdleSec int64  `json:"closeAfterIdleSec,omitempty"`
	WriteIntervalSec  int64  `json:"writeIntervalSec,omitempty"`
	MaxFileSizeByte   int64  `json:"maxFileSizeByte,omitempty"`
}

// New creates a new instance of the setting
func New(maxDepthOfFolders int, maxFoldersPerLevel int) Settings {

	// ellenőrizzük, hogy az alapvető mentési könyvtárak léteznek-e és írhatóak-e
	// ha nem léteznek, akkor létrehozzuk azokat írható formában
	hydraDataFolderPath = filepath.Join(os.Getenv("HYDRAIDE_ROOT_PATH"), "data")
	hydraSettingsFolderPath = filepath.Join(os.Getenv("HYDRAIDE_ROOT_PATH"), "settings")

	checkFolder(hydraDataFolderPath)
	checkFolder(hydraSettingsFolderPath)

	t := &settings{
		patterns: make(map[string]setting.Setting),
		model: &Model{
			Patterns: make(map[string]*PatternModel),
		},
		maxDepthOfFolders:  maxDepthOfFolders,
		maxFoldersPerLevel: maxFoldersPerLevel,
	}

	// load the saved settings from the filesystem at the startup
	if err := t.loadSettingsFromFilesystem(); err != nil {
		slog.Error("failed to load settings from filesystem", "error", err)
	}

	return t

}

func (s *settings) GetHashFolderDepth() int {
	return s.maxDepthOfFolders
}

func (s *settings) GetMaxFoldersPerLevel() int {
	return s.maxFoldersPerLevel
}

// GetHydraAbsDataFolderPath visszaadja a hydra alap adatmentési útvonalát
func (s *settings) GetHydraAbsDataFolderPath() string {
	// nem kell lockolni, mert ez egy konstans és az értéke nem változhat futásidő alatt,
	// így nem kell gátolni az egyidejű hozzáférést, ami lassítaná a rendszert
	return hydraDataFolderPath
}

// FileSystemSettings contains the settings for the filesystem-type swamps
type FileSystemSettings struct {
	// WriteIntervalSec is the time interval when the swamp will write the data to the filesystem
	WriteIntervalSec int64
	// MaxFileSizeByte is the maximum size of the file fragments of the swamp in bytes
	MaxFileSizeByte int64
}

// RegisterPattern registers a pattern for a swamp to the settings only if it is not exist
// inMemorySwamp is true if the swamp is in-memory type, otherwise it is false
// If the swamp is filesystem type, then the filesystemSettings must be set otherwise it is nil
func (s *settings) RegisterPattern(pattern name.Name, inMemorySwamp bool, closeAfterIdleSec int64, filesystemSettings *FileSystemSettings) {

	s.mu.Lock()
	defer s.mu.Unlock()

	swampSetting := &setting.SwampSetting{
		Pattern:           pattern,
		InMemory:          inMemorySwamp,
		CloseAfterIdleSec: time.Duration(closeAfterIdleSec) * time.Second,
	}

	// the swamp is filesystem type
	if !inMemorySwamp {

		// check if the pattern is already exist
		if _, ok := s.patterns[pattern.Get()]; ok {
			// check if the actual pattern setting is different from the new setting
			if s.patterns[pattern.Get()].GetCloseAfterIdle() == time.Duration(closeAfterIdleSec)*time.Second &&
				(filesystemSettings != nil &&
					(s.patterns[pattern.Get()].GetWriteInterval() == time.Duration(filesystemSettings.WriteIntervalSec)*time.Second &&
						s.patterns[pattern.Get()].GetMaxFileSizeByte() == filesystemSettings.MaxFileSizeByte)) {
				// do nothing, because the pattern is already exist and not changed
				// so, we don't need to save the settings to the filesystem
				return
			}
		}

		// create a new swamp setting
		s.patterns[pattern.Get()] = setting.New(swampSetting)
		if filesystemSettings != nil {
			swampSetting.WriteIntervalSec = time.Duration(filesystemSettings.WriteIntervalSec) * time.Second
			swampSetting.MaxFileSizeByte = filesystemSettings.MaxFileSizeByte
		}

	}

	// add the pattern to the Model
	func() {

		s.modelMutex.Lock()
		defer s.modelMutex.Unlock()

		pm := &PatternModel{
			NameCanonicalForm: pattern.Get(),
			InMemory:          inMemorySwamp,
		}

		if !inMemorySwamp {
			pm.WriteIntervalSec = filesystemSettings.WriteIntervalSec
			pm.MaxFileSizeByte = filesystemSettings.MaxFileSizeByte
		}

		pm.CloseAfterIdleSec = closeAfterIdleSec

		// set the pattern to the model
		s.model.Patterns[pattern.Get()] = pm

		if err := s.SaveSettingsToFilesystem(); err != nil {
			slog.Error("failed to save settings to filesystem", "error", err)
		}

	}()

	slog.Info("swamp pattern registered", "pattern", pattern.Get())

}

// DeregisterPattern deregister a pattern from the settings
func (s *settings) DeregisterPattern(pattern name.Name) {

	s.mu.Lock()
	defer s.mu.Unlock()

	func() {
		s.modelMutex.Lock()
		defer s.modelMutex.Unlock()
		delete(s.model.Patterns, pattern.Get())
		if err := s.SaveSettingsToFilesystem(); err != nil {
			slog.Error("failed to save settings to filesystem", "error", err)
		}
	}()

	delete(s.patterns, pattern.Get())

}

// GetBySwampName loads the setting of the swamp by the name of the swamp
func (s *settings) GetBySwampName(swampName name.Name) setting.Setting {

	s.mu.RLock()
	defer s.mu.RUnlock()

	if len(s.patterns) > 0 {
		for _, pi := range s.patterns {
			// compare if the pattern is math with the swamp name
			if swampName.ComparePattern(pi.GetPattern()) {
				return pi
			}
		}
	}

	// ha nem találunk olyan beállítást, ami a megadott mintához tartozik, akkor visszaadjuk az alapértelmezett beállítást
	// ebben az esetben is a mentés helye nem változik, csak a beállítások lesznek alapértelmezettek
	return setting.New(&setting.SwampSetting{
		Pattern:           swampName,
		CloseAfterIdleSec: time.Duration(5) * time.Second,
		WriteIntervalSec:  time.Duration(1) * time.Second,
		MaxFileSizeByte:   65536, // 64KB
	})

}

func (s *settings) CallbackAtChanges(f func()) chan bool {
	s.mu.Lock()
	defer s.mu.Unlock()
	s.callbackFunctions = append(s.callbackFunctions, f)
	return nil
}

func (s *settings) SaveSettingsToFilesystem() error {

	data, err := json.MarshalIndent(s.model, "", "  ")
	if err != nil {
		return fmt.Errorf("failed to marshal settings: %w", err)
	}

	filePath := path.Join(hydraSettingsFolderPath, fileName)

	err = os.MkdirAll(path.Join(hydraSettingsFolderPath), 0755)
	if err != nil {
		return fmt.Errorf("failed to create directory path: %w", err)
	}

	if err := os.WriteFile(filePath, data, 0644); err != nil {
		return fmt.Errorf("failed to write to file system: %w", err)
	}

	return nil

}

func (s *settings) loadSettingsFromFilesystem() error {

	s.modelMutex.Lock()
	defer s.modelMutex.Unlock()

	filePath := path.Join(hydraSettingsFolderPath, fileName)
	data, err := os.ReadFile(filePath)

	if err != nil {
		if os.IsNotExist(err) {
			return nil
		}
		return fmt.Errorf("failed to read file: %w", err)
	}

	if err := json.Unmarshal(data, &s.model); err != nil {
		return fmt.Errorf("failed to unmarshal settings: %w", err)
	}

	// Format the LoadedSettings as indented JSON
	formattedSettings, err := json.MarshalIndent(s.model, "", "  ")
	if err != nil {
		return fmt.Errorf("failed to marshal settings for logging: %w", err)
	}

	// Debug: Print the raw JSON data read from the file
	slog.Info("main settings loaded from filesystem successfully", "mainSettings", string(formattedSettings))

	// visszatöltjük a beállításokat a memóriába
	if s.model != nil {
		if s.model.Patterns != nil {
			for _, pattern := range s.model.Patterns {

				patternNameObj := name.Load(pattern.NameCanonicalForm)

				s.patterns[pattern.NameCanonicalForm] = setting.New(&setting.SwampSetting{
					Pattern:           patternNameObj,
					CloseAfterIdleSec: time.Duration(pattern.CloseAfterIdleSec) * time.Second,
					WriteIntervalSec:  time.Duration(pattern.WriteIntervalSec) * time.Second,
					MaxFileSizeByte:   pattern.MaxFileSizeByte,
				})

			}
		}
		if s.model.StreamPath != "" {
			s.streamPath = s.model.StreamPath
		}
		if s.model.AutoMoverPath != "" {
			s.automoverPath = s.model.AutoMoverPath
		}
	}

	return nil

}

// checkDataFolder ellenőrzi, hogy a hydra adatmentési könyvtár létezik-e és írható-e
func checkFolder(folderPath string) {
	// ellenőrizzük, hogy a folder létezik-e és írható-e
	if _, err := os.Stat(folderPath); os.IsNotExist(err) {
		slog.Info("Hydra folder does not exist", "folder", folderPath)
		// létrehozzuk a foldert minden subfolderrel együtt
		if err := os.MkdirAll(folderPath, 0755); err != nil {
			slog.Error("failed to create Hydra folder", "folder", folderPath, "error", err)
			panic("failed to create Hydra folder")
		}
	}
	// ellenőrizzük, hogy a folder írható-e
	if err := os.WriteFile(path.Join(folderPath, writetestFile), []byte("test"), 0644); err != nil {
		slog.Error("Hydraide folder is not writable", "folder", folderPath, "error", err)
		panic("Hydraide folder is not writable")
	}
	// töröljük a teszt fájlt
	if err := os.Remove(path.Join(folderPath, writetestFile)); err != nil {
		slog.Error("failed to remove test file", "error", err, "folder", folderPath)
		panic("failed to remove test file")
	}
}

--------------------------------------------------------------------------------

/==============================================================================\
| FILE: core\settings\settings_test.go
| PATH: C:\go\src\hydraide\app\core\settings\settings_test.go
| SIZE: 1.9 KB
\==============================================================================/

package settings

import (
	"fmt"
	"github.com/hydraide/hydraide/app/name"
	"github.com/stretchr/testify/assert"
	"testing"
	"time"
)

func TestNew(t *testing.T) {

	// destroy test folder

	t.Run("should load default setting for the swamp", func(t *testing.T) {

		maxDepthOfFolders := 2
		maxFoldersPerLevel := 100000

		configs := New(maxDepthOfFolders, maxFoldersPerLevel)

		swampName := name.New().Sanctuary("settingstest1").Realm("myrealm").Swamp("myswamp")

		configInterface := configs.GetBySwampName(swampName)

		assert.Equal(t, int64(65536), configInterface.GetMaxFileSizeByte(), "should be equal")
		assert.Equal(t, 5*time.Second, configInterface.GetCloseAfterIdle(), "should be equal")
		assert.Equal(t, 1*time.Second, configInterface.GetWriteInterval(), "should be equal")
		assert.Equal(t, swampName.Get(), configInterface.GetPattern().Get(), "should be equal")

	})

	t.Run("should add new pattern and sanctuary", func(t *testing.T) {

		maxDepthOfFolders := 2
		maxFoldersPerLevel := 2000

		configs := New(maxDepthOfFolders, maxFoldersPerLevel)
		pattern := name.New().Sanctuary("settingstest2").Realm("*").Swamp("info")

		configs.RegisterPattern(pattern, false, 5, &FileSystemSettings{
			WriteIntervalSec: 14,
			MaxFileSizeByte:  888888,
		})

		// töröljük a patternt
		defer configs.DeregisterPattern(pattern)

		// the swamp name does not match any pattern, so it should return the default settings
		settingsObj := configs.GetBySwampName(name.New().Sanctuary("settingstest2").Realm("index.hu").Swamp("info"))

		assert.NotNil(t, settingsObj, "should not be nil")

		fmt.Println("pattern:", settingsObj.GetPattern())

		assert.Equal(t, int64(888888), settingsObj.GetMaxFileSizeByte(), "should be equal")
		assert.Equal(t, 14*time.Second, settingsObj.GetWriteInterval(), "should be equal")
		assert.Equal(t, 5*time.Second, settingsObj.GetCloseAfterIdle(), "should be equal")

	})

}

--------------------------------------------------------------------------------

/==============================================================================\
| FILE: core\zeus\zeus.go
| PATH: C:\go\src\hydraide\app\core\zeus\zeus.go
| SIZE: 3.1 KB
\==============================================================================/

package zeus

import (
	"fmt"
	"github.com/hydraide/hydraide/app/core/filesystem"
	"github.com/hydraide/hydraide/app/core/hydra"
	"github.com/hydraide/hydraide/app/core/hydra/lock"
	"github.com/hydraide/hydraide/app/core/safeops"
	"github.com/hydraide/hydraide/app/core/settings"
	"log/slog"
	"os"
)

type Zeus interface {
	// InitDataFolder initializes the data folder for the hydra
	InitDataFolder() error
	// GetHydra the hydra interface from the Zeus
	GetHydra() hydra.Hydra
	// GetSafeops the safeops interface from the Zeus
	GetSafeops() safeops.Safeops
	// GetSettings the settings interface from the Zeus
	GetSettings() settings.Settings
	// StartHydra the Hydra
	StartHydra()
	// StopHydra graceful stops the hydra
	StopHydra()
}

type zeus struct {
	settingsInterface   settings.Settings
	safeopsInterface    safeops.Safeops
	hydraInterface      hydra.Hydra
	filesystemInterface filesystem.Filesystem
}

func New(settingsInterface settings.Settings, filesystemInterface filesystem.Filesystem) Zeus {
	z := &zeus{
		settingsInterface:   settingsInterface,
		filesystemInterface: filesystemInterface,
	}
	return z
}

func (z *zeus) InitDataFolder() error {

	// Lekérjük az abszolút elérési utat az adatfolderhez
	absPath := z.settingsInterface.GetHydraAbsDataFolderPath()
	// Ellenőrizzük, hogy az útvonal nem üres
	if absPath == "" {
		return fmt.Errorf("the data folder path is empty")
	}

	// Ellenőrizzük, hogy a mappa már létezik-e
	if _, err := os.Stat(absPath); err == nil {
		// A mappa már létezik, nem kell semmit tenni
		return nil
	} else if !os.IsNotExist(err) {
		// Ha valami más hiba történt az ellenőrzés során, visszaadjuk az errort
		return fmt.Errorf("error checking data folder: %s", err)
	}

	// Megpróbáljuk létrehozni az adatfoldert (és a hiányzó szülőmappákat, ha szükséges)
	if err := os.MkdirAll(absPath, 0755); err != nil {
		return fmt.Errorf("error creating data folder: %s", err)
	}

	return nil

}

func (z *zeus) GetSettings() settings.Settings {
	return z.settingsInterface
}

func (z *zeus) GetSafeops() safeops.Safeops {
	return z.safeopsInterface
}

func (z *zeus) GetHydra() hydra.Hydra {
	return z.hydraInterface
}

func (z *zeus) StartHydra() {

	slog.Info("HydrAIDE DataEngine is starting...")

	z.safeopsInterface = safeops.New()

	go func() {
		for {
			select {
			case <-z.safeopsInterface.MonitorPanic():
				slog.Error("Zeus is stopping the HydrAIDE because there was a panic in the system")
				z.StopHydra()
				return
			}
		}
	}()

	// hashRing interface init
	// create new hydra interface
	z.hydraInterface = hydra.New(z.settingsInterface, z.safeopsInterface, lock.New(), z.filesystemInterface)

}

func (z *zeus) StopHydra() {

	// Stops the hydra and all the swamps
	// this is a blocker function until all well are stopped gracefully
	z.hydraInterface.GracefulStop()

	// WaitForUnlock waits until the system releases the transaction. The function returns when there are no more active
	// transaction requests in the system.
	z.safeopsInterface.WaitForUnlock()

}

--------------------------------------------------------------------------------

/==============================================================================\
| FILE: core\zeus\zeus_test.go
| PATH: C:\go\src\hydraide\app\core\zeus\zeus_test.go
| SIZE: 6.5 KB
\==============================================================================/

package zeus

import (
	"context"
	"fmt"
	"github.com/hydraide/hydraide/app/core/filesystem"
	"github.com/hydraide/hydraide/app/core/hydra/swamp"
	"github.com/hydraide/hydraide/app/core/settings"
	"github.com/hydraide/hydraide/app/name"
	"strconv"
	"testing"
	"time"

	"github.com/stretchr/testify/require"
)

const (
	maxDepthOfFolders     = 3
	maxFoldersPerLevel    = 10000
	sanctuaryForQuickTest = "hydraquicktest"
)

func TestZeus_StartHydra(t *testing.T) {

	settingsInterface := settings.New(maxDepthOfFolders, maxFoldersPerLevel)
	fsInterface := filesystem.New()

	t.Run("test", func(t *testing.T) {

		zeusInterface := New(settingsInterface, fsInterface)
		zeusInterface.StartHydra()

		hydraInterface := zeusInterface.GetHydra()

		require.NotNil(t, hydraInterface)

		swampObject, err := hydraInterface.SummonSwamp(context.Background(), 10, name.New().Swamp("testSwamp"))
		defer swampObject.Destroy()

		swampObject.BeginVigil()
		require.NoError(t, err)
		require.NotNil(t, swampObject)

		// const content = "Lorem ipsum dolor sit amet, consectetur adipiscing elit. Mauris varius, ante sit amet placerat iaculis, quam metus congue nibh, ac pellentesque ex augue eu tellus"

		// insert treasures
		start := time.Now()
		for i := 1; i <= 10; i++ {
			treasureObj := swampObject.CreateTreasure(fmt.Sprintf("%d", i))
			treasureGuardID := treasureObj.StartTreasureGuard(true)
			treasureObj.SetContentInt64(treasureGuardID, int64(i))
			treasureObj.Save(treasureGuardID)
			treasureObj.ReleaseTreasureGuard(treasureGuardID)
		}
		end := time.Now()

		// calculate the elapsed time
		elapsed := end.Sub(start)

		fmt.Println("insert treasures elapsed time: ", elapsed)

		// get treasures from the beacon
		treasures, err := swampObject.GetTreasuresByBeacon(swamp.BeaconTypeValueInt64, swamp.IndexOrderAsc, 0, 3)
		require.NoError(t, err)

		for _, treasure := range treasures {
			c, cErr := treasure.GetContentInt64()
			require.NoError(t, cErr)
			fmt.Printf("treasure: %s \t %d \n", treasure.GetKey(), c)
		}

		swampObject.CeaseVigil()

		time.Sleep(10 * time.Second)

		zeusInterface.StopHydra()

		fmt.Println("hydra stopped successfully")

	})

	t.Run("settings test", func(t *testing.T) {

		allTests := 10
		settingsInterface.RegisterPattern(name.New().Sanctuary(sanctuaryForQuickTest).Realm("*").Swamp("*"), false, 3600, &settings.FileSystemSettings{
			WriteIntervalSec: 1,
			MaxFileSizeByte:  8192, // 8KB
		})

		zeusInterface := New(settingsInterface, fsInterface)
		zeusInterface.StartHydra()

		hydraInterface := zeusInterface.GetHydra()

		require.NotNil(t, hydraInterface)

		swampObject, err := hydraInterface.SummonSwamp(context.Background(), 10, name.New().Sanctuary(sanctuaryForQuickTest).Realm("user").Swamp("petergebri"))
		defer swampObject.Destroy()

		swampObject.BeginVigil()
		require.NoError(t, err)
		require.NotNil(t, swampObject)

		// insert treasures to the swamp
		for i := 1; i <= allTests; i++ {
			treasureObj := swampObject.CreateTreasure(fmt.Sprintf("%d", i))
			treasureGuardID := treasureObj.StartTreasureGuard(true)
			treasureObj.SetContentInt64(treasureGuardID, int64(i))
			treasureObj.Save(treasureGuardID)
			treasureObj.ReleaseTreasureGuard(treasureGuardID)
		}

		// get treasures from the beacon
		require.Equal(t, allTests, swampObject.CountTreasures())

		swampObject.CeaseVigil()

		time.Sleep(10 * time.Second)

		zeusInterface.StopHydra()

		fmt.Println("hydra stopped successfully")

	})

}

// pkg: github.com/hydraide/hydraide/app/core/zeus
// cpu: AMD Ryzen Threadripper 2950X 16-Core Processor
// BenchmarkNew-32    	  623088	      2486 ns/op
// PASS
func BenchmarkNew(b *testing.B) {

	settingsInterface := settings.New(maxDepthOfFolders, maxFoldersPerLevel)
	fsInterface := filesystem.New()

	settingsInterface.RegisterPattern(name.New().Sanctuary(sanctuaryForQuickTest).Realm("*").Swamp("*"), false, 10, &settings.FileSystemSettings{
		WriteIntervalSec: 10,
		MaxFileSizeByte:  8192, // 8KB
	})

	zeusInterface := New(settingsInterface, fsInterface)
	zeusInterface.StartHydra()

	hydraInterface := zeusInterface.GetHydra()

	require.NotNil(b, hydraInterface)

	swampObject, err := hydraInterface.SummonSwamp(context.Background(), 10, name.New().Sanctuary(sanctuaryForQuickTest).Realm("user").Swamp("petergebri"))
	defer swampObject.Destroy()

	if err != nil {
		b.Fatal(err)
	}
	swampObject.BeginVigil()

	require.NoError(b, err)
	require.NotNil(b, swampObject)

	const content = "trendizz.com"

	b.ResetTimer()

	for i := 1; i <= b.N; i++ {
		treasureObj := swampObject.CreateTreasure(strconv.Itoa(i))
		treasureGuardID := treasureObj.StartTreasureGuard(true)
		treasureObj.SetContentString(treasureGuardID, content)
		treasureObj.Save(treasureGuardID)
		treasureObj.ReleaseTreasureGuard(treasureGuardID)
	}

	swampObject.CeaseVigil()

}

func BenchmarkRead(b *testing.B) {
	settingsInterface := settings.New(maxDepthOfFolders, maxFoldersPerLevel)
	fsInterface := filesystem.New()

	settingsInterface.RegisterPattern(name.New().Sanctuary(sanctuaryForQuickTest).Realm("*").Swamp("*"), false, 10, &settings.FileSystemSettings{
		WriteIntervalSec: 10,
		MaxFileSizeByte:  8192, // 8KB
	})

	zeusInterface := New(settingsInterface, fsInterface)
	zeusInterface.StartHydra()

	hydraInterface := zeusInterface.GetHydra()
	require.NotNil(b, hydraInterface)

	swampObject, err := hydraInterface.SummonSwamp(context.Background(), 10, name.New().Sanctuary(sanctuaryForQuickTest).Realm("user").Swamp("petergebri"))
	defer swampObject.Destroy()

	require.NoError(b, err)
	require.NotNil(b, swampObject)
	swampObject.BeginVigil()

	// --- Előkészítés: írjunk be b.N darab Treasure-t ---
	const content = "trendizz.com"
	for i := 1; i <= b.N; i++ {
		treasureObj := swampObject.CreateTreasure(strconv.Itoa(i))
		treasureGuardID := treasureObj.StartTreasureGuard(true)
		treasureObj.SetContentString(treasureGuardID, content)
		treasureObj.Save(treasureGuardID)
		treasureObj.ReleaseTreasureGuard(treasureGuardID)
	}

	b.ResetTimer()

	// --- Mérési szakasz: olvasás ---
	for i := 1; i <= b.N; i++ {
		key := strconv.Itoa(i)
		treasure, err := swampObject.GetTreasure(key)
		if err != nil {
			b.Fatalf("failed to read treasure %s: %v", key, err)
		}
		_, err = treasure.GetContentString()
		if err != nil {
			b.Fatalf("failed to read content from treasure %s: %v", key, err)
		}
	}

	swampObject.CeaseVigil()
}

--------------------------------------------------------------------------------

/==============================================================================\
| FILE: name\name.go
| PATH: C:\go\src\hydraide\app\name\name.go
| SIZE: 8.3 KB
\==============================================================================/

// Package name helps distribute data evenly across servers.
// To use it, you need to specify:
// - the total number of servers to distribute the data across, e.g. 1000 servers,
// - how many levels deep the folder structure should be within a single server, e.g. 2 levels deep,
// - and the maximum number of folders per level.
//
// The `name` package helps determine on which server a particular data item (e.g. a swamp) should be stored,
// and also generates the appropriate folder path on that server based on the given parameters.
//
// For example, if we have a swamp represented by a namespace like Sanctuary/Realm/Swamp,
// the system will calculate:
// - which server should store that swamp,
// - and what the folder structure should look like on that server.
//
// Each swamp is stored in its own unique folder.
//
// Example folder paths generated by the system:
// - 600/ba22/703a
// - 774/e81a/9e24
//
// Folder names are guaranteed to be unique and are distributed evenly across all servers.
//
// Why do we specify the total number of servers?
// Typically, you don't start with 1000 physical servers, but if you configure the system with 1000 logical server slots,
// later on, when you need to scale, it's easy to split:
// - keep the first 500 server ranges on Server A,
// - and move the rest (501–1000) to a new Server B.
//
// This approach creates room on both servers and makes it easy to scale horizontally.
//
// Accessing data across the two servers:
// If you initially had only Server A, and later added Server B,
// you simply migrate the data belonging to logical servers 500–1000 over to Server B.
// Then, in your application, you create a second client instance pointing to Server B.
// When generating a swamp name using the `name` package,
// you also get the server number via the `GetServerNumber` function.
// Based on the returned server number, you decide which client instance to use:
// - if it's below 500, use the A client,
// - if it's 500 or above, use the B client.
//
// It’s that simple – no need for an external orchestrator server.
// Everything is managed directly in the code.
package name

import (
	"fmt"
	"github.com/cespare/xxhash/v2"
	"path/filepath"
	"strings"
	"sync"
)

type Name interface {
	Sanctuary(sanctuaryID string) Name
	Realm(realmName string) Name
	Swamp(swampName string) Name
	Get() string
	GetFolderNumber(allFolders uint16) uint16
	IsWildcardPattern() bool
	ComparePattern(comparableName Name) bool
	GetSanctuaryID() string
	GetRealmName() string
	GetSwampName() string
	GetFullHashPath(rootPath string, islandID uint64, depth int, maxFoldersPerLevel int) string
}

type name struct {
	Path           string
	SanctuaryID    string
	RealmName      string
	SwampName      string
	HashPath       string
	ServerNumber   uint16
	FolderNumber   uint16
	hashPathMu     sync.Mutex
	folderNumberMu sync.Mutex
}

// New creates a new empty Name instance.
// Use this as the starting point for building hierarchical names
// by chaining Sanctuary(), Realm(), and Swamp().
func New() Name {
	return &name{}
}

// Sanctuary sets the top-level domain of the Name.
// Typically used to group major logical areas (e.g. "users", "products").
func (n *name) Sanctuary(sanctuaryID string) Name {
	return &name{
		SanctuaryID: sanctuaryID,
		Path:        sanctuaryID,
	}
}

// Realm sets the second-level scope under the Sanctuary.
// Often used to further categorize Swamps (e.g. "profiles", "settings").
func (n *name) Realm(realmName string) Name {
	return &name{
		SanctuaryID: n.SanctuaryID,
		RealmName:   realmName,
		Path:        n.Path + "/" + realmName,
	}
}

// Swamp sets the final segment of the Name — the Swamp itself.
// This represents the concrete storage unit where Treasures are kept.
// The full path becomes: sanctuary/realm/swamp.
func (n *name) Swamp(swampName string) Name {
	return &name{
		SanctuaryID: n.SanctuaryID,
		RealmName:   n.RealmName,
		SwampName:   swampName,
		Path:        n.Path + "/" + swampName,
	}
}

// Get returns the full hierarchical path of the Name in the format:
//
//	"sanctuary/realm/swamp"
//
// 🔒 Internal use only: This method is intended for SDK-level logic,
// such as logging, folder path generation, or internal diagnostics.
// SDK users should never need to call this directly.
func (n *name) Get() string {
	return n.Path
}

// GetFolderNumber returns the 1-based index of the server responsible for this Name.
// It uses a fast, consistent xxhash hash over the combined Sanctuary, Realm, and Swamp
// to deterministically assign the Name to one of `allFolders` available slots.
//
// 🔒 Internal use only: This function is used by the SDK to route
// the Name to the correct Hydra client instance in a distributed setup.
// It should not be called directly by application developers.
//
// Example (inside SDK logic):
//
//	client := router.Route(name.GetFolderNumber(1000))
func (n *name) GetFolderNumber(allFolders uint16) uint16 {

	n.folderNumberMu.Lock()
	defer n.folderNumberMu.Unlock()

	if n.FolderNumber != 0 {
		return n.FolderNumber
	}

	hash := xxhash.Sum64([]byte(n.SanctuaryID + n.RealmName + n.SwampName))

	n.FolderNumber = uint16(hash%uint64(allFolders)) + 1

	return n.FolderNumber

}

// IsWildcardPattern returns true if any part of the Name is set to "*".
func (n *name) IsWildcardPattern() bool {
	return n.SanctuaryID == "*" || n.RealmName == "*" || n.SwampName == "*"
}

// ComparePattern compares the last element of the path with the given SwampName
func (n *name) ComparePattern(comparableName Name) bool {
	if n.SanctuaryID != comparableName.GetSanctuaryID() {
		return false
	}
	if comparableName.GetRealmName() != "*" && n.RealmName != comparableName.GetRealmName() {
		return false
	}
	if comparableName.GetSwampName() != "*" && n.SwampName != comparableName.GetSwampName() {
		return false
	}
	return true
}

func (n *name) GetSanctuaryID() string {
	return n.SanctuaryID
}

func (n *name) GetRealmName() string {
	return n.RealmName
}

func (n *name) GetSwampName() string {
	return n.SwampName
}

func (n *name) GetFullHashPath(rootPath string, islandID uint64, depth int, maxFoldersPerLevel int) string {

	n.hashPathMu.Lock()
	defer n.hashPathMu.Unlock()

	if n.HashPath != "" {
		return n.HashPath
	}

	hashedDirectoryPath := generateHashedDirectoryPath(n.Path, depth, maxFoldersPerLevel)
	n.HashPath = filepath.Join(
		rootPath,
		fmt.Sprintf("%d", islandID),
		hashedDirectoryPath,
		generateSwampFolderName(n.Path))

	return n.HashPath

}

// Load reconstructs a Name from a given path string in the format:
//
//	"sanctuary/realm/swamp"
//
// It parses the path segments and returns a Name instance with all fields set.
//
// 🔒 Internal use only: This function is intended for SDK-level logic,
// such as reconstructing a Name from persisted references, file paths, or routing metadata.
// It should not be called by application developers directly.
func Load(path string) Name {

	// We process the path and generate a Name object from it
	// The values sanctuaryID, realmName, and swampName are extracted from the path
	// To do this, we split the path by the '/' character
	// sanctuaryID is the first element
	// realmName is the second element
	// swampName is the last element
	splitPath := strings.Split(path, "/")
	sanctuaryID := splitPath[0]
	realmName := splitPath[1]
	swampName := splitPath[2]

	return &name{
		Path:        sanctuaryID + "/" + realmName + "/" + swampName,
		SanctuaryID: sanctuaryID,
		RealmName:   realmName,
		SwampName:   swampName,
	}

}

func generateHashedDirectoryPath(input string, depth int, maxFoldersPerLevel int) string {

	hash := xxhash.Sum64String(input)
	hashHex := fmt.Sprintf("%x", hash)

	charsPerLevel := len(fmt.Sprintf("%x", maxFoldersPerLevel-1))
	if charsPerLevel < 2 {
		charsPerLevel = 2
	}

	parts := make([]string, depth)
	for i := 0; i < depth; i++ {
		start := i * charsPerLevel
		end := start + charsPerLevel
		if end > len(hashHex) {
			end = len(hashHex)
		}
		parts[i] = hashHex[start:end]
	}

	return strings.Join(parts, "/")
}

func generateSwampFolderName(swampName string) string {
	sum := xxhash.Sum64([]byte(swampName))
	return fmt.Sprintf("%x", sum)
}

--------------------------------------------------------------------------------

/==============================================================================\
| FILE: name\name_test.go
| PATH: C:\go\src\hydraide\app\name\name_test.go
| SIZE: 4.1 KB
\==============================================================================/

package name

import (
	"fmt"
	"path/filepath"
	"testing"
)

func TestGetFullHashPath(t *testing.T) {

	// Parameters for the test
	rootPath := "/hydraide/data"
	depth := 2
	maxFoldersPerLevel := 10000

	// First Name instance
	name1 := New().
		Sanctuary("Sanctuary1").
		Realm("RealmA").
		Swamp("SwampX")

	// Second Name instance with the same values
	name2 := New().
		Sanctuary("Sanctuary1").
		Realm("RealmA").
		Swamp("SwampX")

	// Third Name instance with different values
	name3 := New().
		Sanctuary("Sanctuary2").
		Realm("RealmB").
		Swamp("SwampY")

	// Test: Do identical inputs generate the same hash path?
	hashPath1 := name1.GetFullHashPath(rootPath, 10, depth, maxFoldersPerLevel)
	hashPath2 := name2.GetFullHashPath(rootPath, 10, depth, maxFoldersPerLevel)

	fmt.Println(hashPath1)

	if hashPath1 != hashPath2 {
		t.Errorf("Hash path mismatch for identical names: %s != %s", hashPath1, hashPath2)
	}

	// Test: Do different inputs generate different hash paths?
	hashPath3 := name3.GetFullHashPath(rootPath, 10, depth, maxFoldersPerLevel)
	if hashPath1 == hashPath3 {
		t.Errorf("Hash path collision: %s == %s", hashPath1, hashPath3)
	}

	// Output for easier verification
	fmt.Println("Hash path 1:", hashPath1)
	fmt.Println("Hash path 2:", hashPath2)
	fmt.Println("Hash path 3:", hashPath3)
}

// goos: linux
// goarch: amd64
// cpu: AMD Ryzen 9 5950X 16-Core Processor
// BenchmarkName_Compare
// BenchmarkName_Compare-32    	64480774	        18.77 ns/op
// NEW BenchmarkName_Compare-32    	11431681	       100.4 ns/op
// Newer BenchmarkName_Compare-32    	150973188	         7.443 ns/op
// Newest BenchmarkName_Compare-32    	98860936	        10.95 ns/op
func BenchmarkName_Compare(b *testing.B) {

	swampName := New().Sanctuary("users").Realm("petergebri").Swamp("info")
	pattern := New().Sanctuary("users").Realm("*").Swamp("info")

	b.ResetTimer()
	for i := 0; i < b.N; i++ {
		swampName.ComparePattern(pattern)
	}

}

// goos: linux
// goarch: amd64
// cpu: AMD Ryzen 9 5950X 16-Core Processor
// BenchmarkName_LoadFromCanonicalForm
// NEW BenchmarkName_Load-32    	 1630828	       748.7 ns/op
// Newer BenchmarkName_Load-32    	 3155320	       373.6 ns/op
// Newest BenchmarkName_Load-32    	 3427303	       336.8 ns/op
func BenchmarkName_Load(b *testing.B) {

	canonicalForm := filepath.Join("users", "petergebri", "info")
	b.ResetTimer()
	for i := 0; i < b.N; i++ {
		_ = Load(canonicalForm)
	}

}

// goos: linux
// goarch: amd64
// cpu: AMD Ryzen 9 5950X 16-Core Processor
// BenchmarkName_GetCanonicalForm
// NEW BenchmarkName_Get-32    	69597764	        16.46 ns/op
// Newer BenchmarkName_Get-32    	617518238	         1.919 ns/op
// Newest BenchmarkName_Get-32    	1000000000	         0.5444 ns/op
func BenchmarkName_Get(b *testing.B) {

	nameObj := New().Sanctuary("users").Realm("petergebri").Swamp("info")

	b.ResetTimer()
	for i := 0; i < b.N; i++ {
		nameObj.Get()
	}

}

// goos: linux
// goarch: amd64
// pkg: github.com/trendizz/hydra-spine/hydra/name
// cpu: AMD Ryzen 9 5950X 16-Core Processor
// BenchmarkName_Add
// BenchmarkName_Add-32    	 2036251	       592.8 ns/op
// BenchmarkName_Add-32    	19829251	        61.39 ns/op
// Newest BenchmarkName_Add-32    	27526341	        40.42 ns/op
func BenchmarkName_Add(b *testing.B) {

	b.ResetTimer()
	for i := 0; i < b.N; i++ {
		New().Sanctuary("users").Realm("petergebri").Swamp("info")
	}

}

// goos: linux
// goarch: amd64
// cpu: AMD Ryzen Threadripper 2950X 16-Core Processor
// BenchmarkName_GetFullHashPath
// BenchmarkName_GetFullHashPath-32    	69819813	        17.16 ns/op
func BenchmarkName_GetFullHashPath(b *testing.B) {

	sanctuary := "BenchmarkSanctuary"
	realm := "BenchmarkRealm"
	swamp := "BenchmarkSwamp"

	n := New().Sanctuary(sanctuary).Realm(realm).Swamp(swamp)

	rootPath := "/hydraide/data"
	depth := 3
	maxFoldersPerLevel := 5000

	b.ResetTimer() // Elindítjuk az időmérést

	for i := 0; i < b.N; i++ {
		n.GetFullHashPath(rootPath, 10, depth, maxFoldersPerLevel) // Meghívjuk a funkciót
	}

}

--------------------------------------------------------------------------------

/==============================================================================\
| FILE: name\README.md
| PATH: C:\go\src\hydraide\app\name\README.md
| SIZE: 2.4 KB
\==============================================================================/

# HydrAIDE Name

Deterministic hashing and folder distribution utility for HydraIDE server-side data sharding.

## 🔧 Purpose

This internal library is used by [HydrAIDE Core](https://github.com/hydraide/core) and [HydrAIDE Server](https://github.com/hydraide/server) to ensure **predictable and even distribution** of namespace-based data (like swamps) across a scalable pool of logical servers.

> ⚠️ This package is **not intended for public use**.
> It exists solely to support the internal infrastructure of the HydrAIDE ecosystem.

---

## ✨ Features

* Hash-based deterministic server assignment
* Predictable nested folder structure generation
* Namespace-aware: works with structured paths like `Sanctuary/Realm/Swamp`
* Supports:

    * Arbitrary number of logical servers (e.g. 1000)
    * Multi-level folder depth
    * Max folders per level
* Guarantees even data distribution and uniqueness
* Enables horizontal scaling without breaking storage logic
* Lightweight: no external state or service required

---

## 🧠 How It Works

The package takes a structured path and converts it into:

1. A **server number** (between 0 and N-1),
2. A **nested folder path** suitable for sharded storage.

Given:

```
name := New().
  Sanctuary("Sanctuary1").
  Realm("RealmA").
  Swamp("SwampX")

path := name.GetFullHashPath("/hydraide/data", totalServers, depth, maxFoldersPerLevel)
```

You get output like:

```
/hydraide/data/600/ba22/703a
```

This tells you:

* Server 600 is responsible for this swamp
* Its folder path is `/600/ba22/703a`

---

## 🧱 Scaling Logic

Even if you only run **1 or 2 physical servers**, setting a high number of **logical servers** (e.g. 1000) allows you to:

* Distribute data in advance,
* Later **split** data ranges between servers (e.g. 0–499 stays on A, 500–999 moves to B),
* Route client requests correctly using `GetServerNumber()`.

This model removes the need for:

* External orchestrator logic
* Redistribution overhead during scale-out
* Central metadata services

Just compute → resolve → store.

---

## 📦 Installation

```bash
go get github.com/hydraide/name
```

But again:
This is for internal use only by HydrAIDE contributors. No external API guarantees, no support, no versioning. Use it only if you're working inside the core or server repo.

--------------------------------------------------------------------------------

/==============================================================================\
| FILE: server\e2etests\e2etests_test.go
| PATH: C:\go\src\hydraide\app\server\e2etests\e2etests_test.go
| SIZE: 9.4 KB
\==============================================================================/

package e2etests

import (
	"context"
	"fmt"
	"github.com/hydraide/hydraide/app/server/server"
	"github.com/hydraide/hydraide/generated/hydraidepbgo"
	"github.com/hydraide/hydraide/sdk/go/hydraidego/client"
	"github.com/hydraide/hydraide/sdk/go/hydraidego/name"
	"github.com/stretchr/testify/assert"
	"google.golang.org/protobuf/types/known/timestamppb"
	"log/slog"
	"os"
	"sync"
	"testing"
	"time"
)

var serverInterface server.Server
var clientInterface client.Client
var serverGlobalName name.Name

const (
	testPort = 4888
)

func TestMain(m *testing.M) {

	fmt.Println("Setting up test environment...")
	setup()
	code := m.Run()
	fmt.Println("Tearing down test environment...")
	teardown()
	os.Exit(code)
}

func setup() {

	serverGlobalName = name.New().Sanctuary("server").Realm("global").Swamp("name")

	slog.SetLogLoggerLevel(slog.LevelDebug)

	if os.Getenv("HYDRA_SERVER_CRT") == "" {
		slog.Error("HYDRA_SERVER_CRT environment variable is not set")
		panic("HYDRA_SERVER_CRT environment variable is not set")
	}
	if os.Getenv("HYDRA_SERVER_KEY") == "" {
		slog.Error("HYDRA_SERVER_KEY environment variable is not set")
		panic("HYDRA_SERVER_KEY environment variable is not set")
	}
	if os.Getenv("HYDRA_CLIENT_CA_CRT") == "" {
		slog.Error("HYDRA_CLIENT_CA_CRT environment variable is not set")
		panic("HYDRA_CLIENT_CA_CRT environment variable is not set")
	}

	// start the new Hydra server
	serverInterface = server.New(&server.Configuration{
		CertificateCrtFile:  os.Getenv("HYDRA_SERVER_CRT"),
		CertificateKeyFile:  os.Getenv("HYDRA_SERVER_KEY"),
		HydraServerPort:     testPort,
		HydraMaxMessageSize: 1024 * 1024 * 1024, // 1 GB
	})

	if err := serverInterface.Start(); err != nil {
		slog.Error("error while starting the server", "error", err)
		panic(fmt.Sprintf("error while starting the server: %v", err))
	}

	createGrpcClient()

}

func teardown() {
	// stop the microservice and exit the program
	serverInterface.Stop()
	slog.Info("server stopped gracefully. Program is exiting...")
	// waiting for logs to be written to the file
	time.Sleep(1 * time.Second)
	// exit the program if the microservice is stopped gracefully
	os.Exit(0)
}

func createGrpcClient() {

	// create a new gRPC client object
	servers := []*client.Server{
		{
			Host:         fmt.Sprintf("localhost:%d", testPort),
			FromIsland:   0,
			ToIsland:     100,
			CertFilePath: os.Getenv("HYDRA_CLIENT_CA_CRT"),
		},
	}

	// 100 folders and 2 gig message size
	clientInterface = client.New(servers, 100, 2147483648)
	if err := clientInterface.Connect(true); err != nil {
		slog.Error("error while connecting to the server", "error", err)
	}

}

func TestLockAndUnlock(t *testing.T) {

	ctx, cancel := context.WithTimeout(context.Background(), 10*time.Second)
	defer cancel()

	lockKey := "myLockKey"
	maxTTL := 10 * time.Second

	lockResponse, err := clientInterface.GetServiceClient(serverGlobalName).Lock(ctx, &hydraidepbgo.LockRequest{
		Key: lockKey,
		TTL: maxTTL.Milliseconds(),
	})

	assert.NoError(t, err)
	assert.NotNil(t, lockResponse)

	unlockResponse, err := clientInterface.GetServiceClient(serverGlobalName).Unlock(ctx, &hydraidepbgo.UnlockRequest{
		Key:    lockKey,
		LockID: lockResponse.GetLockID(),
	})

	assert.NoError(t, err)
	assert.NotNil(t, unlockResponse)

}

func TestGateway_Set(t *testing.T) {

	writeInterval := int64(1)
	maxFileSize := int64(65536)

	swampPattern := name.New().Sanctuary("dizzlets").Realm("*").Swamp("*")
	selectedClient := clientInterface.GetServiceClient(swampPattern)
	_, err := selectedClient.RegisterSwamp(context.Background(), &hydraidepbgo.RegisterSwampRequest{
		SwampPattern:   swampPattern.Get(),
		CloseAfterIdle: int64(3600),
		WriteInterval:  &writeInterval,
		MaxFileSize:    &maxFileSize,
	})

	swampName := name.New().Sanctuary("dizzlets").Realm("testing").Swamp("set-and-get")
	swampClient := clientInterface.GetServiceClient(swampName)
	defer func() {
		_, err = swampClient.Destroy(context.Background(), &hydraidepbgo.DestroyRequest{
			SwampName: swampName.Get(),
		})
		assert.NoError(t, err)
	}()

	var keyValues []*hydraidepbgo.KeyValuePair
	for i := 0; i < 10; i++ {
		myVal := fmt.Sprintf("value-%d", i)
		createdBy := "trendizz"
		keyValues = append(keyValues, &hydraidepbgo.KeyValuePair{
			Key:       fmt.Sprintf("key-%d", i),
			StringVal: &myVal,
			CreatedAt: timestamppb.Now(),
			CreatedBy: &createdBy,
			UpdatedAt: timestamppb.Now(),
			UpdatedBy: &createdBy,
			ExpiredAt: timestamppb.Now(),
		})
	}

	// try to set a value to the swamp
	response, err := swampClient.Set(context.Background(), &hydraidepbgo.SetRequest{
		Swamps: []*hydraidepbgo.SwampRequest{
			{
				SwampName:        swampName.Get(),
				CreateIfNotExist: true,
				Overwrite:        true,
				KeyValues:        keyValues,
			},
		}})

	assert.NoError(t, err)
	assert.NotNil(t, response)

	slog.Debug("response from the server", "response", response)

	assert.Equal(t, 1, len(response.GetSwamps()), "response should contain one swamp")
	assert.Equal(t, 10, len(response.GetSwamps()[0].GetKeysAndStatuses()), "the swamp should contain 10 keys")

	// try to get back all data from the swamp
	getResponse, err := swampClient.Get(context.Background(), &hydraidepbgo.GetRequest{
		Swamps: []*hydraidepbgo.GetSwamp{
			{
				SwampName: swampName.Get(),
				Keys:      []string{"key-0", "key-1", "key-2", "key-3", "key-4", "key-5", "key-6", "key-7", "key-8", "key-9", "key-10"},
			},
		},
	})

	assert.NoError(t, err)
	assert.NotNil(t, getResponse)

	// print the data to the console
	treasureExistCounter := 0
	treasureNotExistCounter := 0
	for _, getResponseValue := range getResponse.GetSwamps() {
		slog.Debug("swamp found", "swamp", getResponseValue.GetSwampName())
		for _, treasure := range getResponseValue.GetTreasures() {
			if treasure.IsExist {
				fmt.Printf("Key: %s, Value: %s\n", treasure.GetKey(), treasure.GetStringVal())
				slog.Debug("treasure found", "key", treasure.GetKey(), "value", treasure.GetStringVal())
				treasureExistCounter++
			} else {
				slog.Debug("treasure not found")
				treasureNotExistCounter++
			}
		}
	}

	assert.Equal(t, 10, treasureExistCounter)
	assert.Equal(t, 1, treasureNotExistCounter)

}

func TestRegisterSwamp(t *testing.T) {

	writeInterval := int64(1)
	maxFileSize := int64(65536)

	swampPattern := name.New().Sanctuary("dizzlets").Realm("*").Swamp("*")
	selectedClient := clientInterface.GetServiceClient(swampPattern)
	response, err := selectedClient.RegisterSwamp(context.Background(), &hydraidepbgo.RegisterSwampRequest{
		SwampPattern:    swampPattern.Get(),
		CloseAfterIdle:  int64(3600),
		IsInMemorySwamp: false,
		WriteInterval:   &writeInterval,
		MaxFileSize:     &maxFileSize,
	})

	assert.NoError(t, err, "error should be nil")
	assert.NotNil(t, response, "response should not be nil")

}

func TestGateway_SubscribeToEvent(t *testing.T) {

	ctx, cancelFunc := context.WithCancel(context.Background())
	defer cancelFunc()

	writeInterval := int64(1)
	maxFileSize := int64(65536)

	swampPattern := name.New().Sanctuary("subscribe").Realm("to").Swamp("event")

	destroySwamp(clientInterface.GetServiceClient(swampPattern), swampPattern)
	defer func() {
		destroySwamp(clientInterface.GetServiceClient(swampPattern), swampPattern)
		slog.Info("swamp destroyed at the end of the test", "swamp", swampPattern.Get())
	}()

	selectedClient := clientInterface.GetServiceClient(swampPattern)
	_, err := selectedClient.RegisterSwamp(context.Background(), &hydraidepbgo.RegisterSwampRequest{
		SwampPattern:   swampPattern.Get(),
		CloseAfterIdle: int64(3600),
		WriteInterval:  &writeInterval,
		MaxFileSize:    &maxFileSize,
	})

	assert.NoError(t, err)

	eventClient, err := selectedClient.SubscribeToEvents(ctx, &hydraidepbgo.SubscribeToEventsRequest{
		SwampName: swampPattern.Get(),
	})

	assert.NoError(t, err, "error should be nil")

	testTreasures := 5
	wg := &sync.WaitGroup{}
	wg.Add(testTreasures)

	go func() {
		for {
			select {
			case <-ctx.Done():
				return
			default:
				event, err := eventClient.Recv()

				if err != nil || event == nil {
					continue
				}

				slog.Debug("event received", "treasure key", event.Treasure.GetKey(), "treasure value", event.Treasure.GetStringVal())

				wg.Done()
			}
		}
	}()

	var keyValues []*hydraidepbgo.KeyValuePair
	for i := 0; i < testTreasures; i++ {
		myVal := fmt.Sprintf("value-%d", i)
		keyValues = append(keyValues, &hydraidepbgo.KeyValuePair{
			Key:       fmt.Sprintf("key-%d", i),
			StringVal: &myVal,
		})
	}

	swampsRequest := []*hydraidepbgo.SwampRequest{
		{
			SwampName:        swampPattern.Get(),
			KeyValues:        keyValues,
			CreateIfNotExist: true,
			Overwrite:        true,
		},
	}

	// set the treasures to the swamp
	_, err = selectedClient.Set(context.Background(), &hydraidepbgo.SetRequest{
		Swamps: swampsRequest,
	})

	assert.NoError(t, err, "error should be nil")

	wg.Wait()

	slog.Info("all events received successfully")

}

func destroySwamp(selectedClient hydraidepbgo.HydraideServiceClient, swampName name.Name) {

	_, err := selectedClient.Destroy(context.Background(), &hydraidepbgo.DestroyRequest{
		SwampName: swampName.Get(),
	})

	if err != nil {
		slog.Error("error while destroying swamp", "swamp", swampName.Get(), "error", err)
		return
	}

}

--------------------------------------------------------------------------------

/==============================================================================\
| FILE: server\gateway\gateway.go
| PATH: C:\go\src\hydraide\app\server\gateway\gateway.go
| SIZE: 65.3 KB
\==============================================================================/

package gateway

import (
	"context"
	"errors"
	"fmt"
	"github.com/google/uuid"
	"github.com/hydraide/hydraide/app/core/hydra/swamp"
	"github.com/hydraide/hydraide/app/core/hydra/swamp/treasure"
	"github.com/hydraide/hydraide/app/core/hydra/swamp/treasure/guard"
	"github.com/hydraide/hydraide/app/core/settings"
	"github.com/hydraide/hydraide/app/core/zeus"
	"github.com/hydraide/hydraide/app/name"
	"github.com/hydraide/hydraide/app/server/observer"
	hydrapb "github.com/hydraide/hydraide/generated/hydraidepbgo"
	"google.golang.org/grpc/codes"
	"google.golang.org/grpc/status"
	"google.golang.org/protobuf/types/known/timestamppb"
	"log/slog"
	"runtime/debug"
	"strings"
	"time"
)

type Gateway struct {
	hydrapb.UnimplementedHydraideServiceServer
	ObserverInterface     observer.Observer
	SettingsInterface     settings.Settings
	ZeusInterface         zeus.Zeus
	DefaultCloseAfterIdle int64
	DefaultWriteInterval  int64
	DefaultFileSize       int64
}

func (g Gateway) Heartbeat(_ context.Context, in *hydrapb.HeartbeatRequest) (*hydrapb.HeartbeatResponse, error) {
	return &hydrapb.HeartbeatResponse{
		Pong: in.Ping,
	}, nil
}

func (g Gateway) Lock(ctx context.Context, in *hydrapb.LockRequest) (*hydrapb.LockResponse, error) {

	defer handlePanic()

	// try to summon the swamp
	lockerInterface := g.ZeusInterface.GetHydra().GetLocker()

	// késíztünk egy új contextet
	ctxForLocker := context.WithoutCancel(ctx)

	// lock the system
	lockID, err := lockerInterface.Lock(ctxForLocker, in.GetKey(), time.Duration(in.GetTTL())*time.Millisecond)
	if err != nil {
		// return with grpc error message
		return nil, status.Error(codes.DeadlineExceeded, fmt.Sprintf("lock deadline exceeded: %s", err.Error()))
	}

	return &hydrapb.LockResponse{
		LockID: lockID,
	}, nil

}

func (g Gateway) Unlock(_ context.Context, in *hydrapb.UnlockRequest) (*hydrapb.UnlockResponse, error) {

	defer handlePanic()

	// try to summon the swamp
	lockerInterface := g.ZeusInterface.GetHydra().GetLocker()
	// unlock the system
	if err := lockerInterface.Unlock(in.GetKey(), in.GetLockID()); err != nil {
		// return with grpc error message
		return nil, status.Error(codes.NotFound, fmt.Sprintf("lock not found: %s", err.Error()))
	}
	return &hydrapb.UnlockResponse{}, nil

}

func (g Gateway) RegisterSwamp(_ context.Context, in *hydrapb.RegisterSwampRequest) (*hydrapb.RegisterSwampResponse, error) {

	g.ZeusInterface.GetSafeops().LockSystem()
	defer g.ZeusInterface.GetSafeops().UnlockSystem()

	defer handlePanic()

	if in.SwampPattern == "" {
		// return with grpc error message
		return nil, status.Error(codes.InvalidArgument, "SwampPattern cannot be empty")
	}

	// try to create the pattern from the input string
	swampPattern := name.Load(in.SwampPattern)

	closeAfterIdle := g.DefaultCloseAfterIdle

	if in.CloseAfterIdle > 0 {
		closeAfterIdle = in.CloseAfterIdle
	}

	var fss *settings.FileSystemSettings
	if !in.IsInMemorySwamp {

		fss = &settings.FileSystemSettings{}
		if in.WriteInterval != nil && *in.WriteInterval > 0 {
			fss.WriteIntervalSec = *in.WriteInterval
		} else {
			fss.WriteIntervalSec = g.DefaultWriteInterval
		}

		if in.MaxFileSize != nil && *in.MaxFileSize > 0 {
			fss.MaxFileSizeByte = *in.MaxFileSize
		} else {
			fss.MaxFileSizeByte = g.DefaultFileSize
		}

	}

	g.SettingsInterface.RegisterPattern(swampPattern, in.IsInMemorySwamp, closeAfterIdle, fss)

	return &hydrapb.RegisterSwampResponse{}, nil

}

func (g Gateway) DeRegisterSwamp(_ context.Context, in *hydrapb.DeRegisterSwampRequest) (*hydrapb.DeRegisterSwampResponse, error) {

	g.ZeusInterface.GetSafeops().LockSystem()
	defer g.ZeusInterface.GetSafeops().UnlockSystem()

	defer handlePanic()

	if in.SwampPattern == "" {
		// return with grpc error message
		return nil, status.Error(codes.InvalidArgument, "SwampPattern cannot be empty")
	}

	// try to create the pattern from the input string
	swampPattern := name.Load(in.SwampPattern)

	g.SettingsInterface.DeregisterPattern(swampPattern)

	return &hydrapb.DeRegisterSwampResponse{}, nil

}

func (g Gateway) Set(ctx context.Context, in *hydrapb.SetRequest) (*hydrapb.SetResponse, error) {

	g.ZeusInterface.GetSafeops().LockSystem()
	defer g.ZeusInterface.GetSafeops().UnlockSystem()

	defer handlePanic()

	// validate all the requests
	for _, swampRequest := range in.GetSwamps() {
		// check if the swamp name is valid and exist or not
		// we don't need to check the existence of the swamp because we will create it if it does not exist
		if _, err := checkSwampName(g.ZeusInterface, swampRequest.GetIslandID(), swampRequest.SwampName, false); err != nil {
			return nil, err
		}
		if swampRequest.GetKeyValues() == nil {
			// return with grpc error message
			return nil, status.Error(codes.InvalidArgument, fmt.Sprintf("KeyValues cannot be empty for the swamp: %s", swampRequest.GetSwampName()))
		}
	}

	// try to summon the swamp
	hydraInterface := g.ZeusInterface.GetHydra()

	var swampResponses []*hydrapb.SwampResponse

	for _, swampRequest := range in.GetSwamps() {

		swampResponse := &hydrapb.SwampResponse{
			SwampName: swampRequest.SwampName,
		}

		// don't need to check the error, because we already checked it in the previous loop
		swampName := name.Load(swampRequest.SwampName)

		var internalError error

		func() {

			// this is a meaningless setting
			if !swampRequest.GetCreateIfNotExist() && !swampRequest.GetOverwrite() {
				swampResponses = append(swampResponses, &hydrapb.SwampResponse{
					SwampName:       swampRequest.SwampName,
					KeysAndStatuses: []*hydrapb.KeyStatusPair{},
					ErrorCode:       hydrapb.SwampResponse_CanNotBeExecuted.Enum(),
				})
				return
			}

			// check if the swamp already exists if the
			if !swampRequest.GetCreateIfNotExist() {
				isExist, err := hydraInterface.IsExistSwamp(swampRequest.GetIslandID(), swampName)
				if err != nil || !isExist {
					swampResponses = append(swampResponses, &hydrapb.SwampResponse{
						SwampName:       swampRequest.SwampName,
						KeysAndStatuses: []*hydrapb.KeyStatusPair{},
						ErrorCode:       hydrapb.SwampResponse_SwampDoesNotExist.Enum(),
					})
					return
				}
			}

			swampInterface, err := hydraInterface.SummonSwamp(ctx, swampRequest.GetIslandID(), swampName)
			if err != nil {
				// return with grpc error message
				internalError = err
				return
			}

			// begin the vigil, to prevent the close of the swamp
			swampInterface.BeginVigil()
			defer swampInterface.CeaseVigil()

			response := make([]*hydrapb.KeyStatusPair, 0)

			for _, item := range swampRequest.GetKeyValues() {

				// if "create if not" exist is false and the treasure does not exist
				if !swampRequest.GetCreateIfNotExist() && !swampInterface.TreasureExists(item.Key) {
					response = append(response, &hydrapb.KeyStatusPair{
						Key:    item.Key,
						Status: hydrapb.Status_NOT_FOUND,
					})
					continue
				}

				if !swampRequest.Overwrite && swampInterface.TreasureExists(item.Key) {
					response = append(response, &hydrapb.KeyStatusPair{
						Key:    item.Key,
						Status: hydrapb.Status_NOTHING_CHANGED,
					})
					// check the treasure and skip if it exists
					continue
				}

				// anonymous function to handle the treasure
				func() {

					// create the treasure and start the guard
					treasureInterface := swampInterface.CreateTreasure(item.Key)
					guardID := treasureInterface.StartTreasureGuard(true)
					defer treasureInterface.ReleaseTreasureGuard(guardID)

					// set the content type and content
					keyValuesToTreasure(item, treasureInterface, guardID)

					treasureStatus := treasureInterface.Save(guardID)

					// save the treasure to the Hydra
					responseStatus := convertTreasureStatusToPbStatus(treasureStatus)

					// add the key and status to the response
					response = append(response, &hydrapb.KeyStatusPair{
						Key:    item.Key,
						Status: responseStatus,
					})

				}()

			}

			swampResponse.KeysAndStatuses = response

		}()

		if internalError != nil {
			// return with grpc error message
			return nil, status.Error(codes.Internal, fmt.Sprintf("internal server error in hydra: %s", internalError.Error()))
		}

		swampResponses = append(swampResponses, swampResponse)

	}

	// return with all the keys and statuses that we saved
	return &hydrapb.SetResponse{
		Swamps: swampResponses,
	}, nil

}

func (g Gateway) Get(ctx context.Context, in *hydrapb.GetRequest) (*hydrapb.GetResponse, error) {

	g.ZeusInterface.GetSafeops().LockSystem()
	defer g.ZeusInterface.GetSafeops().UnlockSystem()

	defer handlePanic()

	// validate all the requests
	for _, swampRequest := range in.GetSwamps() {
		// check if the swamp name is valid and exist or not
		if _, err := checkSwampName(g.ZeusInterface, swampRequest.GetIslandID(), swampRequest.SwampName, true); err != nil {
			return nil, err
		}
		if swampRequest.GetKeys() == nil || swampRequest.GetKeys()[0] == "" {
			// return with grpc error message
			return nil, status.Error(codes.InvalidArgument, "Keys cannot be empty")
		}
	}

	// try to summon the swamp
	hydraInterface := g.ZeusInterface.GetHydra()

	var swamps []*hydrapb.GetSwampResponse

	// iterating over the requests
	for _, swampRequest := range in.GetSwamps() {

		// don't need to check the error, because we already checked it in the previous loop
		swampName := name.Load(swampRequest.SwampName)

		swampResponse := &hydrapb.GetSwampResponse{
			SwampName: swampRequest.SwampName,
		}

		var internalError error

		func() {

			// check if the swamp already exists
			// because we need to prevent the creation of a new swamp
			isExist, err := hydraInterface.IsExistSwamp(swampRequest.GetIslandID(), swampName)
			if err != nil || !isExist {
				// return with grpc error message
				swampResponse.IsExist = false // override the default value
				return
			}

			swampInterface, err := hydraInterface.SummonSwamp(ctx, swampRequest.GetIslandID(), swampName)
			if err != nil {
				// internal error
				internalError = err
				return
			}

			// begin the vigil, to prevent closing of the swamp
			swampInterface.BeginVigil()
			defer swampInterface.CeaseVigil()

			var response []*hydrapb.Treasure

			for _, key := range swampRequest.GetKeys() {

				t := &hydrapb.Treasure{
					Key:     key,
					IsExist: true, // default value
				}

				treasureInterface, err := swampInterface.GetTreasure(key)
				if err != nil {
					// the treasure does not exist
					t.IsExist = false // override the default value
				} else {
					// convert the treasure from the hydra to the protobuf format
					treasureToKeyValuePair(treasureInterface, t)
				}

				// add the treasure to the response
				response = append(response, t)

			}

			swampResponse.Treasures = response

		}()

		if internalError != nil {
			// return with grpc error message
			return nil, status.Error(codes.Internal, fmt.Sprintf("internal server error in hydra: %s", internalError.Error()))
		}

		swamps = append(swamps, swampResponse)

	}

	// return with all the treasures that we found
	return &hydrapb.GetResponse{
		Swamps: swamps,
	}, nil

}

func (g Gateway) GetAll(ctx context.Context, in *hydrapb.GetAllRequest) (*hydrapb.GetAllResponse, error) {

	g.ZeusInterface.GetSafeops().LockSystem()
	defer g.ZeusInterface.GetSafeops().UnlockSystem()

	defer handlePanic()

	// check if the swamp name is valid and exist or not
	swampName, err := checkSwampName(g.ZeusInterface, in.GetIslandID(), in.SwampName, true)
	if err != nil {
		return nil, err
	}

	hydraInterface := g.ZeusInterface.GetHydra()

	// summon the swamp
	swampInterface, err := hydraInterface.SummonSwamp(ctx, in.GetIslandID(), swampName)
	if err != nil {
		// return with grpc error message
		return nil, status.Error(codes.Internal, fmt.Sprintf("internal server error in hydra: %s", err.Error()))
	}

	// begin the vigil, to prevent closing of the swamp
	swampInterface.BeginVigil()
	defer swampInterface.CeaseVigil()

	treasures := swampInterface.GetAll()

	var response []*hydrapb.Treasure
	for _, treasureInterface := range treasures {
		t := &hydrapb.Treasure{}
		treasureToKeyValuePair(treasureInterface, t)
		response = append(response, t)
	}

	return &hydrapb.GetAllResponse{
		Treasures: response,
	}, nil

}

func (g Gateway) GetByIndex(ctx context.Context, in *hydrapb.GetByIndexRequest) (*hydrapb.GetByIndexResponse, error) {

	g.ZeusInterface.GetSafeops().LockSystem()
	defer g.ZeusInterface.GetSafeops().UnlockSystem()

	defer handlePanic()

	swampName, err := checkSwampName(g.ZeusInterface, in.GetIslandID(), in.SwampName, true)
	if err != nil {
		return nil, err
	}

	hydraInterface := g.ZeusInterface.GetHydra()

	// summon the swamp
	swampInterface, err := hydraInterface.SummonSwamp(ctx, in.GetIslandID(), swampName)
	if err != nil {
		// return with grpc error message
		return nil, status.Error(codes.Internal, fmt.Sprintf("internal server error in hydra: %s", err.Error()))
	}

	// begin the vigil, to prevent closing of the swamp
	swampInterface.BeginVigil()
	defer swampInterface.CeaseVigil()

	treasures, err := swampInterface.GetTreasuresByBeacon(inputIndexTypeToBeaconType(in.GetIndexType()),
		inputOrderTypeToBeaconOrderType(in.GetOrderType()), in.GetFrom(), in.GetLimit())

	if err != nil {
		// return with grpc error message
		return nil, status.Error(codes.Internal, fmt.Sprintf("hydra error: %s", err.Error()))
	}

	// convert all treasures to the protobuf format
	var response []*hydrapb.Treasure
	for _, treasureInterface := range treasures {
		// convert the treasure to the protobuf format
		t := &hydrapb.Treasure{}
		treasureToKeyValuePair(treasureInterface, t)
		response = append(response, t)
	}

	// get the treasures by the index
	return &hydrapb.GetByIndexResponse{
		Treasures: response,
	}, nil

}

func (g Gateway) ShiftExpiredTreasures(ctx context.Context, in *hydrapb.ShiftExpiredTreasuresRequest) (*hydrapb.ShiftExpiredTreasuresResponse, error) {

	g.ZeusInterface.GetSafeops().LockSystem()
	defer g.ZeusInterface.GetSafeops().UnlockSystem()

	defer handlePanic()

	swampName, err := checkSwampName(g.ZeusInterface, in.GetIslandID(), in.SwampName, true)
	if err != nil {
		return nil, err
	}

	hydraInterface := g.ZeusInterface.GetHydra()

	// summon the swamp
	swampInterface, err := hydraInterface.SummonSwamp(ctx, in.GetIslandID(), swampName)
	if err != nil {
		// return with grpc error message
		return nil, status.Error(codes.Internal, fmt.Sprintf("internal server error in hydra: %s", err.Error()))
	}

	// begin the vigil, to prevent closing of the swamp
	swampInterface.BeginVigil()
	defer swampInterface.CeaseVigil()

	howMany := in.GetHowMany()
	if howMany == 0 {
		// set the howMany to the default value because it is zero and if the value is zero, the user wants ALL the
		// expired treasures
		howMany = 1000000000 // 1 billion, this is a very large number, so it will return all the expired treasures
	}

	// clone and delete the expired treasures from the swamp
	treasures, err := swampInterface.CloneAndDeleteExpiredTreasures(howMany)
	// there was an error
	if err != nil {
		// return with grpc error message
		return nil, status.Error(codes.Internal, fmt.Sprintf("hydra error: %s", err.Error()))
	}

	// convert all treasures to the protobuf format
	var response []*hydrapb.Treasure
	for _, treasureInterface := range treasures {
		// convert the treasure to the protobuf format
		t := &hydrapb.Treasure{}
		treasureToKeyValuePair(treasureInterface, t)
		response = append(response, t)
	}

	// get the treasures by the index
	return &hydrapb.ShiftExpiredTreasuresResponse{
		Treasures: response,
	}, nil

}

func (g Gateway) Destroy(ctx context.Context, in *hydrapb.DestroyRequest) (*hydrapb.DestroyResponse, error) {

	g.ZeusInterface.GetSafeops().LockSystem()
	defer g.ZeusInterface.GetSafeops().UnlockSystem()

	defer handlePanic()

	// check and validate the name of the swamp
	swampName, err := checkSwampName(g.ZeusInterface, in.GetIslandID(), in.SwampName, false)
	if err != nil {
		return nil, err
	}

	// get the hydra interface
	hydraInterface := g.ZeusInterface.GetHydra()

	// summon the swamp
	swampInterface, err := hydraInterface.SummonSwamp(ctx, in.GetIslandID(), swampName)
	if err != nil {
		// return with grpc error message
		return nil, status.Error(codes.Internal, fmt.Sprintf("internal server error in hydra: %s", err.Error()))
	}

	// destroy the swamp
	swampInterface.Destroy()

	return &hydrapb.DestroyResponse{}, nil

}

func (g Gateway) Delete(ctx context.Context, in *hydrapb.DeleteRequest) (*hydrapb.DeleteResponse, error) {

	g.ZeusInterface.GetSafeops().LockSystem()
	defer g.ZeusInterface.GetSafeops().UnlockSystem()

	defer handlePanic()

	responses := make([]*hydrapb.DeleteResponse_SwampDeleteResponse, 0, len(in.GetSwamps()))

	// validate all the requests
	for _, swampRequest := range in.GetSwamps() {

		// check if the swamp name is valid and exist or not
		// we don't need to check the existence of the swamp because we will create it if it does not exist
		swampNameObj, err := checkSwampName(g.ZeusInterface, swampRequest.GetIslandID(), swampRequest.SwampName, true)
		if err != nil {
			responses = append(responses, &hydrapb.DeleteResponse_SwampDeleteResponse{
				SwampName: swampRequest.SwampName,
				ErrorCode: hydrapb.DeleteResponse_SwampDeleteResponse_SwampDoesNotExist.Enum(),
			})
			continue
		}

		hydraInterface := g.ZeusInterface.GetHydra()

		// summon the swamp
		swampInterface, err := hydraInterface.SummonSwamp(ctx, swampRequest.GetIslandID(), swampNameObj)
		if err != nil {
			// return with grpc error message
			return nil, status.Error(codes.Internal, fmt.Sprintf("internal server error in hydra: %s", err.Error()))
		}

		func() {

			// begin the vigil, to prevent closing of the swamp
			swampInterface.BeginVigil()
			defer swampInterface.CeaseVigil()

			sr := &hydrapb.DeleteResponse_SwampDeleteResponse{
				SwampName: swampRequest.SwampName,
				ErrorCode: nil,
			}

			keyStatuses := make([]*hydrapb.KeyStatusPair, 0)

			for _, key := range swampRequest.GetKeys() {
				statusPair := &hydrapb.KeyStatusPair{
					Key: key,
				}
				if err := swampInterface.DeleteTreasure(key, false); err != nil {
					statusPair.Status = hydrapb.Status_NOT_FOUND

				} else {
					statusPair.Status = hydrapb.Status_DELETED
				}
				keyStatuses = append(keyStatuses, statusPair)
			}

			sr.KeyStatuses = keyStatuses
			responses = append(responses, sr)

		}()

	}

	return &hydrapb.DeleteResponse{
		Responses: responses,
	}, nil

}

func (g Gateway) Count(ctx context.Context, in *hydrapb.CountRequest) (*hydrapb.CountResponse, error) {

	g.ZeusInterface.GetSafeops().LockSystem()
	defer g.ZeusInterface.GetSafeops().UnlockSystem()

	defer handlePanic()

	// try to count the treasures in all the swamps
	var response []*hydrapb.CountSwamp

	type SwampIdentifier struct {
		IslandID  uint64
		SwampName name.Name
	}

	var swamps []*SwampIdentifier

	for _, swampIdentifier := range in.GetSwamps() {

		swampNameObject, err := checkSwampName(g.ZeusInterface, swampIdentifier.GetIslandID(), swampIdentifier.GetSwampName(), true)
		if err != nil {
			// Ellenőrizzük, hogy a hiba állapota 'NotFound' kódú-e
			if st, ok := status.FromError(err); ok && st.Code() == codes.NotFound {
				// this is not an error, just a swamp that does not exist
				response = append(response, &hydrapb.CountSwamp{
					SwampName: swampIdentifier.GetSwampName(),
					Count:     0,
					IsExist:   false,
				})
			} else {
				// return with grpc error message
				return nil, err
			}
		}

		swamps = append(swamps, &SwampIdentifier{
			IslandID:  swampIdentifier.GetIslandID(),
			SwampName: swampNameObject,
		})
	}

	hydraInterface := g.ZeusInterface.GetHydra()

	// iterating over only the existing swamps
	for _, swampIdentifier := range swamps {

		// summon the swamp
		swampInterface, err := hydraInterface.SummonSwamp(ctx, swampIdentifier.IslandID, swampIdentifier.SwampName)
		if err != nil {
			// return with grpc error message
			return nil, status.Error(codes.Internal, fmt.Sprintf("internal server error in hydra: %s", err.Error()))
		}
		if swampInterface == nil {
			// return with grpc error message
			return nil, status.Error(codes.Internal, "internal server error in hydra: swamp interface is nil")
		}

		func() {

			// begin the vigil, to prevent closing of the swamp
			swampInterface.BeginVigil()
			defer swampInterface.CeaseVigil()

			count := swampInterface.CountTreasures()
			response = append(response, &hydrapb.CountSwamp{
				SwampName: swampIdentifier.SwampName.Get(),
				Count:     int32(count),
				IsExist:   true,
			})

		}()

	}

	// return with the count of the treasures
	return &hydrapb.CountResponse{
		Swamps: response,
	}, nil

}

func (g Gateway) IsSwampExist(_ context.Context, in *hydrapb.IsSwampExistRequest) (*hydrapb.IsSwampExistResponse, error) {

	g.ZeusInterface.GetSafeops().LockSystem()
	defer g.ZeusInterface.GetSafeops().UnlockSystem()

	defer handlePanic()

	_, err := checkSwampName(g.ZeusInterface, in.GetIslandID(), in.SwampName, true)
	if err != nil {
		return &hydrapb.IsSwampExistResponse{
			IsExist: false,
		}, err
	}

	return &hydrapb.IsSwampExistResponse{
		IsExist: true,
	}, nil

}

func (g Gateway) IsKeyExist(_ context.Context, in *hydrapb.IsKeyExistRequest) (*hydrapb.IsKeyExistResponse, error) {

	g.ZeusInterface.GetSafeops().LockSystem()
	defer g.ZeusInterface.GetSafeops().UnlockSystem()

	defer handlePanic()

	// check if the swamp name is correct and exist
	swampName, err := checkSwampName(g.ZeusInterface, in.GetIslandID(), in.SwampName, true)
	if err != nil {
		return nil, err
	}

	// summon the swamp
	hydraInterface := g.ZeusInterface.GetHydra()
	swampInterface, err := hydraInterface.SummonSwamp(context.Background(), in.GetIslandID(), swampName)
	if err != nil {
		// return with grpc error message
		return nil, status.Error(codes.Internal, fmt.Sprintf("internal server error in hydra: %s", err.Error()))
	}

	// begin the vigil, to prevent closing of the swamp
	swampInterface.BeginVigil()
	defer swampInterface.CeaseVigil()

	isExist := swampInterface.TreasureExists(in.Key)

	return &hydrapb.IsKeyExistResponse{
		IsExist: isExist,
	}, nil

}

func (g Gateway) SubscribeToEvents(in *hydrapb.SubscribeToEventsRequest, eventServer hydrapb.HydraideService_SubscribeToEventsServer) error {

	// do not use the g.ZeusInterface.GetSafeops().LockSystem() because if we use it, we can never stop the server because of the active subscribers
	// until the client closes the connection

	defer handlePanic()

	// check if the swamp name is correct
	swampName, err := checkSwampName(g.ZeusInterface, in.GetIslandID(), in.SwampName, false)
	if err != nil {
		return status.Error(codes.InvalidArgument, err.Error())
	}

	subscriberUUID := uuid.New()

	// the subscription is successful, now we can start to send the events to the client
	// Get the server context
	hydraInterface := g.ZeusInterface.GetHydra()

	eventCallbackFunction := func(event *swamp.Event) {

		if event == nil {
			return
		}

		// send the event to the client
		defer handlePanic()

		// get the canonical form of the swamp name
		eventSwampName := event.SwampName.Get()
		// convert the hydra treasure to the protobuf format
		convertedTreasure := &hydrapb.Treasure{}
		// convert the status type to the protobuf format
		convertedStatusType := convertTreasureStatusToPbStatus(event.StatusType)

		// convert the event time to the protobuf format
		convertedEventTime := timestamppb.New(time.Unix(event.EventTime, 0))
		convertedOldTreasure := &hydrapb.Treasure{}
		convertedDeletedTreasure := &hydrapb.Treasure{}

		switch event.StatusType {
		case treasure.StatusNew:

			if event.Treasure != nil {
				treasureToKeyValuePair(event.Treasure, convertedTreasure)
			}

		case treasure.StatusModified:

			if event.Treasure != nil {
				treasureToKeyValuePair(event.Treasure, convertedTreasure)
			}
			if event.OldTreasure != nil {
				treasureToKeyValuePair(event.OldTreasure, convertedOldTreasure)
			}

		case treasure.StatusDeleted:

			if event.DeletedTreasure != nil {
				treasureToKeyValuePair(event.DeletedTreasure, convertedDeletedTreasure)
			}

		default:

			return

		}

		// send the message to the client
		if sendErr := eventServer.SendMsg(&hydrapb.SubscribeToEventsResponse{
			SwampName:       eventSwampName,
			Treasure:        convertedTreasure,
			Status:          convertedStatusType,
			OldTreasure:     convertedOldTreasure,
			DeletedTreasure: convertedDeletedTreasure,
			EventTime:       convertedEventTime,
		}); sendErr != nil {
			slog.Error("failed to send the event to the client",
				"error", sendErr.Error(),
				"swamp_name", eventSwampName)
		}

	}

	if err := hydraInterface.SubscribeToSwampEvents(subscriberUUID, swampName, eventCallbackFunction); err != nil {
		return status.Error(codes.Internal, fmt.Sprintf("internal server error in hydra: %s", err.Error()))
	}

	for {
		select {
		// we are waiting for the client to close the connection
		case <-eventServer.Context().Done():

			err := eventServer.Context().Err()
			if err != nil && !errors.Is(err, context.Canceled) {
				slog.Warn("connection closed with an unexpected error",
					"uuid", subscriberUUID,
					"error", err.Error())
			} else {
				slog.Debug("the client closed the connection gracefully",
					"uuid", subscriberUUID)
			}

			// Unsubscribe logic
			if err := hydraInterface.UnsubscribeFromSwampEvents(subscriberUUID, swampName); err != nil {
				slog.Error("failed to unsubscribe the subscriber from the swamp",
					"uuid", subscriberUUID,
					"error", err.Error())
			}

			return nil

		}
	}

}

func (g Gateway) SubscribeToInfo(in *hydrapb.SubscribeToInfoRequest, infoServer hydrapb.HydraideService_SubscribeToInfoServer) error {

	// do not use the g.ZeusInterface.GetSafeops().LockSystem() because if we use it, we can never stop the server because of the active subscribers
	// until the client closes the connection
	defer handlePanic()

	// check if the swamp name is correct
	swampName, err := checkSwampName(g.ZeusInterface, in.GetIslandID(), in.SwampName, false)
	if err != nil {
		return status.Error(codes.InvalidArgument, err.Error())
	}

	// make the channel for the subscriber
	subscriberUUID := uuid.New()

	infoSubscriptionCallbackFunction := func(info *swamp.Info) {
		// send the event to the client
		func() {

			defer handlePanic()

			// get the canonical form of the swamp name
			infoSwampName := info.SwampName.Get()

			// send the info to the client
			if sendErr := infoServer.Send(&hydrapb.SubscribeToInfoResponse{
				SwampName:   infoSwampName,
				AllElements: info.AllElements,
			}); sendErr != nil {
				slog.Error("failed to send the info to the client",
					"error", sendErr.Error(),
					"swamp_name", infoSwampName)
			}

		}()
	}

	// subscribe to the swamp for information
	hydraInterface := g.ZeusInterface.GetHydra()
	if err := hydraInterface.SubscribeToSwampInfo(subscriberUUID, swampName, infoSubscriptionCallbackFunction); err != nil {
		return status.Error(codes.Internal, fmt.Sprintf("internal server error in hydra: %s", err.Error()))
	}

	defer func() {
		handlePanic()
		// remove the subscriber from the swamp when the client closes the connection
		if err := hydraInterface.UnsubscribeFromSwampInfo(subscriberUUID, swampName); err != nil {
			slog.Error("failed to unsubscribe the subscriber from the swamp",
				"uuid", subscriberUUID,
				"error", err.Error())
		}
		slog.Debug("the subscriber is removed from the swamp",
			"uuid", subscriberUUID,
		)
	}()

	for {
		select {
		// várunk arra, hogy a user bezárja a kapcsolatot
		case <-infoServer.Context().Done():
			// remove the subscriber from the swamp when the client closes the connection
			if err := hydraInterface.UnsubscribeFromSwampInfo(subscriberUUID, swampName); err != nil {
				slog.Error("failed to unsubscribe the subscriber from the swamp",
					"uuid", subscriberUUID,
					"error", err.Error(),
				)
			}
			return nil

		}
	}

}

func (g Gateway) Uint32SlicePush(ctx context.Context, in *hydrapb.AddToUint32SlicePushRequest) (*hydrapb.AddToUint32SlicePushResponse, error) {

	g.ZeusInterface.GetSafeops().LockSystem()
	defer g.ZeusInterface.GetSafeops().UnlockSystem()

	defer handlePanic()

	if in.SwampName == "" {
		return nil, status.Error(codes.InvalidArgument, "SwampName cannot be empty")
	}

	// check the name of the swamp
	swampName, err := checkSwampName(g.ZeusInterface, in.GetIslandID(), in.SwampName, false)
	if err != nil {
		return nil, err
	}

	// get the hydra interface
	hydraInterface := g.ZeusInterface.GetHydra()

	// summon the swamp
	swampObj, err := hydraInterface.SummonSwamp(ctx, in.GetIslandID(), swampName)
	if err != nil {
		// return with grpc error message
		return nil, status.Error(codes.Internal, fmt.Sprintf("internal server error in hydra: %s", err.Error()))
	}

	// begin the vigil, to prevent closing of the swamp
	swampObj.BeginVigil()
	defer swampObj.CeaseVigil()

	var errorsWhilePush []string

	for _, pair := range in.KeySlicePairs {

		func() {

			treasureObj := swampObj.CreateTreasure(pair.GetKey())

			guardID := treasureObj.StartTreasureGuard(true)
			defer treasureObj.ReleaseTreasureGuard(guardID)

			if err := treasureObj.Uint32SlicePush(pair.GetValues()); err != nil {
				errorsWhilePush = append(errorsWhilePush, err.Error())
			}

		}()

	}

	if len(errorsWhilePush) > 0 {
		return nil, status.Error(codes.InvalidArgument, fmt.Sprintf("the following errors occurred: %s", strings.Join(errorsWhilePush, ", ")))
	}

	return nil, nil

}

func (g Gateway) Uint32SliceDelete(ctx context.Context, in *hydrapb.Uint32SliceDeleteRequest) (*hydrapb.Uint32SliceDeleteResponse, error) {

	g.ZeusInterface.GetSafeops().LockSystem()
	defer g.ZeusInterface.GetSafeops().UnlockSystem()

	defer handlePanic()

	if in.SwampName == "" {
		return nil, status.Error(codes.InvalidArgument, "SwampName cannot be empty")
	}

	// check the name of the swamp
	swampName, err := checkSwampName(g.ZeusInterface, in.GetIslandID(), in.SwampName, false)
	if err != nil {
		return nil, err
	}

	// get the hydra interface
	hydraInterface := g.ZeusInterface.GetHydra()

	// summon the swamp
	swampObj, err := hydraInterface.SummonSwamp(ctx, in.GetIslandID(), swampName)
	if err != nil {
		// return with grpc error message
		return nil, status.Error(codes.Internal, fmt.Sprintf("internal server error in hydra: %s", err.Error()))
	}

	// begin the vigil, to prevent closing of the swamp
	swampObj.BeginVigil()
	defer swampObj.CeaseVigil()

	var errorsWhileDelete []string

	for _, pair := range in.KeySlicePairs {

		func() {

			// try to load the treasure
			treasureObj, err := swampObj.GetTreasure(pair.GetKey())
			// the treasure does not exist so we can't delete the slice from it
			if err != nil {
				return
			}

			guardID := treasureObj.StartTreasureGuard(true)
			defer treasureObj.ReleaseTreasureGuard(guardID)

			if err := treasureObj.Uint32SliceDelete(pair.GetValues()); err != nil {
				errorsWhileDelete = append(errorsWhileDelete, err.Error())
			}

			// check the length of the slice in the treasure
			// if the length is 0, we can delete the treasure
			size, err := treasureObj.Uint32SliceSize()
			if err != nil || size == 0 {
				// delete the treasure
				if err := swampObj.DeleteTreasure(pair.GetKey(), false); err != nil {
					errorsWhileDelete = append(errorsWhileDelete, err.Error())
				}
			}

		}()

	}

	if len(errorsWhileDelete) > 0 {
		return nil, status.Error(codes.InvalidArgument, fmt.Sprintf("the following errors occurred: %s", strings.Join(errorsWhileDelete, ", ")))
	}

	return nil, nil

}

func (g Gateway) Uint32SliceSize(ctx context.Context, in *hydrapb.Uint32SliceSizeRequest) (*hydrapb.Uint32SliceSizeResponse, error) {

	g.ZeusInterface.GetSafeops().LockSystem()
	defer g.ZeusInterface.GetSafeops().UnlockSystem()

	defer handlePanic()

	if in.SwampName == "" {
		return nil, status.Error(codes.InvalidArgument, "SwampName cannot be empty")
	}

	// check the name of the swamp
	swampName, err := checkSwampName(g.ZeusInterface, in.GetIslandID(), in.SwampName, false)
	if err != nil {
		return nil, err
	}

	// get the hydra interface
	hydraInterface := g.ZeusInterface.GetHydra()

	// summon the swamp
	swampObj, err := hydraInterface.SummonSwamp(ctx, in.GetIslandID(), swampName)
	if err != nil {
		// return with grpc error message
		return nil, status.Error(codes.Internal, fmt.Sprintf("internal server error in hydra: %s", err.Error()))
	}

	// begin the vigil, to prevent closing of the swamp
	swampObj.BeginVigil()
	defer swampObj.CeaseVigil()

	treasureObj, err := swampObj.GetTreasure(in.GetKey())
	if err != nil {
		return &hydrapb.Uint32SliceSizeResponse{Size: 0}, status.Error(codes.InvalidArgument, fmt.Sprintf("the key does not exist: %s", err.Error()))
	}

	size, err := treasureObj.Uint32SliceSize()
	if err != nil {
		return nil, status.Error(codes.FailedPrecondition, fmt.Sprintf("the treasure type is not slice. err: %s", err.Error()))
	}

	return &hydrapb.Uint32SliceSizeResponse{Size: int64(size)}, nil

}

func (g Gateway) Uint32SliceIsValueExist(ctx context.Context, in *hydrapb.Uint32SliceIsValueExistRequest) (*hydrapb.Uint32SliceIsValueExistResponse, error) {

	g.ZeusInterface.GetSafeops().LockSystem()
	defer g.ZeusInterface.GetSafeops().UnlockSystem()

	defer handlePanic()

	if in.SwampName == "" {
		return nil, status.Error(codes.InvalidArgument, "SwampName cannot be empty")
	}

	// check the name of the swamp
	swampName, err := checkSwampName(g.ZeusInterface, in.GetIslandID(), in.SwampName, false)
	if err != nil {
		return nil, err
	}

	// get the hydra interface
	hydraInterface := g.ZeusInterface.GetHydra()

	// summon the swamp
	swampObj, err := hydraInterface.SummonSwamp(ctx, in.GetIslandID(), swampName)
	if err != nil {
		// return with grpc error message
		return nil, status.Error(codes.Internal, fmt.Sprintf("internal server error in hydra: %s", err.Error()))
	}

	// begin the vigil, to prevent closing of the swamp
	swampObj.BeginVigil()
	defer swampObj.CeaseVigil()

	treasureObj, err := swampObj.GetTreasure(in.GetKey())
	if err != nil {
		return nil, status.Error(codes.InvalidArgument, fmt.Sprintf("the key does not exist: %s", err.Error()))
	}

	sl, err := treasureObj.Uint32SliceGetAll()
	for _, value := range sl {
		if value == in.GetValue() {
			return &hydrapb.Uint32SliceIsValueExistResponse{IsExist: true}, nil
		}
	}

	return &hydrapb.Uint32SliceIsValueExistResponse{IsExist: false}, nil
}

func (g Gateway) IncrementInt8(ctx context.Context, in *hydrapb.IncrementInt8Request) (*hydrapb.IncrementInt8Response, error) {

	g.ZeusInterface.GetSafeops().LockSystem()
	defer g.ZeusInterface.GetSafeops().UnlockSystem()

	defer handlePanic()

	if in.SwampName == "" {
		// return with grpc error message
		return nil, status.Error(codes.InvalidArgument, "SwampName cannot be empty")
	}
	if in.IncrementBy == 0 {
		// return with grpc error message
		return nil, status.Error(codes.InvalidArgument, "IncrementBy cannot be zero")
	}

	// check the name of the swamp
	swampName, err := checkSwampName(g.ZeusInterface, in.GetIslandID(), in.SwampName, false)
	if err != nil {
		return nil, err
	}

	// get the hydra interface
	hydraInterface := g.ZeusInterface.GetHydra()

	// summon the swamp
	swampObj, err := hydraInterface.SummonSwamp(ctx, in.GetIslandID(), swampName)
	if err != nil {
		// return with grpc error message
		return nil, status.Error(codes.Internal, fmt.Sprintf("internal server error in hydra: %s", err.Error()))
	}

	// begin the vigil, to prevent closing of the swamp
	swampObj.BeginVigil()
	defer swampObj.CeaseVigil()

	// create the condition if it is not nil
	var condition *swamp.IncrementInt8Condition
	if in.GetCondition() != nil {
		condition = &swamp.IncrementInt8Condition{
			RelationalOperator: relationalOperatorToSwampRelationalOperator(in.GetCondition().GetRelationalOperator()),
			Value:              int8(in.GetCondition().GetValue()),
		}
	}

	// increment the value with the condition
	newValue, isIncremented, err := swampObj.IncrementInt8(in.Key, int8(in.IncrementBy), condition)
	if err != nil {
		// return with grpc error message
		return nil, status.Error(codes.InvalidArgument, fmt.Sprintf("the value of the key is not an integer: %s", err.Error()))
	}

	// return with the new value and the status of the increment
	return &hydrapb.IncrementInt8Response{
		Value:         int32(newValue),
		IsIncremented: isIncremented,
	}, nil

}

func (g Gateway) IncrementInt16(ctx context.Context, in *hydrapb.IncrementInt16Request) (*hydrapb.IncrementInt16Response, error) {

	g.ZeusInterface.GetSafeops().LockSystem()
	defer g.ZeusInterface.GetSafeops().UnlockSystem()

	defer handlePanic()

	if in.SwampName == "" {
		// return with grpc error message
		return nil, status.Error(codes.InvalidArgument, "SwampName cannot be empty")
	}
	if in.IncrementBy == 0 {
		// return with grpc error message
		return nil, status.Error(codes.InvalidArgument, "IncrementBy cannot be zero")
	}

	// check the name of the swamp
	swampName, err := checkSwampName(g.ZeusInterface, in.GetIslandID(), in.SwampName, false)
	if err != nil {
		return nil, err
	}

	// get the hydra interface
	hydraInterface := g.ZeusInterface.GetHydra()

	// summon the swamp
	swampObj, err := hydraInterface.SummonSwamp(ctx, in.GetIslandID(), swampName)
	if err != nil {
		// return with grpc error message
		return nil, status.Error(codes.Internal, fmt.Sprintf("internal server error in hydra: %s", err.Error()))
	}

	// begin the vigil, to prevent closing of the swamp
	swampObj.BeginVigil()
	defer swampObj.CeaseVigil()

	// create the condition if it is not nil
	var condition *swamp.IncrementInt16Condition
	if in.GetCondition() != nil {
		condition = &swamp.IncrementInt16Condition{
			RelationalOperator: relationalOperatorToSwampRelationalOperator(in.GetCondition().GetRelationalOperator()),
			Value:              int16(in.GetCondition().GetValue()),
		}
	}

	// increment the value with the condition
	newValue, isIncremented, err := swampObj.IncrementInt16(in.Key, int16(in.IncrementBy), condition)
	if err != nil {
		// return with grpc error message
		return nil, status.Error(codes.InvalidArgument, fmt.Sprintf("the value of the key is not an integer: %s", err.Error()))
	}

	// return with the new value and the status of the increment
	return &hydrapb.IncrementInt16Response{
		Value:         int32(newValue),
		IsIncremented: isIncremented,
	}, nil

}

func (g Gateway) IncrementInt32(ctx context.Context, in *hydrapb.IncrementInt32Request) (*hydrapb.IncrementInt32Response, error) {

	g.ZeusInterface.GetSafeops().LockSystem()
	defer g.ZeusInterface.GetSafeops().UnlockSystem()

	defer handlePanic()

	if in.SwampName == "" {
		// return with grpc error message
		return nil, status.Error(codes.InvalidArgument, "SwampName cannot be empty")
	}
	if in.IncrementBy == 0 {
		// return with grpc error message
		return nil, status.Error(codes.InvalidArgument, "IncrementBy cannot be zero")
	}

	// check the name of the swamp
	swampName, err := checkSwampName(g.ZeusInterface, in.GetIslandID(), in.SwampName, false)
	if err != nil {
		return nil, err
	}

	// get the hydra interface
	hydraInterface := g.ZeusInterface.GetHydra()

	// summon the swamp
	swampObj, err := hydraInterface.SummonSwamp(ctx, in.GetIslandID(), swampName)
	if err != nil {
		// return with grpc error message
		return nil, status.Error(codes.Internal, fmt.Sprintf("internal server error in hydra: %s", err.Error()))
	}

	// begin the vigil, to prevent closing of the swamp
	swampObj.BeginVigil()
	defer swampObj.CeaseVigil()

	// create the condition if it is not nil
	var condition *swamp.IncrementInt32Condition
	if in.GetCondition() != nil {
		condition = &swamp.IncrementInt32Condition{
			RelationalOperator: relationalOperatorToSwampRelationalOperator(in.GetCondition().GetRelationalOperator()),
			Value:              in.GetCondition().GetValue(),
		}
	}

	// increment the value with the condition
	newValue, isIncremented, err := swampObj.IncrementInt32(in.Key, in.IncrementBy, condition)
	if err != nil {
		// return with grpc error message
		return nil, status.Error(codes.InvalidArgument, fmt.Sprintf("the value of the key is not an integer: %s", err.Error()))
	}

	// return with the new value and the status of the increment
	return &hydrapb.IncrementInt32Response{
		Value:         newValue,
		IsIncremented: isIncremented,
	}, nil

}

func (g Gateway) IncrementInt64(ctx context.Context, in *hydrapb.IncrementInt64Request) (*hydrapb.IncrementInt64Response, error) {

	g.ZeusInterface.GetSafeops().LockSystem()
	defer g.ZeusInterface.GetSafeops().UnlockSystem()

	defer handlePanic()

	if in.SwampName == "" {
		// return with grpc error message
		return nil, status.Error(codes.InvalidArgument, "SwampName cannot be empty")
	}
	if in.IncrementBy == 0 {
		// return with grpc error message
		return nil, status.Error(codes.InvalidArgument, "IncrementBy cannot be zero")
	}

	// check the name of the swamp
	swampName, err := checkSwampName(g.ZeusInterface, in.GetIslandID(), in.SwampName, false)
	if err != nil {
		return nil, err
	}

	// get the hydra interface
	hydraInterface := g.ZeusInterface.GetHydra()

	// summon the swamp
	swampObj, err := hydraInterface.SummonSwamp(ctx, in.GetIslandID(), swampName)
	if err != nil {
		// return with grpc error message
		return nil, status.Error(codes.Internal, fmt.Sprintf("internal server error in hydra: %s", err.Error()))
	}

	// begin the vigil, to prevent closing of the swamp
	swampObj.BeginVigil()
	defer swampObj.CeaseVigil()

	// create the condition if it is not nil
	var condition *swamp.IncrementInt64Condition
	if in.GetCondition() != nil {
		condition = &swamp.IncrementInt64Condition{
			RelationalOperator: relationalOperatorToSwampRelationalOperator(in.GetCondition().GetRelationalOperator()),
			Value:              in.GetCondition().GetValue(),
		}
	}

	// increment the value with the condition
	newValue, isIncremented, err := swampObj.IncrementInt64(in.Key, in.IncrementBy, condition)
	if err != nil {
		// return with grpc error message
		return nil, status.Error(codes.InvalidArgument, fmt.Sprintf("the value of the key is not an integer: %s", err.Error()))
	}

	// return with the new value and the status of the increment
	return &hydrapb.IncrementInt64Response{
		Value:         newValue,
		IsIncremented: isIncremented,
	}, nil

}

func (g Gateway) IncrementUint8(ctx context.Context, in *hydrapb.IncrementUint8Request) (*hydrapb.IncrementUint8Response, error) {

	g.ZeusInterface.GetSafeops().LockSystem()
	defer g.ZeusInterface.GetSafeops().UnlockSystem()

	defer handlePanic()

	if in.SwampName == "" {
		// return with grpc error message
		return nil, status.Error(codes.InvalidArgument, "SwampName cannot be empty")
	}
	if in.IncrementBy == 0 {
		// return with grpc error message
		return nil, status.Error(codes.InvalidArgument, "IncrementBy cannot be zero")
	}

	// check the name of the swamp
	swampName, err := checkSwampName(g.ZeusInterface, in.GetIslandID(), in.SwampName, false)
	if err != nil {
		return nil, err
	}

	// get the hydra interface
	hydraInterface := g.ZeusInterface.GetHydra()

	// summon the swamp
	swampObj, err := hydraInterface.SummonSwamp(ctx, in.GetIslandID(), swampName)
	if err != nil {
		// return with grpc error message
		return nil, status.Error(codes.Internal, fmt.Sprintf("internal server error in hydra: %s", err.Error()))
	}

	// begin the vigil, to prevent closing of the swamp
	swampObj.BeginVigil()
	defer swampObj.CeaseVigil()

	// create the condition if it is not nil
	var condition *swamp.IncrementUInt8Condition
	if in.GetCondition() != nil {
		condition = &swamp.IncrementUInt8Condition{
			RelationalOperator: relationalOperatorToSwampRelationalOperator(in.GetCondition().GetRelationalOperator()),
			Value:              uint8(in.GetCondition().GetValue()),
		}
	}

	// increment the value with the condition
	newValue, isIncremented, err := swampObj.IncrementUint8(in.Key, uint8(in.IncrementBy), condition)
	if err != nil {
		// return with grpc error message
		return nil, status.Error(codes.InvalidArgument, fmt.Sprintf("the value of the key is not an integer: %s", err.Error()))
	}

	// return with the new value and the status of the increment
	return &hydrapb.IncrementUint8Response{
		Value:         uint32(newValue),
		IsIncremented: isIncremented,
	}, nil

}

func (g Gateway) IncrementUint16(ctx context.Context, in *hydrapb.IncrementUint16Request) (*hydrapb.IncrementUint16Response, error) {

	g.ZeusInterface.GetSafeops().LockSystem()
	defer g.ZeusInterface.GetSafeops().UnlockSystem()

	defer handlePanic()

	if in.SwampName == "" {
		// return with grpc error message
		return nil, status.Error(codes.InvalidArgument, "SwampName cannot be empty")
	}
	if in.IncrementBy == 0 {
		// return with grpc error message
		return nil, status.Error(codes.InvalidArgument, "IncrementBy cannot be zero")
	}

	// check the name of the swamp
	swampName, err := checkSwampName(g.ZeusInterface, in.GetIslandID(), in.SwampName, false)
	if err != nil {
		return nil, err
	}

	// get the hydra interface
	hydraInterface := g.ZeusInterface.GetHydra()

	// summon the swamp
	swampObj, err := hydraInterface.SummonSwamp(ctx, in.GetIslandID(), swampName)
	if err != nil {
		// return with grpc error message
		return nil, status.Error(codes.Internal, fmt.Sprintf("internal server error in hydra: %s", err.Error()))
	}

	// begin the vigil, to prevent closing of the swamp
	swampObj.BeginVigil()
	defer swampObj.CeaseVigil()

	// create the condition if it is not nil
	var condition *swamp.IncrementUInt16Condition
	if in.GetCondition() != nil {
		condition = &swamp.IncrementUInt16Condition{
			RelationalOperator: relationalOperatorToSwampRelationalOperator(in.GetCondition().GetRelationalOperator()),
			Value:              uint16(in.GetCondition().GetValue()),
		}
	}

	// increment the value with the condition
	newValue, isIncremented, err := swampObj.IncrementUint16(in.Key, uint16(in.IncrementBy), condition)
	if err != nil {
		// return with grpc error message
		return nil, status.Error(codes.InvalidArgument, fmt.Sprintf("the value of the key is not an integer: %s", err.Error()))
	}

	// return with the new value and the status of the increment
	return &hydrapb.IncrementUint16Response{
		Value:         uint32(newValue),
		IsIncremented: isIncremented,
	}, nil

}

func (g Gateway) IncrementUint32(ctx context.Context, in *hydrapb.IncrementUint32Request) (*hydrapb.IncrementUint32Response, error) {

	g.ZeusInterface.GetSafeops().LockSystem()
	defer g.ZeusInterface.GetSafeops().UnlockSystem()

	defer handlePanic()

	if in.SwampName == "" {
		// return with grpc error message
		return nil, status.Error(codes.InvalidArgument, "SwampName cannot be empty")
	}
	if in.IncrementBy == 0 {
		// return with grpc error message
		return nil, status.Error(codes.InvalidArgument, "IncrementBy cannot be zero")
	}

	// check the name of the swamp
	swampName, err := checkSwampName(g.ZeusInterface, in.GetIslandID(), in.SwampName, false)
	if err != nil {
		return nil, err
	}

	// get the hydra interface
	hydraInterface := g.ZeusInterface.GetHydra()

	// summon the swamp
	swampObj, err := hydraInterface.SummonSwamp(ctx, in.GetIslandID(), swampName)
	if err != nil {
		// return with grpc error message
		return nil, status.Error(codes.Internal, fmt.Sprintf("internal server error in hydra: %s", err.Error()))
	}

	// begin the vigil, to prevent closing of the swamp
	swampObj.BeginVigil()
	defer swampObj.CeaseVigil()

	// create the condition if it is not nil
	var condition *swamp.IncrementUInt32Condition
	if in.GetCondition() != nil {
		condition = &swamp.IncrementUInt32Condition{
			RelationalOperator: relationalOperatorToSwampRelationalOperator(in.GetCondition().GetRelationalOperator()),
			Value:              in.GetCondition().GetValue(),
		}
	}

	// increment the value with the condition
	newValue, isIncremented, err := swampObj.IncrementUint32(in.Key, in.IncrementBy, condition)
	if err != nil {
		// return with grpc error message
		return nil, status.Error(codes.InvalidArgument, fmt.Sprintf("the value of the key is not an integer: %s", err.Error()))
	}

	// return with the new value and the status of the increment
	return &hydrapb.IncrementUint32Response{
		Value:         newValue,
		IsIncremented: isIncremented,
	}, nil

}

func (g Gateway) IncrementUint64(ctx context.Context, in *hydrapb.IncrementUint64Request) (*hydrapb.IncrementUint64Response, error) {

	g.ZeusInterface.GetSafeops().LockSystem()
	defer g.ZeusInterface.GetSafeops().UnlockSystem()

	defer handlePanic()

	if in.SwampName == "" {
		// return with grpc error message
		return nil, status.Error(codes.InvalidArgument, "SwampName cannot be empty")
	}
	if in.IncrementBy == 0 {
		// return with grpc error message
		return nil, status.Error(codes.InvalidArgument, "IncrementBy cannot be zero")
	}

	// check the name of the swamp
	swampName, err := checkSwampName(g.ZeusInterface, in.GetIslandID(), in.SwampName, false)
	if err != nil {
		return nil, err
	}

	// get the hydra interface
	hydraInterface := g.ZeusInterface.GetHydra()

	// summon the swamp
	swampObj, err := hydraInterface.SummonSwamp(ctx, in.GetIslandID(), swampName)
	if err != nil {
		// return with grpc error message
		return nil, status.Error(codes.Internal, fmt.Sprintf("internal server error in hydra: %s", err.Error()))
	}

	// begin the vigil, to prevent closing of the swamp
	swampObj.BeginVigil()
	defer swampObj.CeaseVigil()

	// create the condition if it is not nil
	var condition *swamp.IncrementUInt64Condition
	if in.GetCondition() != nil {
		condition = &swamp.IncrementUInt64Condition{
			RelationalOperator: relationalOperatorToSwampRelationalOperator(in.GetCondition().GetRelationalOperator()),
			Value:              in.GetCondition().GetValue(),
		}
	}

	// increment the value with the condition
	newValue, isIncremented, err := swampObj.IncrementUint64(in.Key, in.IncrementBy, condition)
	if err != nil {
		// return with grpc error message
		return nil, status.Error(codes.InvalidArgument, fmt.Sprintf("the value of the key is not an integer: %s", err.Error()))
	}

	// return with the new value and the status of the increment
	return &hydrapb.IncrementUint64Response{
		Value:         newValue,
		IsIncremented: isIncremented,
	}, nil

}

func (g Gateway) IncrementFloat32(ctx context.Context, in *hydrapb.IncrementFloat32Request) (*hydrapb.IncrementFloat32Response, error) {

	g.ZeusInterface.GetSafeops().LockSystem()
	defer g.ZeusInterface.GetSafeops().UnlockSystem()

	defer handlePanic()

	if in.SwampName == "" {
		// return with grpc error message
		return nil, status.Error(codes.InvalidArgument, "SwampName cannot be empty")
	}
	if in.IncrementBy == 0 {
		// return with grpc error message
		return nil, status.Error(codes.InvalidArgument, "IncrementBy cannot be zero")
	}

	// check the name of the swamp
	swampName, err := checkSwampName(g.ZeusInterface, in.GetIslandID(), in.SwampName, false)
	if err != nil {
		return nil, err
	}

	// get the hydra interface
	hydraInterface := g.ZeusInterface.GetHydra()

	// summon the swamp
	swampObj, err := hydraInterface.SummonSwamp(ctx, in.GetIslandID(), swampName)
	if err != nil {
		// return with grpc error message
		return nil, status.Error(codes.Internal, fmt.Sprintf("internal server error in hydra: %s", err.Error()))
	}

	// begin the vigil, to prevent closing of the swamp
	swampObj.BeginVigil()
	defer swampObj.CeaseVigil()

	// create the condition if it is not nil
	var condition *swamp.IncrementFloat32Condition
	if in.GetCondition() != nil {
		condition = &swamp.IncrementFloat32Condition{
			RelationalOperator: relationalOperatorToSwampRelationalOperator(in.GetCondition().GetRelationalOperator()),
			Value:              in.GetCondition().GetValue(),
		}
	}

	// increment the value with the condition
	newValue, isIncremented, err := swampObj.IncrementFloat32(in.Key, in.IncrementBy, condition)

	if err != nil {
		// return with grpc error message
		return nil, status.Error(codes.InvalidArgument, fmt.Sprintf("the value of the key is not a float: %s", err.Error()))
	}

	// return with the new value and the status of the increment
	return &hydrapb.IncrementFloat32Response{
		Value:         newValue,
		IsIncremented: isIncremented,
	}, nil

}

func (g Gateway) IncrementFloat64(ctx context.Context, in *hydrapb.IncrementFloat64Request) (*hydrapb.IncrementFloat64Response, error) {

	g.ZeusInterface.GetSafeops().LockSystem()
	defer g.ZeusInterface.GetSafeops().UnlockSystem()

	defer handlePanic()

	if in.SwampName == "" {
		// return with grpc error message
		return nil, status.Error(codes.InvalidArgument, "SwampName cannot be empty")
	}
	if in.IncrementBy == 0 {
		// return with grpc error message
		return nil, status.Error(codes.InvalidArgument, "IncrementBy cannot be zero")
	}

	// check the name of the swamp
	swampName, err := checkSwampName(g.ZeusInterface, in.GetIslandID(), in.SwampName, false)
	if err != nil {
		return nil, err
	}

	// get the hydra interface
	hydraInterface := g.ZeusInterface.GetHydra()

	// summon the swamp
	swampObj, err := hydraInterface.SummonSwamp(ctx, in.GetIslandID(), swampName)
	if err != nil {
		// return with grpc error message
		return nil, status.Error(codes.Internal, fmt.Sprintf("internal server error in hydra: %s", err.Error()))
	}

	// begin the vigil, to prevent closing of the swamp
	swampObj.BeginVigil()
	defer swampObj.CeaseVigil()

	// create the condition if it is not nil
	var condition *swamp.IncrementFloat64Condition
	if in.GetCondition() != nil {
		condition = &swamp.IncrementFloat64Condition{
			RelationalOperator: relationalOperatorToSwampRelationalOperator(in.GetCondition().GetRelationalOperator()),
			Value:              in.GetCondition().GetValue(),
		}
	}

	// increment the value with the condition
	newValue, isIncremented, err := swampObj.IncrementFloat64(in.Key, in.IncrementBy, condition)

	if err != nil {
		// return with grpc error message
		return nil, status.Error(codes.InvalidArgument, fmt.Sprintf("the value of the key is not a float: %s", err.Error()))
	}

	// return with the new value and the status of the increment
	return &hydrapb.IncrementFloat64Response{
		Value:         newValue,
		IsIncremented: isIncremented,
	}, nil

}

// keyValuesToTreasure converts the key value pairs to the treasure content
// this function not save the treasure, only set its content
func keyValuesToTreasure(keyValuePair *hydrapb.KeyValuePair, treasureInterface treasure.Treasure, guardID guard.ID) {

	// Ensure keyValuePair is not nil to avoid panic
	if keyValuePair == nil {
		treasureInterface.SetContentVoid(guardID)
		return
	}

	// convert interface to the correct type and set the content
	switch {
	case keyValuePair.Int8Val != nil:
		treasureInterface.SetContentInt8(guardID, int8(*keyValuePair.Int8Val))
	case keyValuePair.Int16Val != nil:
		treasureInterface.SetContentInt16(guardID, int16(*keyValuePair.Int16Val))
	case keyValuePair.Int32Val != nil:
		treasureInterface.SetContentInt32(guardID, *keyValuePair.Int32Val)
	case keyValuePair.Int64Val != nil:
		treasureInterface.SetContentInt64(guardID, *keyValuePair.Int64Val)
	case keyValuePair.Uint8Val != nil:
		treasureInterface.SetContentUint8(guardID, uint8(*keyValuePair.Uint8Val))
	case keyValuePair.Uint16Val != nil:
		treasureInterface.SetContentUint16(guardID, uint16(*keyValuePair.Uint16Val))
	case keyValuePair.Uint32Val != nil:
		treasureInterface.SetContentUint32(guardID, *keyValuePair.Uint32Val)
	case keyValuePair.Uint64Val != nil:
		treasureInterface.SetContentUint64(guardID, *keyValuePair.Uint64Val)
	case keyValuePair.Float32Val != nil:
		treasureInterface.SetContentFloat32(guardID, *keyValuePair.Float32Val)
	case keyValuePair.Float64Val != nil:
		treasureInterface.SetContentFloat64(guardID, *keyValuePair.Float64Val)
	case keyValuePair.StringVal != nil:
		treasureInterface.SetContentString(guardID, *keyValuePair.StringVal)
	case keyValuePair.BoolVal != nil:
		var booleanValue bool
		switch *keyValuePair.BoolVal {
		case hydrapb.Boolean_TRUE:
			booleanValue = true
		case hydrapb.Boolean_FALSE:
			booleanValue = false
		default:
			booleanValue = false
		}
		treasureInterface.SetContentBool(guardID, booleanValue)
	case keyValuePair.BytesVal != nil:
		treasureInterface.SetContentByteArray(guardID, keyValuePair.BytesVal)
	case keyValuePair.Uint32Slice != nil:

		if err := treasureInterface.Uint32SlicePush(keyValuePair.Uint32Slice); err != nil {
			slog.Error("failed to push the uint32 slice to the treasure", "error", err.Error())
		}
	case keyValuePair.VoidVal != nil && *keyValuePair.VoidVal:
		// set the content to void
		treasureInterface.SetContentVoid(guardID)
	default:
		treasureInterface.SetContentVoid(guardID)
	}

	// set other values if they are not empty
	if isValidTimestamp(keyValuePair.GetCreatedAt()) {
		treasureInterface.SetCreatedAt(guardID, keyValuePair.GetCreatedAt().AsTime())
	}
	if keyValuePair.GetCreatedBy() != "" {
		treasureInterface.SetCreatedBy(guardID, keyValuePair.GetCreatedBy())
	}
	if isValidTimestamp(keyValuePair.GetUpdatedAt()) {
		treasureInterface.SetModifiedAt(guardID, keyValuePair.GetUpdatedAt().AsTime())
	}
	if keyValuePair.GetUpdatedBy() != "" {
		treasureInterface.SetModifiedBy(guardID, keyValuePair.GetUpdatedBy())
	}
	if isValidTimestamp(keyValuePair.GetExpiredAt()) {
		treasureInterface.SetExpirationTime(guardID, keyValuePair.GetExpiredAt().AsTime())
	}
}

// treasureToKeyValuePair converts the treasure content from the hydra to the protobuf format
func treasureToKeyValuePair(treasureInterface treasure.Treasure, t *hydrapb.Treasure) {

	// Set the key of the treasure
	t.Key = treasureInterface.GetKey()
	t.IsExist = true

	switch treasureInterface.GetContentType() {
	case treasure.ContentTypeInt8:
		val, contentErr := treasureInterface.GetContentInt8()
		if contentErr == nil {
			v := int32(val)
			t.Int8Val = &v
		}
	case treasure.ContentTypeInt16:
		val, contentErr := treasureInterface.GetContentInt16()
		if contentErr == nil {
			v := int32(val)
			t.Int16Val = &v
		}
	case treasure.ContentTypeInt32:
		val, contentErr := treasureInterface.GetContentInt32()
		if contentErr == nil {
			t.Int32Val = &val
		}
	case treasure.ContentTypeInt64:
		val, contentErr := treasureInterface.GetContentInt64()
		if contentErr == nil {
			t.Int64Val = &val
		}
	case treasure.ContentTypeUint8:
		val, contentErr := treasureInterface.GetContentUint8()
		if contentErr == nil {
			v := uint32(val)
			t.Uint8Val = &v
		}
	case treasure.ContentTypeUint16:
		val, contentErr := treasureInterface.GetContentUint16()
		if contentErr == nil {
			v := uint32(val)
			t.Uint16Val = &v
		}
	case treasure.ContentTypeUint32:
		val, contentErr := treasureInterface.GetContentUint32()
		if contentErr == nil {
			t.Uint32Val = &val
		}
	case treasure.ContentTypeUint64:
		val, contentErr := treasureInterface.GetContentUint64()
		if contentErr == nil {
			t.Uint64Val = &val
		}
	case treasure.ContentTypeFloat32:
		val, contentErr := treasureInterface.GetContentFloat32()
		if contentErr == nil {
			t.Float32Val = &val
		}
	case treasure.ContentTypeFloat64:
		val, contentErr := treasureInterface.GetContentFloat64()
		if contentErr == nil {
			t.Float64Val = &val
		}
	case treasure.ContentTypeString:
		val, contentErr := treasureInterface.GetContentString()
		if contentErr == nil {
			t.StringVal = &val
		}
	case treasure.ContentTypeBoolean:
		val, contentErr := treasureInterface.GetContentBool()
		if contentErr == nil {
			// convert the boolean to the protobuf type
			if val {
				t.BoolVal = hydrapb.Boolean_TRUE.Enum()
			} else {
				t.BoolVal = hydrapb.Boolean_FALSE.Enum()
			}
		}
	case treasure.ContentTypeByteArray:
		val, contentErr := treasureInterface.GetContentByteArray()
		if contentErr == nil {
			t.BytesVal = val
		}
	case treasure.ContentTypeUint32Slice:
		val, contentErr := treasureInterface.Uint32SliceGetAll()
		if contentErr == nil {
			t.Uint32Slice = val
		}
	default:
		// do nothing
	}

	if treasureInterface.GetCreatedAt() > 0 {
		t.CreatedAt = timestamppb.New(time.Unix(0, treasureInterface.GetCreatedAt()))
	}
	if treasureInterface.GetCreatedBy() != "" {
		createdBy := t.GetCreatedBy()
		t.CreatedBy = &createdBy
	}
	if treasureInterface.GetModifiedAt() > 0 {
		t.UpdatedAt = timestamppb.New(time.Unix(0, treasureInterface.GetModifiedAt()))
	}
	if t.GetUpdatedBy() != "" {
		updatedBy := t.GetUpdatedBy()
		t.UpdatedBy = &updatedBy
	}
	if treasureInterface.GetExpirationTime() > 0 {
		t.ExpiredAt = timestamppb.New(time.Unix(0, treasureInterface.GetExpirationTime()))
	}

}

// isValidTimestamp checks if the timestamp is valid
func isValidTimestamp(ts *timestamppb.Timestamp) bool {
	if ts == nil {
		return false
	}
	return ts.GetSeconds() > 0 || ts.GetNanos() > 0
}

// convertTreasureStatusToPbStatus converts the treasure status from the hydra to the protobuf status
func convertTreasureStatusToPbStatus(treasureStatus treasure.TreasureStatus) hydrapb.Status_Code {
	switch treasureStatus {
	case treasure.StatusNew:
		return hydrapb.Status_NEW
	case treasure.StatusModified:
		return hydrapb.Status_UPDATED
	case treasure.StatusSame:
		return hydrapb.Status_NOTHING_CHANGED
	case treasure.StatusDeleted:
		return hydrapb.Status_DELETED
	default:
		return hydrapb.Status_NOT_FOUND
	}
}

// handle all the panics in the gateway
func handlePanic() {
	if r := recover(); r != nil {
		// get the stack trace
		stackTrace := debug.Stack()
		// log the panic with the error and stack trace
		slog.Error("grpc gateway panic", "error", r, "stack", string(stackTrace))
	}
}

// checkSwampName check if the swamp name is valid and exist or not.
// The function will return a grpc error message if the swamp name is invalid or does not exist.
func checkSwampName(zeusInterface zeus.Zeus, islandID uint64, inputSwampName string, checkExist bool) (name.Name, error) {

	// check the input
	if inputSwampName == "" {
		// return with grpc error message
		return nil, status.Error(codes.InvalidArgument, "SwampName cannot be empty")
	}
	swampName := name.Load(inputSwampName)

	// check the existence of the swamp only if it is needed
	// because the Set method does not need to check the existence of the swamp
	if checkExist {
		// check if the swamp is exist or not
		hydraInterface := zeusInterface.GetHydra()
		isExist, err := hydraInterface.IsExistSwamp(islandID, swampName)
		if err != nil || !isExist {
			// return with grpc error message
			return nil, status.Error(codes.FailedPrecondition, "Swamp does not exist")
		}
	}

	return swampName, nil

}

func inputIndexTypeToBeaconType(inputIndexType hydrapb.IndexType_Type) swamp.BeaconType {
	switch inputIndexType {
	case hydrapb.IndexType_EXPIRATION_TIME:
		return swamp.BeaconTypeExpirationTime
	case hydrapb.IndexType_CREATION_TIME:
		return swamp.BeaconTypeCreationTime
	case hydrapb.IndexType_UPDATE_TIME:
		return swamp.BeaconTypeUpdateTime
	case hydrapb.IndexType_VALUE_INT8:
		return swamp.BeaconTypeValueInt8
	case hydrapb.IndexType_VALUE_INT16:
		return swamp.BeaconTypeValueInt16
	case hydrapb.IndexType_VALUE_INT32:
		return swamp.BeaconTypeValueInt32
	case hydrapb.IndexType_VALUE_INT64:
		return swamp.BeaconTypeValueInt64
	case hydrapb.IndexType_VALUE_UINT8:
		return swamp.BeaconTypeValueUint8
	case hydrapb.IndexType_VALUE_UINT16:
		return swamp.BeaconTypeValueUint16
	case hydrapb.IndexType_VALUE_UINT32:
		return swamp.BeaconTypeValueUint32
	case hydrapb.IndexType_VALUE_UINT64:
		return swamp.BeaconTypeValueUint64
	case hydrapb.IndexType_VALUE_FLOAT32:
		return swamp.BeaconTypeValueFloat32
	case hydrapb.IndexType_VALUE_FLOAT64:
		return swamp.BeaconTypeValueFloat64
	case hydrapb.IndexType_VALUE_STRING:
		return swamp.BeaconTypeValueString
	default:
		return swamp.BeaconTypeValueString
	}
}

func inputOrderTypeToBeaconOrderType(inputOrderType hydrapb.OrderType_Type) swamp.BeaconOrder {
	switch inputOrderType {
	case hydrapb.OrderType_ASC:
		return swamp.IndexOrderAsc
	case hydrapb.OrderType_DESC:
		return swamp.IndexOrderDesc
	default:
		return swamp.IndexOrderAsc
	}
}

func relationalOperatorToSwampRelationalOperator(operator hydrapb.Relational_Operator) swamp.RelationalOperator {
	switch operator {
	case hydrapb.Relational_EQUAL:
		return swamp.RelationalOperatorEqual
	case hydrapb.Relational_LESS_THAN:
		return swamp.RelationalOperatorLessThan
	case hydrapb.Relational_LESS_THAN_OR_EQUAL:
		return swamp.RelationalOperatorLessThanOrEqual
	case hydrapb.Relational_GREATER_THAN:
		return swamp.RelationalOperatorGreaterThan
	case hydrapb.Relational_GREATER_THAN_OR_EQUAL:
		return swamp.RelationalOperatorGreaterThanOrEqual
	case hydrapb.Relational_NOT_EQUAL:
		return swamp.RelationalOperatorNotEqual
	default:
		return swamp.RelationalOperatorEqual
	}
}

--------------------------------------------------------------------------------

/==============================================================================\
| FILE: server\loghandlers\fallback\fallback.go
| PATH: C:\go\src\hydraide\app\server\loghandlers\fallback\fallback.go
| SIZE: 6.2 KB
\==============================================================================/

// Package fallback implements a resilient slog.Handler that combines a primary
// log destination (e.g., Graylog) with a local file fallback. If the primary
// destination is unavailable, logs are automatically written to a rotating
// fallback file instead. Once the primary becomes reachable again, logs are
// replayed from the file back to the primary sink in the background.
//
// Features:
//   - Seamless failover to local file if remote logging is down
//   - Automatic background retry every 30s to flush stored logs
//   - Dual-handler support for primary and fallback destinations
//   - Rotation logic to avoid unbounded log file growth
//
// Use this handler to guarantee that logs are never lost — even across
// network failures, container restarts, or temporary outages.
package fallback

import (
	"bufio"
	"context"
	"encoding/json"
	"errors"
	"fmt"
	"log/slog"
	"os"
	"sync"
	"time"
)

const (
	fallbackLogFile       = "fallback.log"
	fallbackBackupLogFile = "fallback.log.old"
	maxFileSize           = 10 * 1024 * 1024 // 10MB
)

// Handler routes log records to a primary handler (e.g., Graylog) when reachable,
// and to a fallback handler (e.g., JSON file) otherwise.
type Handler struct {
	primary      slog.Handler  // main log destination
	fallback     slog.Handler  // backup log sink (usually file)
	checker      func() bool   // returns true if primary is reachable
	dispatchOnce sync.Once     // ensures retry loop is only started once
	retryTicker  *time.Ticker  // retry interval for log flush
	shutdown     chan struct{} // graceful shutdown signal
}

// New creates a new fallback handler with the given primary and fallback handlers.
// The checker function determines whether the primary is currently available.
func New(primary, fallback slog.Handler, checker func() bool) *Handler {
	h := &Handler{
		primary:  primary,
		fallback: fallback,
		checker:  checker,
		shutdown: make(chan struct{}),
	}

	h.dispatchOnce.Do(func() {
		h.retryTicker = time.NewTicker(30 * time.Second)
		go h.retryLoop()
	})

	return h
}

// Enabled returns true if either the primary or fallback handler is enabled for the log level.
func (h *Handler) Enabled(ctx context.Context, level slog.Level) bool {
	return h.primary.Enabled(ctx, level) || h.fallback.Enabled(ctx, level)
}

// Handle sends the log record to the primary if reachable, otherwise stores it via fallback.
func (h *Handler) Handle(ctx context.Context, r slog.Record) error {
	if h.checker() {
		return h.primary.Handle(ctx, r)
	}

	err := h.fallback.Handle(ctx, r)
	if err != nil {
		_, _ = fmt.Fprintf(os.Stderr, "fallback handler failed: %v\n", err)
	}
	return nil
}

// WithAttrs adds structured attributes to both primary and fallback handlers.
func (h *Handler) WithAttrs(attrs []slog.Attr) slog.Handler {
	return &Handler{
		primary:     h.primary.WithAttrs(attrs),
		fallback:    h.fallback.WithAttrs(attrs),
		checker:     h.checker,
		shutdown:    h.shutdown,
		retryTicker: h.retryTicker,
	}
}

// WithGroup applies grouping to both handlers (no-op grouping supported).
func (h *Handler) WithGroup(name string) slog.Handler {
	return &Handler{
		primary:     h.primary.WithGroup(name),
		fallback:    h.fallback.WithGroup(name),
		checker:     h.checker,
		shutdown:    h.shutdown,
		retryTicker: h.retryTicker,
	}
}

// retryLoop runs in background and periodically flushes the fallback log file if the primary becomes available.
func (h *Handler) retryLoop() {
	for {
		select {
		case <-h.retryTicker.C:
			if h.checker() {
				h.flushFallback()
			}
		case <-h.shutdown:
			h.retryTicker.Stop()
			return
		}
	}
}

// flushFallback reads stored fallback logs and replays them to the primary handler.
func (h *Handler) flushFallback() {
	files := []string{fallbackLogFile, fallbackBackupLogFile}
	for _, file := range files {
		_ = processFile(file, h.primary)
	}
}

// processFile reads and re-emits each JSON log line to the provided primary handler.
// Unsuccessful lines are preserved in a temp file to avoid data loss.
func processFile(path string, primary slog.Handler) error {
	input, err := os.Open(path)
	if err != nil {
		if errors.Is(err, os.ErrNotExist) {
			return nil
		}
		return err
	}
	defer func() {
		_ = input.Close()
	}()

	temp := path + ".tmp"
	tmp, err := os.Create(temp)
	if err != nil {
		return err
	}
	defer func() {
		_ = tmp.Close()
	}()

	scanner := bufio.NewScanner(input)
	for scanner.Scan() {
		line := scanner.Bytes()
		var data map[string]interface{}
		if err := json.Unmarshal(line, &data); err != nil {
			_, _ = tmp.Write(line)
			_, _ = tmp.Write([]byte("\n"))
			continue
		}

		r := recordFromGELF(data)
		err := primary.Handle(context.Background(), r)
		if err != nil {
			_, _ = tmp.Write(line)
			_, _ = tmp.Write([]byte("\n"))
		}
	}

	_ = input.Close()
	_ = tmp.Close()
	_ = os.Rename(temp, path)
	return nil
}

// recordFromGELF reconstructs a slog.Record from GELF JSON data.
func recordFromGELF(data map[string]interface{}) slog.Record {
	msg := fmt.Sprintf("%v", data["short_message"])
	ts := time.Now()
	if t, ok := data["timestamp"].(float64); ok {
		ts = time.Unix(int64(t), 0)
	}
	rec := slog.NewRecord(ts, slog.LevelInfo, msg, 0)
	for k, v := range data {
		if len(k) > 1 && k[0] == '_' {
			rec.AddAttrs(slog.Any(k[1:], v))
		}
	}
	return rec
}

// LocalHandler creates a file-based JSON slog.Handler that writes to fallback.log.
func LocalHandler(minLevel slog.Level) slog.Handler {
	f, err := os.OpenFile(fallbackLogFile, os.O_APPEND|os.O_CREATE|os.O_WRONLY, 0644)
	if err != nil {
		panic(fmt.Sprintf("cannot open fallback file: %v", err))
	}
	rotateIfNeeded(f)
	return slog.NewJSONHandler(f, &slog.HandlerOptions{Level: minLevel})
}

// rotateIfNeeded rotates the fallback file if it exceeds maxFileSize.
func rotateIfNeeded(f *os.File) {
	fi, err := f.Stat()
	if err == nil && fi.Size() >= maxFileSize {
		_ = f.Close()
		_ = os.Rename(fallbackLogFile, fallbackBackupLogFile)
		_, _ = os.Create(fallbackLogFile)
	}
}

// Stop gracefully shuts down the retry loop and background processing.
func (h *Handler) Stop() {
	close(h.shutdown)
}

--------------------------------------------------------------------------------

/==============================================================================\
| FILE: server\loghandlers\graylog\graylog.go
| PATH: C:\go\src\hydraide\app\server\loghandlers\graylog\graylog.go
| SIZE: 6.2 KB
\==============================================================================/

// Package graylog implements a slog.Handler that sends logs to Graylog using
// asynchronous background dispatch with fallback awareness.
package graylog

import (
	"context"
	"encoding/json"
	"errors"
	"fmt"
	"log/slog"
	"net"
	"sync"
)

// Handler is a slog.Handler implementation that sends log messages to a Graylog server via TCP asynchronously.
// It uses an internal queue and a background dispatcher to avoid blocking the main execution flow.
// If the connection fails, it retries automatically and maintains the queue until shutdown.
type Handler struct {
	address string      // Graylog TCP address (e.g., "127.0.0.1:12201")
	host    string      // Logical hostname or service identifier sent as the GELF "host" field
	level   slog.Level  // Minimum log level to emit (e.g., Info, Warn, Error)
	attrs   []slog.Attr // Static attributes included with every log record

	queue    chan []byte        // Buffered channel for asynchronous log message delivery
	ctx      context.Context    // Context for graceful shutdown of the dispatcher
	cancel   context.CancelFunc // Cancel function to signal dispatcher shutdown
	once     sync.Once          // Ensures dispatcher is started only once
	retryMux sync.Mutex         // Mutex to synchronize reconnect attempts
	conn     net.Conn           // Active TCP connection to Graylog
}

const queueSize = 1000 // Max number of pending messages before dropping new ones

// New creates a new asynchronous Graylog handler with a background dispatcher.
// It connects to the specified Graylog address and starts a goroutine that sends logs from a buffered queue.
func New(address, host string, level slog.Level) (*Handler, error) {
	ctx, cancel := context.WithCancel(context.Background())
	h := &Handler{
		address: address,
		host:    host,
		level:   level,
		queue:   make(chan []byte, queueSize),
		ctx:     ctx,
		cancel:  cancel,
	}
	go h.dispatcher() // Start background log dispatcher
	return h, nil
}

// Enabled reports whether a given log level is enabled for this handler.
// This allows slog to skip formatting logs that would not be sent.
func (h *Handler) Enabled(_ context.Context, level slog.Level) bool {
	return level >= h.level
}

// WithAttrs returns a shallow copy of the handler with additional attributes added.
// These attributes will be included in all subsequent log messages emitted by the handler.
func (h *Handler) WithAttrs(attrs []slog.Attr) slog.Handler {
	return &Handler{
		address: h.address,
		host:    h.host,
		level:   h.level,
		attrs:   append(h.attrs, attrs...), // merge existing and new attributes
		queue:   h.queue,
		ctx:     h.ctx,
		cancel:  h.cancel,
	}
}

// WithGroup returns the same handler, as attribute grouping is not supported in this implementation.
func (h *Handler) WithGroup(_ string) slog.Handler {
	return h
}

// Handle processes a single log record and enqueues it for asynchronous delivery to Graylog.
// It transforms the slog.Record into a GELF-compatible JSON object, appends static and dynamic attributes,
// and sends it to the internal queue for background dispatch.
func (h *Handler) Handle(_ context.Context, r slog.Record) error {
	extras := map[string]interface{}{}

	// Merge static attributes from handler setup
	for _, attr := range h.attrs {
		extras[attr.Key] = attr.Value.Any()
	}

	// Merge dynamic attributes from the log record
	r.Attrs(func(attr slog.Attr) bool {
		extras[attr.Key] = attr.Value.Any()
		return true
	})

	// Extract and optionally isolate stack trace
	var stack string
	if s, ok := extras["stack"]; ok {
		stack, _ = s.(string)
		delete(extras, "stack") // avoid duplicate field in GELF payload
	}

	// Base GELF fields required by Graylog
	msg := map[string]interface{}{
		"version":       "1.1",
		"host":          h.host,
		"short_message": r.Message,
		"timestamp":     float64(r.Time.UnixNano()) / 1e9,
		"level":         convertLevel(r.Level),
	}

	// Add full_message only if stack is available
	if stack != "" {
		msg["full_message"] = stack
		msg["_stack_only"] = true // optional internal flag for debugging
	}

	// Prefix extra attributes with "_" as required by GELF spec
	for k, v := range extras {
		msg["_"+k] = v
	}

	// Marshal message to JSON format
	data, err := json.Marshal(msg)
	if err != nil {
		return fmt.Errorf("failed to marshal GELF: %w", err)
	}

	// Enqueue for background delivery; drop if queue is full
	select {
	case h.queue <- append(data, '\n'):
		return nil
	default:
		return errors.New("graylog queue is full") // optional: could write to fallback
	}
}

// dispatcher runs in a background goroutine and sends log messages from the queue to the Graylog server.
// It maintains a single persistent TCP connection, reconnecting if the connection is lost.
func (h *Handler) dispatcher() {
	var err error

	for {
		select {
		case <-h.ctx.Done():
			// Graceful shutdown: close connection if active
			if h.conn != nil {
				_ = h.conn.Close()
			}
			return

		case msg := <-h.queue:
			func() {
				h.retryMux.Lock()
				defer h.retryMux.Unlock()

				// Establish TCP connection if not already connected
				if h.conn == nil {
					fmt.Println("Graylog connection not established, attempting to connect...")

					h.conn, err = net.Dial("tcp", h.address)
					if err != nil {
						return // skip this message, keep it in queue
					}
				}

				// Write message + NULL byte (0x00 terminator required by GELF TCP)
				_, err := h.conn.Write(append(msg, 0x00))
				if err != nil {
					_ = h.conn.Close()
					h.conn = nil
					return
				}

			}()
		}
	}
}

// convertLevel maps slog.Level values to GELF numerical levels.
// GELF uses syslog-style severity levels (0=emergency to 7=debug).
func convertLevel(level slog.Level) int {
	switch level {
	case slog.LevelDebug:
		return 7 // debug
	case slog.LevelInfo:
		return 6 // info
	case slog.LevelWarn:
		return 4 // warning
	case slog.LevelError:
		return 3 // error
	default:
		return 6 // fallback to info
	}
}

// Close gracefully shuts down the handler, stopping the dispatcher goroutine
// and releasing the TCP connection to Graylog.
func (h *Handler) Close() error {
	h.once.Do(func() {
		h.cancel() // cancel dispatcher context
	})
	return nil
}

--------------------------------------------------------------------------------

/==============================================================================\
| FILE: server\loghandlers\slogmulti\slogmulti.go
| PATH: C:\go\src\hydraide\app\server\loghandlers\slogmulti\slogmulti.go
| SIZE: 2.3 KB
\==============================================================================/

// Package slogmulti provides a slog.Handler implementation that fans out
// log records to multiple handlers. This allows logs to be written
// simultaneously to various destinations, such as console, files, or remote sinks
// like Graylog or syslog. It preserves the behavior of each handler
// and aggregates errors during log emission.
//
// Example usage:
//
//	logger := slog.New(
//		slogmulti.New(
//			slog.NewTextHandler(os.Stdout, nil),
//			fileHandler,
//			graylogHandler,
//		),
//	)
//	slog.SetDefault(logger)
package slogmulti

import (
	"context"
	"log/slog"
)

// MultiHandler is a slog.Handler that dispatches log records to multiple child handlers.
// It enables simultaneous logging to different outputs (e.g., console + file + network).
type MultiHandler struct {
	handlers []slog.Handler
}

// New constructs a MultiHandler that fans out logs to the provided handlers.
func New(handlers ...slog.Handler) slog.Handler {
	return &MultiHandler{handlers: handlers}
}

// Enabled returns true if any of the child handlers is enabled for the given level.
// If none are enabled, the log record will be skipped entirely.
func (m *MultiHandler) Enabled(ctx context.Context, level slog.Level) bool {
	for _, h := range m.handlers {
		if h.Enabled(ctx, level) {
			return true
		}
	}
	return false
}

// Handle sends the log record to all enabled child handlers.
// If any of them returns an error, the last error is returned.
func (m *MultiHandler) Handle(ctx context.Context, r slog.Record) error {
	var err error
	for _, h := range m.handlers {
		if e := h.Handle(ctx, r); e != nil {
			err = e
		}
	}
	return err
}

// WithAttrs returns a new MultiHandler with the given attributes added to all child handlers.
func (m *MultiHandler) WithAttrs(attrs []slog.Attr) slog.Handler {
	hs := make([]slog.Handler, len(m.handlers))
	for i, h := range m.handlers {
		hs[i] = h.WithAttrs(attrs)
	}
	return &MultiHandler{handlers: hs}
}

// WithGroup returns a new MultiHandler with a log group added to all child handlers.
// Groups are useful for nesting structured attributes under a common key.
func (m *MultiHandler) WithGroup(name string) slog.Handler {
	hs := make([]slog.Handler, len(m.handlers))
	for i, h := range m.handlers {
		hs[i] = h.WithGroup(name)
	}
	return &MultiHandler{handlers: hs}
}

--------------------------------------------------------------------------------

/==============================================================================\
| FILE: server\main.go
| PATH: C:\go\src\hydraide\app\server\main.go
| SIZE: 9.5 KB
\==============================================================================/

package main

import (
	"fmt"
	"github.com/hydraide/hydraide/app/server/loghandlers/fallback"
	"github.com/hydraide/hydraide/app/server/loghandlers/graylog"
	"github.com/hydraide/hydraide/app/server/loghandlers/slogmulti"
	"github.com/hydraide/hydraide/app/server/server"
	"log/slog"
	"net"
	"net/http"
	"os"
	"os/signal"
	"path/filepath"
	"runtime/debug"
	"strconv"
	"syscall"
	"time"

	"github.com/joho/godotenv"
)

var serverInterface server.Server

var (
	graylogServer         = ""
	graylogServiceName    = ""
	logLevel              = "debug"
	hydraMaxMessageSize   = 104857600 // 100 MB
	defaultCloseAfterIdle = int64(1)  // 1 second
	defaultWriteInterval  = int64(10) // 10 seconds
	defaultFileSize       = int64(0)  // 1 GB
	systemResourceLogging = false
	serverCrtPath         = ""
	serverKeyPath         = ""
	hydraServerPort       = int(4444)
	healthCheckPort       = int(4445)
)

func init() {

	// Load environment variables from .env files before anything else
	_ = godotenv.Load()

	// check if the HYDRAIDE_SERVER_PORT and HEALTH_CHECK_PORT environment variables are set
	var err error
	if os.Getenv("HYDRAIDE_SERVER_PORT") != "" {
		if hydraServerPort, err = strconv.Atoi(os.Getenv("HYDRAIDE_SERVER_PORT")); err != nil {
			panic(fmt.Sprintf("HYDRAIDE_SERVER_PORT must be a number without any string characters: %v", err))
		}
	}
	if os.Getenv("HEALTH_CHECK_PORT") != "" {
		if healthCheckPort, err = strconv.Atoi(os.Getenv("HEALTH_CHECK_PORT")); err != nil {
			panic(fmt.Sprintf("HEALTH_CHECK_PORT must be a number without any string characters: %v", err))
		}
	}

	if os.Getenv("HYDRAIDE_ROOT_PATH") == "" {
		slog.Error("HYDRAIDE_ROOT_PATH environment variable is not set")
		panic("HYDRAIDE_ROOT_PATH environment variable is not set")
	}

	// should be handled these for linux and windows
	serverCrtPath = filepath.Join(os.Getenv("HYDRAIDE_ROOT_PATH"), "certificate", "server.crt")
	serverKeyPath = filepath.Join(os.Getenv("HYDRAIDE_ROOT_PATH"), "certificate", "server.key")

	if _, err := os.Stat(serverCrtPath); os.IsNotExist(err) {
		slog.Error("server certificate file server.crt are not found", "error", err.Error())
		panic(fmt.Sprintf("server certificate file server.crt are not found in %s", serverCrtPath))
	}

	// check if the server key and certificate files exist
	if _, err := os.Stat(serverCrtPath); os.IsNotExist(err) {
		slog.Error("server certificate file server.crt are not found", "error", err.Error())
		panic(fmt.Sprintf("server certificate file server.crt are not found in %s", serverCrtPath))
	}
	if _, err := os.Stat(serverKeyPath); os.IsNotExist(err) {
		slog.Error("server certificate file server.key are not found", "error", err.Error())
		panic(fmt.Sprintf("server certificate file server.key are not found in %s", serverKeyPath))
	}

	// log level must have
	if os.Getenv("LOG_LEVEL") != "" {
		logLevel = os.Getenv("LOG_LEVEL")
	}

	if os.Getenv("SYSTEM_RESOURCE_LOGGING") == "true" {
		systemResourceLogging = true // default system resource logging is disabled
	}

	if os.Getenv("GRAYLOG_ENABLED") == "true" {
		if os.Getenv("GRAYLOG_SERVER") != "" {
			graylogServer = os.Getenv("GRAYLOG_SERVER")
		}
		// GRAYLOG_SERVICE_NAME is optional environment variable. Set the graylog service name only if it is set
		if os.Getenv("GRAYLOG_SERVICE_NAME") != "" {
			graylogServiceName = os.Getenv("GRAYLOG_SERVICE_NAME")
		}
	}

	// HYDRA_MAX_MESSAGE_SIZE environment variable
	if os.Getenv("GRPC_MAX_MESSAGE_SIZE") != "" {
		var err error
		hydraMaxMessageSize, err = strconv.Atoi(os.Getenv("GRPC_MAX_MESSAGE_SIZE"))
		if err != nil {
			slog.Error("GRPC_MAX_MESSAGE_SIZE must be a number without any string characters", "error", err)
			panic("GRPC_MAX_MESSAGE_SIZE must be a number without any string characters")
		}
	}

	if os.Getenv("HYDRAIDE_DEFAULT_CLOSE_AFTER_IDLE") != "" {
		dcai, err := strconv.Atoi(os.Getenv("HYDRAIDE_DEFAULT_CLOSE_AFTER_IDLE"))
		if err != nil {
			slog.Error("HYDRAIDE_DEFAULT_CLOSE_AFTER_IDLE must be a number without any string characters", "error", err)
			panic("HYDRAIDE_DEFAULT_CLOSE_AFTER_IDLE must be a number without any string characters")
		}
		defaultCloseAfterIdle = int64(dcai)
	}

	if os.Getenv("HYDRAIDE_DEFAULT_WRITE_INTERVAL") != "" {
		dwi, err := strconv.Atoi(os.Getenv("HYDRAIDE_DEFAULT_WRITE_INTERVAL"))
		if err != nil {
			slog.Error("HYDRAIDE_DEFAULT_WRITE_INTERVAL must be a number without any string characters", "error", err)
			panic("HYDRAIDE_DEFAULT_WRITE_INTERVAL must be a number without any string characters")
		}
		defaultWriteInterval = int64(dwi)
	}

	if os.Getenv("HYDRAIDE_DEFAULT_FILE_SIZE") != "" {
		dfs, err := strconv.Atoi(os.Getenv("HYDRAIDE_DEFAULT_FILE_SIZE"))
		if err != nil {
			slog.Error("HYDRAIDE_DEFAULT_FILE_SIZE must be a number without any string characters", "error", err)
			panic("HYDRAIDE_DEFAULT_FILE_SIZE must be a number without any string characters")
		}
		defaultFileSize = int64(dfs)
	}

}

func main() {

	defer panicHandler()

	// ----------------------------------------------------------------------------
	// Logger setup with console output + optional Graylog + file fallback
	// ----------------------------------------------------------------------------
	// Logging architecture:
	// - Always: logs go to console
	// - If Graylog is defined:
	//   - logs go to Graylog
	//   - if Graylog fails, logs go to fallback.log (and are retried later)
	// - If Graylog is undefined: logs go ONLY to console (no file write)
	// ----------------------------------------------------------------------------

	ll := parseLogLevel(logLevel)
	graylogAvailable := graylogServer != ""

	// Console handler — always active
	consoleHandler := slog.NewTextHandler(os.Stdout, &slog.HandlerOptions{
		Level: ll,
	})

	// Optional Graylog + fallback setup
	var combinedHandler slog.Handler

	if graylogAvailable {
		// Attempt to connect to Graylog
		gh, err := graylog.New(graylogServer, graylogServiceName, ll)
		if err != nil {
			fmt.Printf("failed to connect to Graylog: %v\n", err)
			graylogAvailable = false
		} else {
			defer func() { _ = gh.Close() }()
			slog.Info("Graylog handler initialized",
				slog.String("server", graylogServer),
				slog.String("service", graylogServiceName))

			// Local file fallback (only enabled if Graylog is used)
			localHandler := fallback.LocalHandler(ll)

			combinedHandler = fallback.New(
				gh,
				localHandler,
				func() bool {
					conn, err := net.DialTimeout("tcp", graylogServer, 1*time.Second)
					if err != nil {
						return false
					}
					_ = conn.Close()
					return true
				},
			)
		}
	}

	// Final logger: console only, or console + Graylog + fallback
	if combinedHandler != nil {
		logger := slog.New(slogmulti.New(consoleHandler, combinedHandler))
		slog.SetDefault(logger)
	} else {
		logger := slog.New(consoleHandler)
		slog.SetDefault(logger)
	}

	slog.Info("logger successfully initialized")

	// start the new Hydra server
	serverInterface = server.New(&server.Configuration{
		CertificateCrtFile:    serverCrtPath,
		CertificateKeyFile:    serverKeyPath,
		HydraServerPort:       hydraServerPort,
		HydraMaxMessageSize:   hydraMaxMessageSize,
		DefaultCloseAfterIdle: defaultCloseAfterIdle,
		DefaultWriteInterval:  defaultWriteInterval,
		DefaultFileSize:       defaultFileSize,
		SystemResourceLogging: systemResourceLogging,
	})

	if err := serverInterface.Start(); err != nil {
		slog.Error("HydrAIDE server is not running", "error", err)
		panic(fmt.Sprintf("HydrAIDE server is not running: %v", err))
	}

	go func() {
		http.HandleFunc("/health", healthCheckHandler)
		port := fmt.Sprintf(":%d", healthCheckPort)
		if err := http.ListenAndServe(port, nil); err != nil {
			slog.Error("http server error - health check server is not running", "error", err)
		}
	}()

	// blocker for the main goroutine and waiting for kill signal
	waitingForKillSignal()

}

func parseLogLevel(level string) slog.Level {
	switch level {
	case "debug":
		return slog.LevelDebug
	case "info":
		return slog.LevelInfo
	case "warn":
		return slog.LevelWarn
	case "error":
		return slog.LevelError
	default:
		return slog.LevelInfo
	}
}

func panicHandler() {
	if r := recover(); r != nil {
		// get the stack trace
		stackTrace := debug.Stack()
		// Log the panic error and stack trace
		slog.Error("caught panic", "error", r, "stack", string(stackTrace))
		// get the graceful stop
		gracefulStop()
	}
}

func gracefulStop() {
	// stop the microservice and exit the program
	serverInterface.Stop()
	slog.Info("hydra server stopped gracefully. Program is exiting...")
	// waiting for logs to be written to the file
	time.Sleep(1 * time.Second)
	// exit the program if the microservice is stopped gracefully
	os.Exit(0)
}

func waitingForKillSignal() {
	slog.Info("HydrAIDE server waiting for kill signal")
	gracefulStopSignal := make(chan os.Signal, 1)
	signal.Notify(gracefulStopSignal, syscall.SIGKILL, syscall.SIGINT, syscall.SIGTERM, syscall.SIGQUIT)
	// waiting for graceful stop signal
	<-gracefulStopSignal
	slog.Info("kill signal received, stopping the server gracefully")
	gracefulStop()
}

func healthCheckHandler(w http.ResponseWriter, _ *http.Request) {
	if serverInterface == nil {
		// unhealthy
		w.WriteHeader(http.StatusInternalServerError)
		return
	}
	if !serverInterface.IsHydraRunning() {
		// unhealthy
		w.WriteHeader(http.StatusInternalServerError)
	}
	// healthy
	w.WriteHeader(http.StatusOK)
}

--------------------------------------------------------------------------------

/==============================================================================\
| FILE: server\Makefile
| PATH: C:\go\src\hydraide\app\server\Makefile
| SIZE: 1.1 KB
\==============================================================================/

IMAGE_NAME=ghcr.io/hydraide/hydraide
IMAGE_TAG=$(IMAGE_TAG)

# load the .env file to get the GitHub username and token
include .env
export $(shell sed 's/=.*//' .env)

LIVE_ENV=live
TEST_ENV=test

# Docker build args
BUILD_ARGS=--build-arg GIT_USERNAME=$(GITHUB_USERNAME) \
           --build-arg GIT_EMAIL=$(GITHUB_EMAIL) \

DOCKER_BUILDKIT=1

# Docker build and push
.PHONY: build push build-push all

# Build the Docker image with the specified tag
build:
	echo $(GITHUB_TOKEN) > .git_token_file
	docker build --secret id=git_token,src=.git_token_file $(BUILD_ARGS) -f Dockerfile -t $(IMAGE_NAME):$(IMAGE_TAG) .
	rm .git_token_file

# Push the Docker image to GitHub Container Registry
push:
	echo $(GITHUB_CONTAINER_TOKEN) | docker login ghcr.io -u $(GITHUB_USERNAME) --password-stdin
	docker tag $(IMAGE_NAME):$(IMAGE_TAG) $(IMAGE_NAME):latest
	docker push $(IMAGE_NAME):$(IMAGE_TAG)
	docker push $(IMAGE_NAME):latest

# Build the Docker image with both versioned tag and latest tag
build-push: build push

# Build and push with the specific tag
all: build push

--------------------------------------------------------------------------------

/==============================================================================\
| FILE: server\observer\observer.go
| PATH: C:\go\src\hydraide\app\server\observer\observer.go
| SIZE: 5.8 KB
\==============================================================================/

// Package observer provides utilities for graceful shutdown.
// It ensures that the server only shuts down after all ongoing processes
// have been completed, helping to avoid data loss.
package observer

import (
	"context"
	"fmt"
	"github.com/shirou/gopsutil/cpu"
	"log/slog"
	"math"
	"runtime"
	"runtime/debug"
	"strings"
	"sync"
	"time"
)

var allocMemoryBefore uint64
var allocMemoryPeak uint64
var processorLoadPeak float64
var goroutinePeak int

// Observer interface defines methods for tracking ongoing processes.
// It's especially useful for graceful shutdowns, ensuring that the system
// waits for all active tasks to finish.
type Observer interface {
	// StartProcess should be called at the beginning of every request or operation.
	// It registers a new active process that the server must wait for before shutting down.
	StartProcess(uid string, processName string)

	// EndProcess should be called when a process is finished.
	// It unregisters the process so the system knows it's safe to shut down if no more remain.
	EndProcess(uid string)

	// PushSubprocess allows you to track subprocesses within a main process,
	// especially helpful for diagnosing which parts took longest or caused potential deadlocks.
	PushSubprocess(uid string, processName string)

	// WaitingForAllProcessesFinished is a blocking method that halts execution
	// until all registered processes have been completed.
	// It is essential for implementing graceful shutdowns safely.
	WaitingForAllProcessesFinished()
}

type observer struct {
	mu           sync.RWMutex
	allProcesses map[string]*process
}

type process struct {
	name         string
	uuid         string
	insertTime   time.Time
	subprocesses []string
}

func New(ctx context.Context, systemResourceLogging bool) Observer {

	o := &observer{
		allProcesses: make(map[string]*process),
	}

	// start system resource logging only if the systemResourceLogging is true
	if systemResourceLogging {
		go func() {
			defer func() {
				if r := recover(); r != nil {
					stackTrace := debug.Stack()
					slog.Error("caught panic while detecting memory and processor peak", "error", r, "stack", string(stackTrace))
				}
			}()
			o.detectMemoryAndProcessorPeak(ctx)
		}()
	}

	return o
}

func (o *observer) StartProcess(uid string, processName string) {

	o.mu.Lock()
	defer o.mu.Unlock()

	o.allProcesses[uid] = &process{
		name:       processName,
		uuid:       uid,
		insertTime: time.Now(),
	}

}

func (o *observer) EndProcess(uid string) {
	o.mu.Lock()
	defer o.mu.Unlock()
	delete(o.allProcesses, uid)
}

func (o *observer) PushSubprocess(uid string, processName string) {

	o.mu.Lock()
	defer o.mu.Unlock()

	// if there is no main process we do nothing
	if _, ok := o.allProcesses[uid]; !ok {
		return
	}

	o.allProcesses[uid].subprocesses = append(o.allProcesses[uid].subprocesses, processName)

}

func (o *observer) WaitingForAllProcessesFinished() {
	// waiting for all processes to finish
	for {
		o.mu.RLock()
		if len(o.allProcesses) == 0 {
			slog.Info("all processes finished successfully", "processes", len(o.allProcesses))
			o.mu.RUnlock()
			return
		}

		// log the processes that are still running
		for _, p := range o.allProcesses {
			slog.Debug("waiting for process to finish to shutdown the server....",
				"process", p.name,
				"uuid", p.uuid,
				"subprocesses", strings.Join(p.subprocesses, ", "),
				"elapsedTimeInWaiting", time.Now().Sub(p.insertTime).String())
		}
		o.mu.RUnlock()
		time.Sleep(1 * time.Second)
	}
}

func (o *observer) detectMemoryAndProcessorPeak(ctx context.Context) {

	t := time.NewTicker(10 * time.Second)
	defer t.Stop()

	for {
		select {
		case <-t.C:

			var m runtime.MemStats
			runtime.ReadMemStats(&m)

			if m.Alloc > allocMemoryPeak {
				allocMemoryPeak = m.Alloc
			}

			if runtime.NumGoroutine() > goroutinePeak {
				goroutinePeak = runtime.NumGoroutine()
			}

			percent, err := cpu.Percent(5*time.Second, false)
			if err != nil {
				slog.Error("error while getting cpu percent", "error", err)
				continue
			}

			if len(percent) > 0 && percent[0] > processorLoadPeak {
				processorLoadPeak = math.Round(percent[0]*100) / 100
			}

			o.logMemoryPeak()

		case <-ctx.Done():

			return

		}
	}

}

func (o *observer) logMemoryPeak() {

	var m runtime.MemStats
	runtime.ReadMemStats(&m)

	// calculate the difference between the memory usage before and after the garbage collector
	var diff uint64
	prefix := "0"
	diff = 0
	if m.Alloc > allocMemoryBefore {
		diff = m.Alloc - allocMemoryBefore
		prefix = "+"
	} else if m.Alloc < allocMemoryBefore {
		diff = allocMemoryBefore - m.Alloc
		prefix = "-"
	}

	if diff < 0 {
		diff = 0
	}

	slog.Info("system resource log",
		slog.String("Act_Alloc", bytesToReadable(m.Alloc)),
		slog.String("Act_Diff", fmt.Sprintf("%s%s", prefix, bytesToReadable(diff))),
		slog.Int("Act_GoRoutines", runtime.NumGoroutine()),
		slog.Int("Peak_Goroutine", goroutinePeak),
		slog.Float64("Peak_ProcessorLoad", processorLoadPeak),
		slog.String("Peak_AllocMemory", bytesToReadable(allocMemoryPeak)),
		slog.Uint64("num_GC", uint64(m.NumGC)),
	)

	allocMemoryBefore = m.Alloc

}

func bytesToReadable(bytes uint64) string {

	const (
		_         = iota // ignore first value by assigning to blank identifier
		KB uint64 = 1 << (10 * iota)
		MB
		GB
		TB
	)

	switch {
	case bytes >= TB:
		return fmt.Sprintf("%.2fTB", float64(bytes)/float64(TB))
	case bytes >= GB:
		return fmt.Sprintf("%.2fGB", float64(bytes)/float64(GB))
	case bytes >= MB:
		return fmt.Sprintf("%.2fMB", float64(bytes)/float64(MB))
	case bytes >= KB:
		return fmt.Sprintf("%.2fKB", float64(bytes)/float64(KB))
	default:
		return fmt.Sprintf("%dB", bytes)
	}
}

--------------------------------------------------------------------------------

/==============================================================================\
| FILE: server\server\server.go
| PATH: C:\go\src\hydraide\app\server\server\server.go
| SIZE: 9.3 KB
\==============================================================================/

// Package server
package server

import (
	"context"
	"errors"
	"fmt"
	"github.com/hydraide/hydraide/app/core/filesystem"
	"github.com/hydraide/hydraide/app/core/settings"
	"github.com/hydraide/hydraide/app/core/zeus"
	"github.com/hydraide/hydraide/app/server/gateway"
	"github.com/hydraide/hydraide/app/server/observer"
	hydrapb "github.com/hydraide/hydraide/generated/hydraidepbgo"
	"google.golang.org/grpc"
	"google.golang.org/grpc/codes"
	"google.golang.org/grpc/credentials"
	"google.golang.org/grpc/keepalive"
	"google.golang.org/grpc/peer"
	"google.golang.org/grpc/status"
	"log/slog"
	"net"
	"os"
	"runtime/debug"
	"sync"
	"time"
)

const (
	maxDepth        = 1
	foldersPerLevel = 1000
)

type Configuration struct {
	CertificateCrtFile string // Server CRT file path
	CertificateKeyFile string // Server Key file path
	// Hydra settings
	HydraServerPort       int   // the port where the hydra server listens
	HydraMaxMessageSize   int   // the maximum message size in bytes
	DefaultCloseAfterIdle int64 // the default close after idle time in seconds
	DefaultWriteInterval  int64 // the default write interval time in seconds
	DefaultFileSize       int64 // the default file size in bytes
	SystemResourceLogging bool  // if true, the system resource usage is logged
}

type Server interface {
	// Start starts the microservice
	Start() error
	// Stop stops the microservice gracefully
	Stop()
	// IsHydraRunning returns true if the hydra server is running
	IsHydraRunning() bool
}

type server struct {
	configuration      *Configuration
	observerCancelFunc context.CancelFunc
	mu                 sync.RWMutex
	serverRunning      bool
	grpcServer         *grpc.Server
	zeusInterface      zeus.Zeus
	observerInterface  observer.Observer
}

func New(configuration *Configuration) Server {
	return &server{
		configuration: configuration,
	}
}

func (s *server) IsHydraRunning() bool {
	s.mu.RLock()
	defer s.mu.RUnlock()
	return s.serverRunning
}

func (s *server) Start() error {

	slog.Info("starting the hydra server...")
	// check if the server is already running
	s.mu.Lock()
	if s.serverRunning {
		s.mu.Unlock()
		return errors.New("hydra server is already running")
	}
	s.serverRunning = true
	s.mu.Unlock()

	settingsInterface := settings.New(maxDepth, foldersPerLevel)
	s.zeusInterface = zeus.New(settingsInterface, filesystem.New())
	s.zeusInterface.StartHydra()

	var ctx context.Context
	ctx, s.observerCancelFunc = context.WithCancel(context.Background())
	s.observerInterface = observer.New(ctx, s.configuration.SystemResourceLogging)

	grpcServer := gateway.Gateway{
		ObserverInterface:     s.observerInterface,
		SettingsInterface:     settingsInterface,
		ZeusInterface:         s.zeusInterface,
		DefaultCloseAfterIdle: s.configuration.DefaultCloseAfterIdle,
		DefaultWriteInterval:  s.configuration.DefaultWriteInterval,
		DefaultFileSize:       s.configuration.DefaultFileSize,
	}

	unaryInterceptor := func(
		ctx context.Context,
		req interface{},
		info *grpc.UnaryServerInfo,
		handler grpc.UnaryHandler,
	) (interface{}, error) {

		// Get the client's IP address
		clientIP := "unknown"
		if p, ok := peer.FromContext(ctx); ok {
			if addr, ok := p.Addr.(*net.TCPAddr); ok {
				clientIP = addr.IP.String()
			}
		}

		resp, err := handler(ctx, req)
		if err != nil {
			// Logging GRPC Server error
			if os.Getenv("GRPC_SERVER_ERROR_LOGGING") == "true" {
				if grpcErr, ok := status.FromError(err); ok {
					switch grpcErr.Code() {
					case codes.PermissionDenied:
						slog.Error("client request rejected: permission denied", "method", info.FullMethod, "clientIP", clientIP, "error", grpcErr.Message())
					case codes.Unauthenticated:
						slog.Error("client request rejected: unauthenticated", "method", info.FullMethod, "clientIP", clientIP, "error", grpcErr.Message())
					case codes.InvalidArgument:
						slog.Debug("client request rejected: invalid argument", "method", info.FullMethod, "clientIP", clientIP, "error", grpcErr.Message())
					case codes.ResourceExhausted:
						slog.Error("client request rejected: resource exhausted", "method", info.FullMethod, "clientIP", clientIP, "error", grpcErr.Message())
					case codes.FailedPrecondition:
						slog.Debug("client request rejected: failed precondition", "method", info.FullMethod, "clientIP", clientIP, "error", grpcErr.Message())
					case codes.Aborted:
						slog.Debug("client request rejected: aborted", "method", info.FullMethod, "clientIP", clientIP, "error", grpcErr.Message())
					case codes.OutOfRange:
						slog.Debug("client request rejected: out of range", "method", info.FullMethod, "clientIP", clientIP, "error", grpcErr.Message())
					case codes.Unavailable:
						slog.Error("client request rejected: unavailable", "method", info.FullMethod, "clientIP", clientIP, "error", grpcErr.Message())
					case codes.DataLoss:
						slog.Error("client request rejected: data loss", "method", info.FullMethod, "clientIP", clientIP, "error", grpcErr.Message())
					case codes.Unknown:
						slog.Debug("client request rejected: unknown error", "method", info.FullMethod, "clientIP", clientIP, "error", grpcErr.Message())
					case codes.Internal:
						slog.Error("client request rejected: internal server error", "method", info.FullMethod, "clientIP", clientIP, "error", grpcErr.Message())
					case codes.Unimplemented:
						slog.Warn("client request rejected: unimplemented", "method", info.FullMethod, "clientIP", clientIP, "error", grpcErr.Message())
					case codes.DeadlineExceeded:
						slog.Debug("client request rejected: deadline exceeded", "method", info.FullMethod, "clientIP", clientIP, "error", grpcErr.Message())
					case codes.Canceled:
						slog.Debug("client request rejected: canceled by client", "method", info.FullMethod, "clientIP", clientIP, "error", grpcErr.Message())
					default:
						slog.Error("client request rejected: unknown grpc error code", "method", info.FullMethod, "clientIP", clientIP, "error", grpcErr.Message())
					}
				} else {
					slog.Warn("client request rejected: non-gRPC error", "method", info.FullMethod, "clientIP", clientIP, "error", err.Error())
				}
			}
		}
		return resp, err
	}

	// start the main server and waiting for incoming requests
	go func() {

		defer func() {
			if r := recover(); r != nil {
				// get the stack trace
				stackTrace := debug.Stack()
				slog.Error("caught panic in hydra gRPC server", "error", r, "stack", string(stackTrace))
			}
		}()

		// start the gRPC server
		lis, err := net.Listen("tcp", fmt.Sprintf(":%d", s.configuration.HydraServerPort))
		if err != nil {
			slog.Error("can not create listener for the hydra server", "error", err)
			panic("can not create listener for the hydra server")
		}

		// load cert and key files for the server
		creds, err := credentials.NewServerTLSFromFile(s.configuration.CertificateCrtFile, s.configuration.CertificateKeyFile)
		if err != nil {
			slog.Error("failed to load TLS credentials", "error", err)
			panic("failed to load TLS credentials")
		}

		kaParams := keepalive.ServerParameters{
			// IF the connection is idle for 4 minutes, the server will send a keepalive ping.
			Time: 4 * time.Minute,
			// If there is no response to the keepalive ping within 20 seconds, the server will close the connection.
			Timeout: 20 * time.Second,
			// Maximum time a connection can be idle before it is closed.
			MaxConnectionIdle: 5 * time.Minute,
		}

		s.grpcServer = grpc.NewServer(
			grpc.Creds(creds),
			grpc.MaxSendMsgSize(s.configuration.HydraMaxMessageSize),
			grpc.MaxRecvMsgSize(s.configuration.HydraMaxMessageSize),
			grpc.UnaryInterceptor(unaryInterceptor), // add the interceptor
			grpc.KeepaliveParams(kaParams),          // keepalive parameters
		)

		// registering the server
		hydrapb.RegisterHydraideServiceServer(s.grpcServer, &grpcServer)

		slog.Info(fmt.Sprintf("HydrAIDE server is listening on port: %d", s.configuration.HydraServerPort))
		// create the server and start listening for requests
		if err = s.grpcServer.Serve(lis); err != nil {
			slog.Error("can not start the HydrAIDE server", "error", err)
		}

	}()

	return nil

}

// Stop stops the microservice gracefully
func (s *server) Stop() {

	slog.Info("stopping the HydrAIDE server...")
	// check if the server is already stopped
	s.mu.Lock()
	if !s.serverRunning {
		s.mu.Unlock()
		slog.Info("hydra server stopped gracefully. Program is exiting...")
		return
	}
	s.serverRunning = false
	s.mu.Unlock()

	if s.grpcServer != nil {
		// stops the gRPC server gracefully because we don't want to get new requests from the crawler
		s.grpcServer.GracefulStop()
	}

	// waiting for all processes to finish. This is a blocker function until all processes are finished
	if s.observerInterface != nil {
		slog.Info("waiting for all processes to finish in the background")
		s.observerInterface.WaitingForAllProcessesFinished()
		slog.Info("all processes are finished in the background")
	}

	if s.zeusInterface != nil {
		// stop the Hydra gracefully. This is a blocker function until all swamps are stopped gracefully
		s.zeusInterface.StopHydra()
		slog.Info("HydrAIDE server stopped gracefully. Program is exiting...")
	}

	// stop the observer's monitoring process
	s.observerCancelFunc()

}

--------------------------------------------------------------------------------

================================================================================
📊 GENERATION SUMMARY
================================================================================
✅ Successfully processed: 48 files
📁 Base directory: C:\go\src\hydraide\app
💾 Output file: C:\go\src\hydraide\NormalizedFile.txt
🕒 Generated: 2025-07-30 09:36:50
================================================================================
